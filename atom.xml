<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FLC</title>
  
  <subtitle>Wir müssen wissen, wir werden wissen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fsslc.github.io/"/>
  <updated>2020-03-21T04:23:31.493Z</updated>
  <id>https://fsslc.github.io/</id>
  
  <author>
    <name>FSSlc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Linux 实战技能 100 讲》笔记</title>
    <link href="https://fsslc.github.io/2020/03/21/Note-for-geektime-Linux-in-Action/"/>
    <id>https://fsslc.github.io/2020/03/21/Note-for-geektime-Linux-in-Action/</id>
    <published>2020-03-21T02:30:30.000Z</published>
    <updated>2020-03-21T04:23:31.493Z</updated>
    
    <content type="html"><![CDATA[<p>本文目的主要是对学习 《Linux 实战技能 100 讲》过程中的内容做记录，防止忘记，即便忘记了也可以再回来查。</p><p>极客专栏地址： <a href="https://time.geekbang.org/course/intro/193" target="_blank" rel="noopener">https://time.geekbang.org/course/intro/193</a></p><a id="more"></a><h2 id="第三章：-系统管理篇"><a href="#第三章：-系统管理篇" class="headerlink" title="第三章： 系统管理篇"></a>第三章： 系统管理篇</h2><h3 id="26-网络管理"><a href="#26-网络管理" class="headerlink" title="26 网络管理"></a>26 网络管理</h3><h4 id="网络状态查看工具"><a href="#网络状态查看工具" class="headerlink" title="网络状态查看工具"></a>网络状态查看工具</h4><p>早期使用 <code>net-tools</code> 工具集，现在较新的 Linux 发行版使用 <code>iproute2</code> 工具集。</p><p>简要介绍如下：</p><h5 id="1-net-tools"><a href="#1-net-tools" class="headerlink" title="1.net-tools"></a>1.net-tools</h5><ul><li>ifconfig<ul><li>eth0 第一块网卡</li><li>ens33 PCI-E 网卡</li><li>enp0s3 无法获取物理信息的 PCI-E 网卡</li><li>CentOS 7 使用了一致性网络设备命名，以上都不匹配则使用 eth0</li></ul></li><li>route</li><li>netstat</li></ul><h5 id="2-iproute2"><a href="#2-iproute2" class="headerlink" title="2.iproute2"></a>2.iproute2</h5><ul><li>ip</li><li>ss</li></ul><h4 id="网卡接口命名修改"><a href="#网卡接口命名修改" class="headerlink" title="网卡接口命名修改"></a>网卡接口命名修改</h4><ul><li>网卡命名规则受 <code>biosdevname</code> 和 <code>net.ifnames</code> 两个参数影响</li><li>编辑 <code>/etc/default/grub</code> 文件，增加 <code>biosdevname=0 net.ifnames=0</code></li><li>更新 grub<ul><li><code>#grub2-mkconfig -o /boot/grub2/grub.cfg</code></li></ul></li><li>重启<ul><li><code>#reboot</code></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">biosdevname</th><th style="text-align:center">net.ifnames</th><th style="text-align:center">网卡名</th></tr></thead><tbody><tr><td style="text-align:center">默认</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">ens33</td></tr><tr><td style="text-align:center">组合 1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">em1</td></tr><tr><td style="text-align:center">组合 2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">eth0</td></tr></tbody></table></div><blockquote><p>systemd 网络端口命名规则</p></blockquote><p><a href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/" target="_blank" rel="noopener">https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/</a></p><h3 id="27-查看网络配置"><a href="#27-查看网络配置" class="headerlink" title="27 查看网络配置"></a>27 查看网络配置</h3><h4 id="ifconfig-输出"><a href="#ifconfig-输出" class="headerlink" title="ifconfig 输出"></a>ifconfig 输出</h4><pre><code class="lang-bash">ifconfig/sbin/ifconfig</code></pre><pre><code class="lang-bash">enp0s31f6: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500        ether e8:6a:64:44:77:3c  txqueuelen 1000  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 16  memory 0xee300000-ee320000lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 1425567  bytes 5078552462 (4.7 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 1425567  bytes 5078552462 (4.7 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0wlp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.1.9  netmask 255.255.255.0  broadcast 192.168.1.255        inet6 fe80::92ed:8a43:7e6:6880  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 1c:1b:b5:3f:4b:4d  txqueuelen 1000  (Ethernet)        RX packets 78354285  bytes 111604642686 (103.9 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 40923681  bytes 4766853522 (4.4 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><ul><li><code>inet</code> 网卡的 ipv4 地址</li><li><code>inet6</code> 网卡的 ipv6 地址</li><li><code>ether</code> 网卡的 MAC 地址</li><li><code>RX</code>  <code>TX</code> 发送、接收数据包统计</li><li><code>lo</code> 代表本地环回 网卡，本地地址永远是 <code>127.0.0.1</code></li></ul><h4 id="查看网卡物理链接状态"><a href="#查看网卡物理链接状态" class="headerlink" title="查看网卡物理链接状态"></a>查看网卡物理链接状态</h4><p><strong>mii-tool - view, manipulate media-independent interface status</strong></p><pre><code class="lang-bash"># sudo mii-tool enp0s31f6enp0s31f6: no link</code></pre><h4 id="查看网关命令"><a href="#查看网关命令" class="headerlink" title="查看网关命令"></a>查看网关命令</h4><ul><li><code>route -n</code></li><li>使用 <code>-n</code> 参数不解析主机名</li></ul><pre><code class="lang-bash">--&gt;$ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    600    0        0 wlp2s0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-a1bd391f73c0192.168.1.0     0.0.0.0         255.255.255.0   U     600    0        0 wlp2s0</code></pre><ul><li><code>default</code> 表示默认网关</li></ul><h3 id="28-修改网络配置"><a href="#28-修改网络配置" class="headerlink" title="28 修改网络配置"></a>28 修改网络配置</h3><h4 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h4><ul><li><code>ifconfig &lt;接口&gt; &lt;IP地址&gt; [netmask 子网掩码]</code></li><li><code>ifup &lt;接口&gt;</code></li><li><code>ifdown &lt;接口&gt;</code></li></ul><h4 id="网关配置命令"><a href="#网关配置命令" class="headerlink" title="网关配置命令"></a>网关配置命令</h4><h5 id="添加网关"><a href="#添加网关" class="headerlink" title="添加网关"></a>添加网关</h5><p>添加默认网关：<br><code>route add default gw &lt;网关ip&gt;</code><br>添加明细路由：<br><code>route add -host &lt;指定ip&gt; gw &lt;网关ip&gt;</code><br><code>route add -net &lt;指定网段&gt; netmask &lt;子网掩码&gt;  gw &lt;网关ip&gt;</code> 访问某个网段的明细路由</p><h4 id="ip-命令"><a href="#ip-命令" class="headerlink" title="ip 命令"></a>ip 命令</h4><ul><li><code>ip addr ls</code> = <code>ifconfig</code></li><li><code>ip link set dev eth0 up</code> = <code>ipup eth0</code></li><li><code>ip addr add 10.0.0.1/24 dev eth1</code> = <code>ifconfig eth1 10.0.0.1/24 netmask 255.255.255.0</code></li><li><code>ip route add 10.0.0.1/24 via 192.168.0.1</code> = <code>route add -net 10.0.0.0 netmask 255.255.255.0 gw 192.168.0.1</code></li></ul><h3 id="29-网络故障排除"><a href="#29-网络故障排除" class="headerlink" title="29 网络故障排除"></a>29 网络故障排除</h3><p><strong>排除命令：</strong></p><ul><li><code>ping</code> 检测网络是否可达 , <code>-c</code> 指定次数</li><li><code>traceroute</code> 检测每一跳的情况 ； <code>-w</code> 等待时间</li><li><code>mtr</code> 检测包是否丢失 <code>My traceroute</code></li><li><code>nslookup</code> 域名查看 ip</li><li><code>telnet</code> 检查端口连接状态 <code>telnet www.baidu.com 80</code></li><li><code>tcpdump</code> 抓取数据包 <code>tcpdump -i any -n port 80</code>  <code>tcpdump -i any -n host 10.0.0.1</code>  <code>tcpdump -i any -n host 10,0.0.1 and port 80 -w /tmp/dump.txt</code></li><li><code>netstat</code> 端口查看状态 <code>-n</code> 显示 ip 地址， <code>t</code> tcp <code>-p</code> 进程 <code>l</code> listen</li><li><code>ss</code> 参数与 netstat 类似</li></ul><h3 id="30-网络管理和配置文件"><a href="#30-网络管理和配置文件" class="headerlink" title="30 网络管理和配置文件"></a>30 网络管理和配置文件</h3><h4 id="网络服务管理"><a href="#网络服务管理" class="headerlink" title="网络服务管理"></a>网络服务管理</h4><p>网络服务管理程序分为 SysV 和 systemd， 下面是常用的一些命令：</p><ul><li><code>service network start/stop/restart</code></li><li><code>chkconfig -list network</code>  <code>chkconfig --level 2345 network off/on</code></li><li><code>systemctl list-unit-files NetworkManager.service</code></li><li><code>systemctl start/stop/restart NetworkManager</code></li><li><code>systemctl enable/disable NetworkManager</code></li></ul><h4 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h4><ul><li><code>/et/sysconfig/network-scripts/ifcfg-**</code><ul><li><code>BOOTPROTO=dhcp/static/none</code></li><li><code>ONBOOT=&quot;yes&quot;/&quot;no&quot;</code></li><li><code>IPADDR</code>  <code>NETMASK</code>  <code>GATEWAY</code>  <code>DNS1</code>  <code>DNS2</code>  <code>DNS3</code></li></ul></li><li><code>/etc/hosts</code></li></ul><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><ul><li><code>hostname # 展示主机名</code></li><li><code>hostname NAME # 临时设置主机名</code></li><li><code>hostnamectl set-hostname NAME # 永久设置主机名</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文目的主要是对学习 《Linux 实战技能 100 讲》过程中的内容做记录，防止忘记，即便忘记了也可以再回来查。&lt;/p&gt;
&lt;p&gt;极客专栏地址： &lt;a href=&quot;https://time.geekbang.org/course/intro/193&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://time.geekbang.org/course/intro/193&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://fsslc.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://fsslc.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://fsslc.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 在 Linux 系统中禁用与解禁用户的账号</title>
    <link href="https://fsslc.github.io/2020/01/23/Translate-Locking-and-unlocking-accounts-on-Linux-systems/"/>
    <id>https://fsslc.github.io/2020/01/23/Translate-Locking-and-unlocking-accounts-on-Linux-systems/</id>
    <published>2020-01-23T13:43:13.000Z</published>
    <updated>2020-03-24T01:16:43.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总有这样的时候：有时你需要禁用某位 Linux 用户的账号，有时你还需要反过来解禁用户的账号。<br>本文将介绍一些管理用户访问的命令，并介绍它们背后的原理。</p></blockquote><p><img src="https://images.idgesg.net/images/article/2019/10/cso_cybersecurity_mysterious_padlock_complex_circuits_gold_by_sqback_gettyimages-1177918748_2400x1600-100813830-large.jpg" style="zoom:50%; text-align: center" /></p><a id="more"></a><p>假如你正管理着一台 <a href="https://www.networkworld.com/article/3215226/what-is-linux-uses-featres-products-operating-systems.html" target="_blank" rel="noopener">Linux</a> 系统，那么很有可能将遇到需要禁用一个账号的情况。可能是某人已经换了职位，他们是否还需要该账号仍是个问题；或许有理由相信再次使用该账号并没有大碍。不管上述哪种情况，知晓如何禁用账号并解禁账号都是你需要知道的知识。</p><p>需要你记住的一件重要的事是尽管有多种方法来禁用账号，但它们并不都达到相同的效果。假如用户使用公钥/私钥来使用该账号而不是使用密码来访问，那么你使用的某些命令来阻止用户获取该账号或许将不会生效。</p><h3 id="使用-passwd-来禁用一个账号"><a href="#使用-passwd-来禁用一个账号" class="headerlink" title="使用 passwd 来禁用一个账号"></a>使用 passwd 来禁用一个账号</h3><p>最为简单的用来禁用一个账号的方法是使用 <code>passwd -l</code> 命令。例如：</p><pre><code>$ sudo passwd -l tadpole</code></pre><p>上面这个命令的效果是在加密后的密码文件 <code>/etc/shadow</code> 中，用户对应的那一行的最前面加上一个 <code>!</code> 符号。这样就足够阻止用户使用密码来访问账号了。</p><p>在没有使用上述命令前，加密后的密码行如下所示（请注意第一个字符）：</p><pre><code>$6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPCnXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7:::</code></pre><p>而禁用该账号后，这一行将变为：</p><pre><code>!$6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPCnXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7:::</code></pre><p>在 tadpole 下一次尝试登录时，他可能会使用他原有的密码来尝试多次登录，但就是无法再登录成功了。另一方面，你则可以使用下面的命令来查看他这个账号的状态（<code>-S</code> = status）：</p><pre><code>$ sudo passwd -S tadpoletadpole L 10/15/2019 0 99999 7 -1</code></pre><p>第二项的 <code>L</code> 告诉你这个账号已经被禁用了。在该账号被禁用前，这一项应该是 <code>P</code>。如果显示的是 <code>NP</code> 则意味着该账号还没有设置密码。</p><p>命令 <code>usermod -L</code> 也具有相同的效果（添加 <code>!</code> 来禁用账号的使用）。</p><p>使用这种方法来禁用某个账号的一个好处是当需要解禁某个账号时非常容易。只需要使用一个文本编辑器或者使用 <code>passwd -u</code> 命令来执行相反的操作，即将添加的 <code>!</code> 移除即可。</p><pre><code>$ sudo passwd -u tadpolepasswd: password expiry information changed.</code></pre><p>但使用这种方式的问题是如果用户使用公钥/私钥对的方式来访问他/她的账号，这种方式将不能阻止他们使用该账号。</p><h3 id="使用-chage-命令来禁用账号"><a href="#使用-chage-命令来禁用账号" class="headerlink" title="使用 chage 命令来禁用账号"></a>使用 chage 命令来禁用账号</h3><p>另一种禁用用户账号的方法是使用 <code>chage</code> 命令，它可以帮助管理用户账号的过期日期。</p><pre><code>$ sudu chage -E0 tadpole$ sudo passwd -S tadpoletadpole P 10/15/2019 0 99999 7 -1</code></pre><p><code>chage</code> 命令将会稍微修改 <code>/etc/shadow</code> 文件。在这个使用 <code>:</code> 来分隔的文件（下面将进行展示）中，某行的第 8 项将被设置为 <code>0</code>（先前为空），这就意味着这个账号已经过期了。<code>chage</code> 命令会追踪密码更改期间的天数，通过选项也可以提供账号过期信息。第 8 项如果是 0 则意味着这个账号在 1970 年 1 月 1 日后的一天过期，当使用上面显示的那个命令时可以用来禁用账号。</p><pre><code>$ sudo grep tadpole /etc/shadow | foldtadpole:$6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPCnXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7::0:                                                    ^                                                    |                                                    +--- days until expiration</code></pre><p>为了执行相反的操作，你可以简单地使用下面的命令将放置在 <code>/etc/shadow</code> 文件中的 <code>0</code> 移除掉：</p><pre><code>% sudo chage -E-1 tadpole</code></pre><p>一旦一个账号使用这种方式被禁用，即便是无密码的 <a href="https://www.networkworld.com/article/3441777/how-the-linux-screen-tool-can-save-your-tasks-and-your-sanity-if-ssh-is-interrupted.html" target="_blank" rel="noopener">SSH</a> 登录也不能再访问该账号了。</p><hr><p>via: <a href="https://www.networkworld.com/article/3513982/locking-and-unlocking-accounts-on-linux-systems.html" target="_blank" rel="noopener">https://www.networkworld.com/article/3513982/locking-and-unlocking-accounts-on-linux-systems.html</a></p><p>作者：<a href="https://www.networkworld.com/author/Sandra-Henry_Stocker/" target="_blank" rel="noopener">Sandra Henry-Stocker</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总有这样的时候：有时你需要禁用某位 Linux 用户的账号，有时你还需要反过来解禁用户的账号。&lt;br&gt;本文将介绍一些管理用户访问的命令，并介绍它们背后的原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images.idgesg.net/images/article/2019/10/cso_cybersecurity_mysterious_padlock_complex_circuits_gold_by_sqback_gettyimages-1177918748_2400x1600-100813830-large.jpg&quot; style=&quot;zoom:50%; text-align: center&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Linux" scheme="https://fsslc.github.io/tags/Linux/"/>
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="禁用用户" scheme="https://fsslc.github.io/tags/%E7%A6%81%E7%94%A8%E7%94%A8%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 软件包来处理较为复杂的 JSON 文件</title>
    <link href="https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/"/>
    <id>https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/</id>
    <published>2019-12-16T08:04:26.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Python 软件包来处理较为复杂的 JSON 文件</p></blockquote><p>最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的<br>JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。</p><a id="more"></a><h2 id="复杂-json-示例"><a href="#复杂-json-示例" class="headerlink" title="复杂 json 示例"></a>复杂 json 示例</h2><p>下面展示的是一个较为复杂的 JSON 数据，这里列出只是展示一个较为复杂的 JSON 数据会怎么复杂。</p><pre><code class="lang-json">[    // 一个 data group 根数据库的示例    {        // 首先是激活条件        &quot;active&quot;: {            &quot;ref-library&quot;: &quot;&quot;,            &quot;ref-library_name&quot;: &quot;&quot;,            &quot;ref-value&quot;: &quot;&quot;,            &quot;ref_path&quot;: &quot;&quot;,            &quot;type&quot;: &quot;Condition_Default&quot;        },        // 接着是它包含的键值对，可包含多个，这里只显示一个        &quot;items&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;enum_list&quot;: null,                &quot;max&quot;: null,                &quot;min&quot;: null,                &quot;name&quot;: &quot;periodic_dimension&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;int_array&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/periodic_dimension&quot;,                &quot;value&quot;: &quot;0,0,0&quot;            }        ],        // 然后是它包含的子数据库，可能会嵌套        &quot;librarys&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;items&quot;: [                    {                        &quot;active&quot;: {                            &quot;ref-library&quot;: &quot;&quot;,                            &quot;ref-library_name&quot;: &quot;&quot;,                            &quot;ref-value&quot;: &quot;&quot;,                            &quot;ref_path&quot;: &quot;&quot;,                            &quot;type&quot;: &quot;Condition_Default&quot;                        },                        &quot;enum_list&quot;: null,                        &quot;max&quot;: null,                        &quot;min&quot;: null,                        &quot;name&quot;: &quot;SAT_MODEL&quot;,                        &quot;show&quot;: {                            &quot;show_on_interface&quot;: false                        },                        &quot;type&quot;: &quot;string&quot;,                        &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel/SAT_MODEL&quot;,                        &quot;value&quot;: &quot;model.sat&quot;                    }                ],                &quot;librarys&quot;: [],                &quot;name&quot;: &quot;CADModel&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;Library_Fixed&quot;,                &quot;uid&quot;: &quot;{b717c641-4145-44ac-8468-efb7afa451f1}&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel&quot;            }        ],        // 最后是 data group 的额外属性        &quot;name&quot;: &quot;CartesianGeometry&quot;,        &quot;show&quot;: {            &quot;show_name&quot;: &quot;CartesianGeometry&quot;,            &quot;show_on_interface&quot;: true        },        &quot;type&quot;: &quot;Library_Fixed&quot;,        &quot;uid&quot;: &quot;{909515c3-d978-4021-943b-0d6e7fc3136d}&quot;,        &quot;unique_name&quot;: &quot;/CartesianGeometry&quot;    },    // 后面再添加类似的其他 data group]</code></pre><h2 id="Python-标准库中对-json-数据的处理"><a href="#Python-标准库中对-json-数据的处理" class="headerlink" title="Python 标准库中对 json 数据的处理"></a>Python 标准库中对 json 数据的处理</h2><p>在 Python 标准库中，自带 json 模块，可以使用 <code>import json</code> 来使用它。</p><p>主要的函数有如下几个：</p><ul><li><code>json.dumps</code>：将 Python 对象序列化为 json 字符串</li><li><code>json.dump</code>：将 Python 对象序列化为 json 对象</li><li><code>json.loads</code>：将 json 字符串导入为 Python 对象</li><li><code>json.load</code>：将 json 对象导入为 Python 对象</li></ul><p>另外，<code>json</code> 模块还提供一个命令行接口 <code>json.tool</code>，可以在终端中使用，常用的例子如下：</p><pre><code class="lang-bash">$ echo &#39;{&quot;json&quot;: &quot;obj&quot;}&#39; | python -m json.tool{    &quot;json&quot;: &quot;obj&quot;}</code></pre><p>另外最为常见的使用场景是读入 json 文件的数据，然后经过修改，再将 json 数据写回 json 文件中。</p><p>下面的代码就展示这两个常用的使用场景：</p><pre><code class="lang-python"># 打开文件将 json 数据读入 data_json 对象中with open(modelFile) as f:    data_json = json.load(f)# 打开新文件，将 data_json 数据写入新的 json 文件中with open(modModleFile, &#39;w&#39;) as f:    f.write(json.dumps(data_json, indent=2))</code></pre><h2 id="常见处理-JSON-的-Python-软件包"><a href="#常见处理-JSON-的-Python-软件包" class="headerlink" title="常见处理 JSON 的 Python 软件包"></a>常见处理 JSON 的 Python 软件包</h2><p>针对上面我们的需求，需要对复杂 JSON 数据做处理，所以就在网上进行了相关的搜索。<br>针对 JSON 数据的筛选，搜索后知道有个 <code>JSONPath</code> 的提议，仿照<br>XPath 的语法来查询 JSON 数据。</p><p>然后就根据 JSONPath 这个关键字在 PyPI 中搜索都了一些软件包，下面简单罗列一下：</p><h3 id="dpath"><a href="#dpath" class="headerlink" title="dpath"></a>dpath</h3><p>主页：<a href="https://www.github.com/akesterson/dpath-python" target="_blank" rel="noopener">https://www.github.com/akesterson/dpath-python</a><br>特点：使用类型 XPath 的语法来对复杂 json 数据做查询<br>优点：如果熟悉 XPath 的话，可以快速上手<br>缺点：无法做复杂的模糊查询，需要知道大致路径来获取数据</p><h3 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h3><p>主页：www.ultimate.com/phil/python/#jsonpath<br>特点：是对上面 jsonPath 提议的一个实现，经过测试发现，相比于后面提及的这些软件，它的查询效率最高<br>优点：查询效率高，单文件的实现<br>缺点：缺乏文档，开发久远；但还在持续更新</p><h3 id="jsonpath2"><a href="#jsonpath2" class="headerlink" title="jsonpath2"></a>jsonpath2</h3><p>主页：<a href="https://pypi.org/project/jsonpath2/" target="_blank" rel="noopener">https://pypi.org/project/jsonpath2/</a><br>特点：是对上面 jsonPath 提议的一个实现，有  ANTLR v4 的语法支持，可以生成 antlr 语法解析<br>优点：支持 antlr 语法<br>缺点：文档太少，只是 jsonPath 的又一个实现，特点不突出</p><h3 id="jsonpath-rw"><a href="#jsonpath-rw" class="headerlink" title="jsonpath-rw"></a>jsonpath-rw</h3><p>主页：<a href="https://github.com/kennknowles/python-jsonpath-rw" target="_blank" rel="noopener">https://github.com/kennknowles/python-jsonpath-rw</a><br>特点：提供健壮的实现，在 Python 2.7, 3.4, 3.5, 3.6, 3.7, pypy 和 pypy3 上都测试过； 实现早，开发者多（15），GitHub 上的星多（434）；<br>优点：开发者多，将 jsonPath 表达式当做第一类对象<br>缺点：无法对数据做复杂的筛选</p><h3 id="jsonpath-rw-ext"><a href="#jsonpath-rw-ext" class="headerlink" title="jsonpath-rw-ext"></a>jsonpath-rw-ext</h3><p>主页：<a href="https://github.com/sileht/python-jsonpath-rw-ext" target="_blank" rel="noopener">https://github.com/sileht/python-jsonpath-rw-ext</a><br>特点：对上面的 jsonpath-rw 做了一些扩展，尤其是对筛选的支持<br>优点：支持筛选<br>缺点：文档不是太详细，<a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">筛选似乎只支持 list</a></p><h3 id="jsonpath-ng"><a href="#jsonpath-ng" class="headerlink" title="jsonpath-ng"></a>jsonpath-ng</h3><p>主页：<a href="https://github.com/h2non/jsonpath-ng" target="_blank" rel="noopener">https://github.com/h2non/jsonpath-ng</a><br>特点：结合了上面 jsonpath-rw 和 jsonpath-rw-ext 的能力，是  jsonpath-rw 的一个 fork<br>优点：具有上面两个包的功能，才能使用；文档详细<br>缺点：扩展的使用有点不太方便</p><p>在查找到了这些软件包后，我针对它们都进行了一些测试，最后测试后发现，在查询方面， jsonpath 这个包的解析速度最快。</p><blockquote><p>注：同时引入 jsonpath 和  jsonpath-rw-ext 会引起冲突，我的解决办法是只安装  jsonpath-rw-ext ，将 jsonpath 的单文件实现直接放入代码中，要使用时再引入。</p></blockquote><p>下面回到整体，介绍如何对复杂 JSON 数据进行查询、筛选和修改。</p><h2 id="如何查询复杂-json-数据"><a href="#如何查询复杂-json-数据" class="headerlink" title="如何查询复杂 json 数据"></a>如何查询复杂 json 数据</h2><p>经过了上面的搜索，简单来说可以直接使用上面的多个软件包，然后按照 JsonPath 的语法来对复杂数据进行查询。</p><p>下面是 JsonPath 的提议，摘自上面提及的<a href="https://goessner.net/articles/JsonPath/" target="_blank" rel="noopener">网址</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">JSONPath</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">代表根对象</td></tr><tr><td style="text-align:center"><code>@</code></td><td style="text-align:center">代表当前对象</td></tr><tr><td style="text-align:center"><code>.</code> 或 <code>[]</code></td><td style="text-align:center">取孩子操作</td></tr><tr><td style="text-align:center"><code>..</code></td><td style="text-align:center">递归搜索后代</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">通配符，代表所有对象</td></tr><tr><td style="text-align:center"><code>[]</code></td><td style="text-align:center">取下标操作，在 JSON 中，它是自带的数组操作</td></tr><tr><td style="text-align:center"><code>[,]</code></td><td style="text-align:center">表示去其中的任意一个</td></tr><tr><td style="text-align:center"><code>[start:end:step]</code></td><td style="text-align:center">数组切片操作</td></tr><tr><td style="text-align:center"><code>?()</code></td><td style="text-align:center">执行筛选操作</td></tr><tr><td style="text-align:center"><code>()</code></td><td style="text-align:center">脚本表达式，不常用</td></tr></tbody></table></div><h2 id="如何筛选复杂-json-数据"><a href="#如何筛选复杂-json-数据" class="headerlink" title="如何筛选复杂 json 数据"></a>如何筛选复杂 json 数据</h2><p>基于前面的搜索，如果要实现对复杂 json 数据的筛选功能，当前就只能使用上面的 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> ，其中 <code>jsonpath-ng</code> 的筛选功能来自于 <code>jsonpath-rw-ext</code>，所以在最后的解决方案中，我直接使用了 <code>jsonpath-rw-ext</code> 来做复杂筛选。</p><p>在使用时，为了支持变量值的替换，可能还需要使用转义符。</p><p>另外，在做筛选时，可以利用 jsonPath 中 <code>..</code> <code>@</code> 等运算符来做模糊筛选。</p><p>具体的使用方法可以参考上面两个软件包的主页。这里就不再介绍。</p><p>下面重点介绍如何修改 json 数据。</p><h2 id="如何修改复杂-json-数据"><a href="#如何修改复杂-json-数据" class="headerlink" title="如何修改复杂 json 数据"></a>如何修改复杂 json 数据</h2><p>基于上面的说明，我们知道可以使用上面的这些软件包来查询复杂 json ，但是对于如何修改数据，这些软件的文档中都没有太多的涉及。</p><p>另外根据我做的这个任务的需求，可能还需要在对 json 数据做了筛选后，再对筛选到的数据做修改。</p><p><code>python-jsonpath-rw</code> GitHub 主页上的 <a href="https://github.com/kennknowles/python-jsonpath-rw/issues/21" target="_blank" rel="noopener">issue 21</a> 上有类似的说明，但自己根据上的说明去实现时，感觉无法满足上面的需求，故作罢。</p><p>另外 <code>python-jsonpath-rw</code> 在代码仓库中似乎更新了一个 <code>update</code> 方法，但没有更新到 PyPI 中，所以必须下载 GitHub 的代码才能使用该功能。在最后的实现时便没有使用该功能。</p><p>最终，我在 stack overflow 上找到了一个参考的<a href="https://stackoverflow.com/questions/37646631/modify-an-element-in-a-nested-dict-given-a-path-to-it" target="_blank" rel="noopener">例子</a>：</p><pre><code class="lang-python">from jsonpath_rw import jsonpath, parsedata = {&quot;dogs&quot;:[{&quot;tail&quot;: True, &quot;properties&quot;:{&quot;test&quot;:1}}]}jsonpath_expr = parse(&quot;dogs.[0].properties&quot;)jsonpath_expr.find(data)[0].value[&#39;test&#39;] = 2print(data)# {&#39;dogs&#39;: [{&#39;tail&#39;: True, &#39;properties&#39;: {&#39;test&#39;: 2}}]}</code></pre><p>通过上面的例子我得到启发，可以使用 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> 包的筛选功能，再使用上面例子中类型的做法来达到筛选并修改特定键值的目的，这样我的需求就可以解决了。</p><p>在经过测试后，最终用来修改 input 模板文件中给定键值对的代码如下：</p><pre><code class="lang-python">import jsonimport jsonpath_rw_extdef Modify_model(refVar, refValue, modelFile, modModleFile=&#39;run.json&#39;):    &quot;&quot;&quot;利用 jsonpath_rw_ext 库搜索 json 格式的模板文件，并修改相应的值        refVar: 需要修改的参数的名称        refValue: 修改过后参数的值        modelFile: json 格式的模板文件        modModleFile: 修改过后的 json 模板文件    &quot;&quot;&quot;    with open(modelFile) as f:        data_json = json.load(f)    parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;    jsonpath_rw_ext.parser.ExtentedJsonPathParser().parse(parse_str).find(data_json)[0].value[&#39;value&#39;] = f&#39;{refValue}&#39;    if not os.path.exists(modModleFile):        # 如果不存在文件，则直接创建空文件        # ref: https://stackoverflow.com/questions/12654772/create-empty-file-using-python        open(modModleFile, &#39;a&#39;).close()    with open(modModleFile, &#39;w&#39;) as f:        f.write(json.dumps(data_json, indent=2))</code></pre><p>上面的代码中有几点需要说明：</p><ol><li><p><code>parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;</code> 这句使用了 Python 的新语法，直接将 refVar 的值替换到字符串中，这需要 Python 3.6 才能支持。另外还转义了括号，使得这个函数更加通用；</p></li><li><p><code>jsonpath_rw_ext.parser.ExtentedJsonPathParser()</code> 这句是为了使用扩展功能才这样写的，具体的使用方法可以参考其主页章的文档；</p></li><li>根据 <a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">GitHub 上的 issue</a>，似乎筛选功能只对 list 生效，相关代码在<a href="https://github.com/h2non/jsonpath-ng/blob/master/jsonpath_ng/ext/filter.py#L42" target="_blank" rel="noopener">这里</a>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 Python 软件包来处理较为复杂的 JSON 文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的&lt;br&gt;JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Python" scheme="https://fsslc.github.io/tags/Python/"/>
    
      <category term="JSON" scheme="https://fsslc.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] Gifski：一个跨平台的高质量 GIF 编码器</title>
    <link href="https://fsslc.github.io/2018/11/02/Translate-A-Cross-platform-High-quality-GIF-Encoder/"/>
    <id>https://fsslc.github.io/2018/11/02/Translate-A-Cross-platform-High-quality-GIF-Encoder/</id>
    <published>2018-11-02T13:11:44.000Z</published>
    <updated>2020-03-24T01:04:01.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍一个 GIF 制作工具 Gifski</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.ostechnix.com/wp-content/uploads/2018/09/gifski-720x340.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>作为一名文字工作者，我需要在我的文章中添加图片。有时为了更容易讲清楚某个概念，我还会添加视频或者 gif 动图，相比于文字，通过视频或者 gif 格式的输出，读者可以更容易地理解我的指导。前些天，我已经写了篇文章来介绍针对 Linux 的功能丰富的强大截屏工具 <a href="https://linux.cn/article-10180-1.html" target="_blank" rel="noopener">Flameshot</a>。今天，我将向你展示如何从一段视频或者一些图片来制作高质量的 gif 动图。这个工具就是 <strong>Gifski</strong>，一个跨平台、开源、基于 <strong>Pngquant</strong> 的高质量命令行 GIF 编码器。</p><a id="more"></a><p>对于那些好奇 pngquant 是什么的读者，简单来说 pngquant 是一个针对 PNG 图片的无损压缩命令行工具。相信我，pngquant 是我使用过的最好的 PNG 无损压缩工具。它可以将 PNG 图片最高压缩 <strong>70%</strong> 而不会损失图片的原有质量并保存了所有的阿尔法透明度。经过压缩的图片可以在所有的网络浏览器和系统中使用。而 Gifski 是基于 Pngquant 的，它使用 pngquant 的功能来创建高质量的 GIF 动图。Gifski 能够创建每帧包含上千种颜色的 GIF 动图。Gifski 也需要 <strong>ffmpeg</strong> 来将视频转换为 PNG 图片。</p><h3 id="安装-Gifski"><a href="#安装-Gifski" class="headerlink" title="安装 Gifski"></a>安装 Gifski</h3><p>首先需要确保你安装了 FFMpeg 和 Pngquant。</p><p>FFmpeg 在大多数的 Linux 发行版的默认软件仓库中都可以获取到，所以你可以使用默认的包管理器来安装它。具体的安装过程，请参考下面链接中的指导。</p><ul><li><a href="https://www.ostechnix.com/install-ffmpeg-linux/" target="_blank" rel="noopener">在 Linux 中如何安装 FFmpeg</a></li></ul><p>Pngquant 可以从 <a href="https://aur.archlinux.org/packages/pngquant/" target="_blank" rel="noopener">AUR</a> 中获取到。要在基于 Arch 的系统安装它，使用任意一个 AUR 帮助程序即可，例如下面示例中的 <a href="https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/" target="_blank" rel="noopener">Yay</a>：</p><pre><code class="lang-bash">$ yay -S pngquant</code></pre><p>在基于 Debian 的系统中，运行：</p><pre><code class="lang-bash">$ sudo apt install pngquant</code></pre><p>假如在你使用的发行版中没有 pngquant，你可以从源码编译并安装它。为此你还需要安装 <code>libpng-dev</code> 包。</p><pre><code class="lang-bash">$ git clone --recursive https://github.com/kornelski/pngquant.git$ make$ sudo make install</code></pre><p>安装完上述依赖后，再安装 Gifski。假如你已经安装了 <a href="https://www.ostechnix.com/install-rust-programming-language-in-linux/" target="_blank" rel="noopener">Rust</a> 编程语言，你可以使用 <strong>cargo</strong> 来安装它：</p><pre><code class="lang-bash">$ cargo install gifski</code></pre><p>另外，你还可以使用 <a href="https://www.ostechnix.com/linuxbrew-common-package-manager-linux-mac-os-x/" target="_blank" rel="noopener">Linuxbrew</a> 包管理器来安装它：</p><pre><code class="lang-bash">$ brew install gifski</code></pre><p>假如你不想安装 cargo 或 Linuxbrew，可以从它的 <a href="https://github.com/ImageOptim/gifski/releases" target="_blank" rel="noopener">发布页面</a> 下载最新的二进制程序，或者手动从源码编译并安装 gifski 。</p><h3 id="使用-Gifski-来创建高质量的-GIF-动图"><a href="#使用-Gifski-来创建高质量的-GIF-动图" class="headerlink" title="使用 Gifski 来创建高质量的 GIF 动图"></a>使用 Gifski 来创建高质量的 GIF 动图</h3><p>进入你保存 PNG 图片的目录，然后运行下面的命令来从这些图片创建 GIF 动图：</p><pre><code class="lang-bash">$ gifski -o file.gif *.png</code></pre><p>上面的 <code>file.gif</code> 为最后输出的 gif 动图。</p><p>Gifski 还有其他的特性，例如：</p><ul><li>创建特定大小的 GIF 动图</li><li>在每秒钟展示特定数目的动图</li><li>以特定的质量编码</li><li>更快速度的编码</li><li>以给定顺序来编码图片，而不是以排序的结果来编码</li></ul><p>为了创建特定大小的 GIF 动图，例如宽为 800，高为 400，可以使用下面的命令：</p><pre><code class="lang-bash">$ gifski -o file.gif -W 800 -H 400 *.png</code></pre><p>你可以设定 GIF 动图在每秒钟展示多少帧，默认值是 <strong>20</strong>。为此，可以运行下面的命令：</p><pre><code class="lang-bash">$ gifski -o file.gif --fps 1 *.png</code></pre><p>在上面的例子中，我指定每秒钟展示 1 帧。</p><p>我们还能够以特定质量（1-100 范围内）来编码。显然，更低的质量将生成更小的文件，更高的质量将生成更大的 GIF 动图文件。</p><pre><code class="lang-bash">$ gifski -o file.gif --quality 50 *.png</code></pre><p>当需要编码大量图片时，Gifski 将会花费更多时间。如果想要编码过程加快到通常速度的 3 倍左右，可以运行：</p><pre><code class="lang-bash">$ gifski -o file.gif --fast *.png</code></pre><p>请注意上面的命令产生的 GIF 动图文件将减少 10% 的质量，并且文件大小也会更大。</p><p>如果想让图片以某个给定的顺序（而不是通过排序）精确地被编码，可以使用 <code>--nosort</code> 选项。</p><pre><code class="lang-bash">$ gifski -o file.gif --nosort *.png</code></pre><p>假如你不想让 GIF 循环播放，只需要使用 <code>--once</code> 选项即可：</p><pre><code class="lang-bash">$ gifski -o file.gif --once *.png</code></pre><h3 id="从视频创建-GIF-动图"><a href="#从视频创建-GIF-动图" class="headerlink" title="从视频创建 GIF 动图"></a>从视频创建 GIF 动图</h3><p>有时或许你想从一个视频创建 GIF 动图。这也是可以做到的，这时候 FFmpeg 便能提供帮助。首先像下面这样，将视频转换成一系列的 PNG 图片：</p><pre><code class="lang-bash">$ ffmpeg -i video.mp4 frame%04d.png</code></pre><p>上面的命令将会从 <code>video.mp4</code> 这个视频文件创建名为 “frame0001.png”、“frame0002.png”、“frame0003.png” 等等形式的图片（其中的 <code>%04d</code> 代表帧数），然后将这些图片保存在当前的工作目录。</p><p>转换好图片后，只需要运行下面的命令便可以制作 GIF 动图了：</p><pre><code class="lang-bash">$ gifski -o file.gif *.png</code></pre><p>想知晓更多的细节，请参考它的帮助部分：</p><pre><code class="lang-bash">$ gifski -h</code></pre><p>下面是使用 Gifski 创建的示例 GIF 动图文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gif.ski/jazz-chromecast-ultra.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>正如你看到的那样，GIF 动图的质量看起来是非常好的。</p><p>好了，这就是全部内容了。希望这篇指南对你有所帮助。更多精彩内容即将呈现，请保持关注！</p><p>干杯吧！</p><hr><p>via: <a href="https://www.ostechnix.com/gifski-a-cross-platform-high-quality-gif-encoder/" target="_blank" rel="noopener">https://www.ostechnix.com/gifski-a-cross-platform-high-quality-gif-encoder/</a><br>publish: <a href="https://linux.cn/article-10186-1.html" target="_blank" rel="noopener">https://linux.cn/article-10186-1.html</a></p><p>作者：<a href="https://www.ostechnix.com/author/sk/" target="_blank" rel="noopener">SK</a><br>选题：<a href="https://github.com/lujun9972" target="_blank" rel="noopener">lujun9972</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍一个 GIF 制作工具 Gifski&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://www.ostechnix.com/wp-content/uploads/2018/09/gifski-720x340.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;作为一名文字工作者，我需要在我的文章中添加图片。有时为了更容易讲清楚某个概念，我还会添加视频或者 gif 动图，相比于文字，通过视频或者 gif 格式的输出，读者可以更容易地理解我的指导。前些天，我已经写了篇文章来介绍针对 Linux 的功能丰富的强大截屏工具 &lt;a href=&quot;https://linux.cn/article-10180-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flameshot&lt;/a&gt;。今天，我将向你展示如何从一段视频或者一些图片来制作高质量的 gif 动图。这个工具就是 &lt;strong&gt;Gifski&lt;/strong&gt;，一个跨平台、开源、基于 &lt;strong&gt;Pngquant&lt;/strong&gt; 的高质量命令行 GIF 编码器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Gif" scheme="https://fsslc.github.io/tags/Gif/"/>
    
      <category term="Gifski" scheme="https://fsslc.github.io/tags/Gifski/"/>
    
  </entry>
  
  <entry>
    <title>linux 下使用 matlab 的几个小提示</title>
    <link href="https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/"/>
    <id>https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/</id>
    <published>2018-07-31T09:39:30.000Z</published>
    <updated>2020-03-21T06:37:59.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux 下使用 matlab 的几个小提示</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200321143505.png" alt="MATLAB LOGO" title="">                </div>                <div class="image-caption">MATLAB LOGO</div>            </figure><p>嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。</p><p>在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>大部分都是直接使用桌面版本来安装 matlab 的。所以先说说这种方法。</p><p>安装无外乎以下几步：</p><ol><li>下载到 iso 镜像：这个不用多说，自己找资源。</li><li>挂载或者解压：挂载使用 <code>mount</code> 命令即可。</li><li>使用命令行安装：运行目录里面的 <code>install</code> 脚本后就会出来图形界面，接下来的安装过程与 windows 下的安装过程没有什么区别了。</li><li>激活：参考资源内的说明文档。</li></ol><p>如果需要在没有桌面的 linux 中安装 matlab，则需要编辑压缩包里面的 <code>installer_input.txt</code> 和 <code>activate.ini</code> 这两个文件，具体的安装过程请参考<a href="https://blog.csdn.net/smartzmz/article/details/41823187" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="终端使用-matlab"><a href="#终端使用-matlab" class="headerlink" title="终端使用 matlab"></a>终端使用 matlab</h2><p>一般启动 MATLAB 使用如下命令：</p><pre><code class="lang-bash">matlab -nodesktop -nodisplay</code></pre><p>跟启动相关的命令主要有如下几个：</p><ol><li><p><strong>-nodesktop</strong>: 启动 jvm (Jave Virtual Machine)，不启动 desktop， 但 help 界面，preferences 界面等仍可通过 cmdline 调出，即 jvm 启动但不启动 desktop，可以启动其他显示； 但是 matlab 不会在 cmd history 记录本次执行的命令。</p></li><li><p><strong>-nodisplay</strong>: 启动 jvm，不启动 desktop，不启动任何显示相关，忽略任何 DISPLAY 环境变量； 即 jvm 启动但不能显示。</p></li><li><p><strong>-nojvm</strong>: 不启动 jvm，则与之相关的一切活动将无法进行，包括图形界面显示，help 界面，preferences界面等，即 jvm 不启动故不能显示。</p></li><li><p><strong>-nosplash</strong>: 只是不显示启动时的log画面，jvm，desktop等正常启动</p></li></ol><p>如果想在让在终端中实现画图，一般需要做以下两步：</p><ol><li>使用 <code>matlab -nodesktop</code> 来启动 matlab；</li><li>在脚本中添加 <code>figure(&#39;Visible&#39;,&#39;off&#39;);</code> 这样的句子来抑制画图窗口的弹出。</li><li>可以使用 print 来保存图片。例如如下的命令：</li></ol><pre><code class="lang-matlab">print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-dpng&#39;);print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-depsc&#39;);</code></pre><p>记得要提前使用 <code>mkdir</code> 创建好在上级目录，图片名称的次级目录如果不存在，matlab 会自动创建。</p><h2 id="matlab-使用-gpu"><a href="#matlab-使用-gpu" class="headerlink" title="matlab 使用 gpu"></a>matlab 使用 gpu</h2><p>matlab 里面对 gpu 的使用做了封装，如果需要使用 NVIDIA 的 gpu ， 一般需要安装 Bumblebee， 然后使用 <code>optirun</code> 来运行。具体可以参考如下几个链接：<br>1.<a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/NVIDIA_Optimus</a><br>2.<a href="https://wiki.archlinux.org/index.php/Bumblebee" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Bumblebee</a></p><p>matlab 里面可以通过 <code>opengl info</code> 来查看使用了什么 gpu。</p><h2 id="几个常见问题"><a href="#几个常见问题" class="headerlink" title="几个常见问题"></a>几个常见问题</h2><p>下面的几个问题常常与 matlab 自带的几个动态链接库有关。一般把这些库备份后，将系统中安装的对应包链接到 matlab 里面就可以了。具体的问题见下面的详细解释</p><h3 id="帮助系统没有-CSS-渲染效果"><a href="#帮助系统没有-CSS-渲染效果" class="headerlink" title="帮助系统没有 CSS 渲染效果"></a>帮助系统没有 CSS 渲染效果</h3><p>字体问题常常与 <code>libfreetype.so</code> 这个动态链接库有关。所以解决办法无非以下几步：</p><pre><code class="lang-bash">sudo mv /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6.BAK # 备份sudo ln -sf /usr/lib64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 # 链接</code></pre><h3 id="libGL-error-for-MATLAB"><a href="#libGL-error-for-MATLAB" class="headerlink" title="libGL error for MATLAB"></a><a href="https://askubuntu.com/questions/841785/libgl-error-for-matlab" target="_blank" rel="noopener">libGL error for MATLAB</a></h3><p>解决办法：</p><pre><code class="lang-bash">ln -sf /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /opt/MATLAB/XXXXX(R2014b)/sys/os/glnxa64/libstdc++.so.6 # 或者执行cd MATLAB_ROOT/sys/os/glnxa64/sudo mv libstdc++.so.6 libstdc++.so.6.old</code></pre><h3 id="无法使用并行工具箱"><a href="#无法使用并行工具箱" class="headerlink" title="无法使用并行工具箱"></a>无法使用并行工具箱</h3><p>解决办法同上，链接系统的 <code>libstdc++.so.6</code> 这个动态库。</p><h3 id="matlab-无法使用系统中文字体"><a href="#matlab-无法使用系统中文字体" class="headerlink" title="matlab 无法使用系统中文字体"></a>matlab 无法使用系统中文字体</h3><p>参考： <a href="https://bbs.archlinux.org/viewtopic.php?id=231299" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=231299</a></p><pre><code class="lang-bash">cd  /usr/local/MATLAB/R2017b # Matlab directorycd bin/glnxa64mkdir excludemv libfreetype* excludecd ../../sys/os/glnxa64mkdir excludemv libstdc++.so.6* exclude</code></pre><p>或者跟上面的解决方法类似，备份文件后做链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;linux 下使用 matlab 的几个小提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200321143505.png&quot; alt=&quot;MATLAB LOGO&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;MATLAB LOGO&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。&lt;/p&gt;
&lt;p&gt;在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="matlab" scheme="https://fsslc.github.io/tags/matlab/"/>
    
      <category term="linux" scheme="https://fsslc.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 递归：梦中梦</title>
    <link href="https://fsslc.github.io/2018/05/06/Translate-Recursion--dream-within-a-dream/"/>
    <id>https://fsslc.github.io/2018/05/06/Translate-Recursion--dream-within-a-dream/</id>
    <published>2018-05-06T15:24:21.000Z</published>
    <updated>2020-03-01T16:01:33.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》</p></blockquote><img src="https://img.linux.net.cn/data/attachment/album/201805/06/111413hoaqz33ez2jdtrmz.jpg" class=""><p><strong>递归</strong>是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。</p><a id="more"></a><p>我们来看一下这个经典的递归阶乘：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;int factorial(int n){    int previous = 0xdeadbeef;    if (n == 0 || n == 1) {        return 1;    }    previous = factorial(n-1);    return n * previous;}int main(int argc){    int answer = factorial(5);    printf(&quot;%d\n&quot;, answer);}</code></pre><p><em>递归阶乘 - factorial.c</em></p><p>函数调用自身的这个观点在一开始是让人很难理解的。为了让这个过程更形象具体，下图展示的是当调用 <code>factorial(5)</code> 并且达到 <code>n == 1</code>这行代码 时，<a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/factorial-gdb-output.txt" target="_blank" rel="noopener">栈上</a> 端点的情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/factorial.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次调用 <code>factorial</code> 都生成一个新的 <a href="https://manybutfinite.com/post/journey-to-the-stack" target="_blank" rel="noopener">栈帧</a>。这些栈帧的创建和 <a href="https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/" target="_blank" rel="noopener">销毁</a> 是使得递归版本的阶乘慢于其相应的迭代版本的原因。在调用返回之前，累积的这些栈帧可能会耗尽栈空间，进而使你的程序崩溃。</p><p>而这些担心经常是存在于理论上的。例如，对于每个 <code>factorial</code> 的栈帧占用 16 字节（这可能取决于栈排列以及其它因素）。如果在你的电脑上运行着现代的 x86 的 Linux 内核，一般情况下你拥有 8 GB 的栈空间，因此，<code>factorial</code> 程序中的 <code>n</code> 最多可以达到  512,000  左右。这是一个 <a href="https://gist.github.com/gduarte/9944878" target="_blank" rel="noopener">巨大无比的结果</a>，它将花费 8,971,833 比特来表示这个结果，因此，栈空间根本就不是什么问题：一个极小的整数 —— 甚至是一个 64 位的整数 —— 在我们的栈空间被耗尽之前就早已经溢出了成千上万次了。</p><p>过一会儿我们再去看 CPU 的使用，现在，我们先从比特和字节回退一步，把递归看作一种通用技术。我们的阶乘算法可归结为：将整数 N、N-1、 … 1 推入到一个栈，然后将它们按相反的顺序相乘。实际上我们使用了程序调用栈来实现这一点，这是它的细节：我们在堆上分配一个栈并使用它。虽然调用栈具有特殊的特性，但是它也只是又一种数据结构而已，你可以随意使用。我希望这个示意图可以让你明白这一点。</p><p>当你将栈调用视为一种数据结构，有些事情将变得更加清晰明了：将那些整数堆积起来，然后再将它们相乘，这并不是一个好的想法。那是一种有缺陷的实现：就像你拿螺丝刀去钉钉子一样。相对更合理的是使用一个迭代过程去计算阶乘。</p><p>但是，螺丝钉太多了，我们只能挑一个。有一个经典的面试题，在迷宫里有一只老鼠，你必须帮助这只老鼠找到一个奶酪。假设老鼠能够在迷宫中向左或者向右转弯。你该怎么去建模来解决这个问题？</p><p>就像现实生活中的很多问题一样，你可以将这个老鼠找奶酪的问题简化为一个图，一个二叉树的每个结点代表在迷宫中的一个位置。然后你可以让老鼠在任何可能的地方都左转，而当它进入一个死胡同时，再回溯回去，再右转。这是一个老鼠行走的 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze.h" target="_blank" rel="noopener">迷宫示例</a>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/mazeGraph.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每到边缘（线）都让老鼠左转或者右转来到达一个新的位置。如果向哪边转都被拦住，说明相关的边缘不存在。现在，我们来讨论一下！这个过程无论你是调用栈还是其它数据结构，它都离不开一个递归的过程。而使用调用栈是非常容易的：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &quot;maze.h&quot;int explore(maze_t *node){    int found = 0;    if (node == NULL)    {        return 0;    }    if (node-&gt;hasCheese){        return 1;// found cheese        }    found = explore(node-&gt;left) || explore(node-&gt;right);    return found;    }    int main(int argc)    {        int found = explore(&amp;maze);    }</code></pre><p><em>递归迷宫求解 <a href="https://manybutfinite.com/code/x86-stack/maze.c" target="_blank" rel="noopener">下载</a></em></p><p>当我们在 <code>maze.c:13</code> 中找到奶酪时，栈的情况如下图所示。你也可以在 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze-gdb-output.txt" target="_blank" rel="noopener">GDB 输出</a> 中看到更详细的数据，它是使用 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze-gdb-commands.txt" target="_blank" rel="noopener">命令</a> 采集的数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/mazeCallStack.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它展示了递归的良好表现，因为这是一个适合使用递归的问题。而且这并不奇怪：当涉及到算法时，<em>递归是规则，而不是例外</em>。它出现在如下情景中——进行搜索时、进行遍历树和其它数据结构时、进行解析时、需要排序时——它无处不在。正如众所周知的 pi 或者 e，它们在数学中像“神”一样的存在，因为它们是宇宙万物的基础，而递归也和它们一样：只是它存在于计算结构中。</p><p>Steven Skienna 的优秀著作 <a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/" target="_blank" rel="noopener">算法设计指南</a> 的精彩之处在于，他通过 “战争故事” 作为手段来诠释工作，以此来展示解决现实世界中的问题背后的算法。这是我所知道的拓展你的算法知识的最佳资源。另一个读物是 McCarthy 的 <a href="https://github.com/papers-we-love/papers-we-love/blob/master/comp_sci_fundamentals_and_history/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-parti.pdf" target="_blank" rel="noopener">关于 LISP 实现的的原创论文</a>。递归在语言中既是它的名字也是它的基本原理。这篇论文既可读又有趣，在工作中能看到大师的作品是件让人兴奋的事情。</p><p>回到迷宫问题上。虽然它在这里很难离开递归，但是并不意味着必须通过调用栈的方式来实现。你可以使用像 <code>RRLL</code> 这样的字符串去跟踪转向，然后，依据这个字符串去决定老鼠下一步的动作。或者你可以分配一些其它的东西来记录追寻奶酪的整个状态。你仍然是实现了一个递归的过程，只是需要你实现一个自己的数据结构。</p><p>那样似乎更复杂一些，因为栈调用更合适。每个栈帧记录的不仅是当前节点，也记录那个节点上的计算状态（在这个案例中，我们是否只让它走左边，或者已经尝试向右）。因此，代码已经变得不重要了。然而，有时候我们因为害怕溢出和期望中的性能而放弃这种优秀的算法。那是很愚蠢的！</p><p>正如我们所见，栈空间是非常大的，在耗尽栈空间之前往往会遇到其它的限制。一方面可以通过检查问题大小来确保它能够被安全地处理。而对 CPU 的担心是由两个广为流传的有问题的示例所导致的：<ruby>哑阶乘<rt>dumb factorial</rt></ruby>和可怕的无记忆的 O( 2^n ) <a href="http://stackoverflow.com/questions/360748/computational-complexity-of-fibonacci-sequence" target="_blank" rel="noopener">Fibonacci 递归</a>。它们并不是栈递归算法的正确代表。</p><p>事实上栈操作是非常快的。通常，栈对数据的偏移是非常准确的，它在 <a href="https://manybutfinite.com/post/intel-cpu-caches/" target="_blank" rel="noopener">缓存</a> 中是热数据，并且是由专门的指令来操作它的。同时，使用你自己定义的在堆上分配的数据结构的相关开销是很大的。经常能看到人们写的一些比栈调用递归更复杂、性能更差的实现方法。最后，现代的 CPU 的性能都是 <a href="https://manybutfinite.com/post/what-your-computer-does-while-you-wait/" target="_blank" rel="noopener">非常好的</a> ，并且一般 CPU 不会是性能瓶颈所在。在考虑牺牲程序的简单性时要特别注意，就像经常考虑程序的性能及性能的<a href="https://manybutfinite.com/post/performance-is-a-science" target="_blank" rel="noopener">测量</a>那样。</p><p>下一篇文章将是探秘栈系列的最后一篇了，我们将了解尾调用、闭包、以及其它相关概念。然后，我们就该深入我们的老朋友—— Linux 内核了。感谢你的阅读！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/1000px-Sierpinski-build.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>via: <a href="https://manybutfinite.com/post/recursion/" target="_blank" rel="noopener">https://manybutfinite.com/post/recursion/</a><br>publish: <a href="https://linux.cn/article-9609-1.html" target="_blank" rel="noopener">https://linux.cn/article-9609-1.html</a></p><p>作者：<a href="http://duartes.org/gustavo/blog/about/" target="_blank" rel="noopener">Gustavo Duarte</a><br>译者：<a href="https://github.com/qhwdw" target="_blank" rel="noopener">qhwdw</a><br>校对：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201805/06/111413hoaqz33ez2jdtrmz.jpg&quot; class=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="递归" scheme="https://fsslc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 10 款 Linux 平台上最好的 LaTeX 编辑器</title>
    <link href="https://fsslc.github.io/2018/01/16/Translate-10-Best-LaTeX-Editors-For-Linux/"/>
    <id>https://fsslc.github.io/2018/01/16/Translate-10-Best-LaTeX-Editors-For-Linux/</id>
    <published>2018-01-16T14:13:09.000Z</published>
    <updated>2020-03-22T03:24:42.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：一旦你克服了 LaTeX 的学习曲线，就没有什么比 LaTeX 更棒了。下面介绍的是针对 Linux 和其他平台的最好的 LaTeX 编辑器。</p></blockquote><h3 id="LaTeX-是什么？"><a href="#LaTeX-是什么？" class="headerlink" title="LaTeX 是什么？"></a>LaTeX 是什么？</h3><p><a href="https://www.LaTeX-project.org/" target="_blank" rel="noopener">LaTeX</a> 是一个文档制作系统。与纯文本编辑器不同，在 LaTeX 编辑器中你不能只写纯文本，为了组织文档的内容，你还必须使用一些 LaTeX 命令。</p><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221313a94bb1t5s954w9as.jpg" alt="LaTeX 示例"></p><p>LaTeX 编辑器一般用在出于学术目的的科学研究文档或书籍的出版，最重要的是，当你需要处理包含众多复杂数学符号的文档时，它能够为你带来方便。当然，使用 LaTeX 编辑器是很有趣的，但它也并非总是很有用，除非你对所要编写的文档有一些特别的需求。</p><a id="more"></a><h3 id="为什么你应当使用-LaTeX"><a href="#为什么你应当使用-LaTeX" class="headerlink" title="为什么你应当使用 LaTeX?"></a>为什么你应当使用 LaTeX?</h3><p>好吧，正如我前面所提到的那样，使用 LaTeX 编辑器便意味着你有着特定的需求。为了捣腾 LaTeX 编辑器，并不需要你有一颗极客的头脑。但对于那些使用一般文本编辑器的用户来说，它并不是一个很有效率的解决方法。</p><p>假如你正在寻找一款工具来精心制作一篇文档，同时你对花费时间在格式化文本上没有任何兴趣，那么 LaTeX 编辑器或许正是你所寻找的那款工具。在 LaTeX 编辑器中，你只需要指定文档的类型，它便会相应地为你设置好文档的字体种类和大小尺寸。正是基于这个原因，难怪它会被认为是 <a href="https://itsfoss.com/open-source-tools-writers/" target="_blank" rel="noopener">给作家的最好开源工具</a> 之一。</p><p>但请务必注意： LaTeX 编辑器并不是自动化的工具，你必须首先学会一些 LaTeX 命令来让它能够精确地处理文本的格式。</p><h3 id="针对-Linux-平台的-10-款最好-LaTeX-编辑器"><a href="#针对-Linux-平台的-10-款最好-LaTeX-编辑器" class="headerlink" title="针对 Linux 平台的 10 款最好 LaTeX 编辑器"></a>针对 Linux 平台的 10 款最好 LaTeX 编辑器</h3><p>事先说明一下，以下列表并没有一个明确的先后顺序，序号为 3 的编辑器并不一定比序号为 7 的编辑器优秀。</p><h4 id="1、-LyX"><a href="#1、-LyX" class="headerlink" title="1、 LyX"></a>1、 LyX</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221314hdkki9din9nd1ldn.jpg" alt=""></p><p><a href="https://www.LyX.org/" target="_blank" rel="noopener">LyX</a> 是一个开源的 LaTeX 编辑器，即是说它是网络上可获取到的最好的文档处理引擎之一。LyX 帮助你集中于你的文章，并忘记对单词的格式化，而这些正是每个 LaTeX 编辑器应当做的。LyX 能够让你根据文档的不同，管理不同的文档内容。一旦安装了它，你就可以控制文档中的很多东西了，例如页边距、页眉、页脚、空白、缩进、表格等等。</p><p>假如你正忙着精心撰写科学类文档、研究论文或类似的文档，你将会很高兴能够体验到 LyX 的公式编辑器，这也是其特色之一。 LyX 还包括一系列的教程来入门，使得入门没有那么多的麻烦。</p><h4 id="2、-Texmaker"><a href="#2、-Texmaker" class="headerlink" title="2、 Texmaker"></a>2、 Texmaker</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221314gdaj2c4vddgejgda.jpg" alt=""></p><p><a href="http://www.xm1math.net/texmaker/" target="_blank" rel="noopener">Texmaker</a> 被认为是 GNOME 桌面环境下最好的 LaTeX 编辑器之一。它呈现出一个非常好的用户界面，带来了极好的用户体验。它也被称之为最实用的 LaTeX 编辑器之一。假如你经常进行 PDF 的转换，你将发现 TeXmaker 相比其他编辑器更加快速。在你书写的同时，你也可以预览你的文档最终将是什么样子的。同时，你也可以观察到可以很容易地找到所需要的符号。</p><p>Texmaker 也提供一个扩展的快捷键支持。你有什么理由不试着使用它呢？</p><h4 id="3、-TeXstudio"><a href="#3、-TeXstudio" class="headerlink" title="3、 TeXstudio"></a>3、 TeXstudio</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221316xpqnhorpgrrg9qqg.jpg" alt=""></p><p>假如你想要一个这样的 LaTeX 编辑器：它既能为你提供相当不错的自定义功能，又带有一个易用的界面，那么 <a href="https://www.texstudio.org/" target="_blank" rel="noopener">TeXstudio</a> 便是一个完美的选择。它的 UI 确实很简单，但是不粗糙。 TeXstudio 带有语法高亮，自带一个集成的阅读器，可以让你检查参考文献，同时还带有一些其他的辅助工具。</p><p>它同时还支持某些酷炫的功能，例如自动补全，链接覆盖，书签，多游标等等，这使得书写 LaTeX 文档变得比以前更加简单。</p><p>TeXstudio 的维护很活跃，对于新手或者高级写作者来说，这使得它成为一个引人注目的选择。</p><h4 id="4、-Gummi"><a href="#4、-Gummi" class="headerlink" title="4、 Gummi"></a>4、 Gummi</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221318bgattbr9t55dhmvf.jpg" alt=""></p><p><a href="https://github.com/alexandervdm/gummi" target="_blank" rel="noopener">Gummi</a> 是一个非常简单的 LaTeX 编辑器，它基于 GTK+ 工具箱。当然，在这个编辑器中你找不到许多华丽的选项，但如果你只想能够立刻着手写作， 那么 Gummi 便是我们给你的推荐。它支持将文档输出为 PDF 格式，支持语法高亮，并帮助你进行某些基础的错误检查。尽管在 GitHub 上它已经不再被活跃地维护，但它仍然工作地很好。</p><h4 id="5、-TeXpen"><a href="#5、-TeXpen" class="headerlink" title="5、 TeXpen"></a>5、 TeXpen</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221320zjcfljdi1dmccp3c.jpg" alt=""></p><p><a href="https://sourceforge.net/projects/texpen/" target="_blank" rel="noopener">TeXpen</a> 是另一个简洁的 LaTeX 编辑器。它为你提供了自动补全功能。但其用户界面或许不会让你感到印象深刻。假如你对用户界面不在意，又想要一个超级容易的 LaTeX 编辑器，那么 TeXpen 将满足你的需求。同时 TeXpen 还能为你校正或提高在文档中使用的英语语法和表达式。</p><h4 id="6、-ShareLaTeX"><a href="#6、-ShareLaTeX" class="headerlink" title="6、 ShareLaTeX"></a>6、 ShareLaTeX</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221320g97mz8w33metwhz7.jpg" alt=""></p><p><a href="https://www.shareLaTeX.com/" target="_blank" rel="noopener">ShareLaTeX</a> 是一款在线 LaTeX 编辑器。假如你想与某人或某组朋友一同协作进行文档的书写，那么这便是你所需要的。</p><p>它提供一个免费方案和几种付费方案。甚至来自哈佛大学和牛津大学的学生也都使用它来进行个人的项目。其免费方案还允许你添加一位协作者。</p><p>其付费方案允许你与 GitHub 和 Dropbox 进行同步，并且能够记录完整的文档修改历史。你可以为你的每个方案选择多个协作者。对于学生，它还提供单独的计费方案。</p><h4 id="7、-Overleaf"><a href="#7、-Overleaf" class="headerlink" title="7、 Overleaf"></a>7、 Overleaf</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221321y336xf2si265i6nu.jpg" alt=""></p><p><a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a> 是另一款在线的 LaTeX 编辑器。它与 ShareLaTeX 类似，它为专家和学生提供了不同的计费方案。它也提供了一个免费方案，使用它你可以与 GitHub 同步，检查你的修订历史，或添加多个合作者。</p><p>在每个项目中，它对文件的数目有所限制。所以在大多数情况下如果你对 LaTeX 文件非常熟悉，这并不会为你带来不便。</p><h4 id="8、-Authorea"><a href="#8、-Authorea" class="headerlink" title="8、 Authorea"></a>8、 Authorea</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221325o378ewwtaz65atwz.jpg" alt=""></p><p><a href="https://www.authorea.com/" target="_blank" rel="noopener">Authorea</a> 是一个美妙的在线 LaTeX 编辑器。当然，如果考虑到价格，它可能不是最好的一款。对于免费方案，它有 100 MB 的数据上传限制和每次只能创建一个私有文档。而付费方案则提供更多的额外好处，但如果考虑到价格，它可能不是最便宜的。你应该选择 Authorea 的唯一原因应该是因为其用户界面。假如你喜爱使用一款提供令人印象深刻的用户界面的工具，那就不要错过它。</p><h4 id="9、-Papeeria"><a href="#9、-Papeeria" class="headerlink" title="9、 Papeeria"></a>9、 Papeeria</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221327zf4nz2h80fph2o0p.jpg" alt=""></p><p><a href="https://www.papeeria.com/" target="_blank" rel="noopener">Papeeria</a> 是在网络上你能够找到的最为便宜的 LaTeX 在线编辑器，如果考虑到它和其他的编辑器一样可信赖的话。假如你想免费地使用它，则你不能使用它开展私有项目。但是，如果你更偏爱公共项目，它允许你创建不限数目的项目，添加不限数目的协作者。它的特色功能是有一个非常简便的画图构造器，并且在无需额外费用的情况下使用 Git 同步。假如你偏爱付费方案，它赋予你创建 10 个私有项目的能力。</p><h4 id="10、-Kile"><a href="#10、-Kile" class="headerlink" title="10、 Kile"></a>10、 Kile</h4><p><img src="https://img.linux.net.cn/data/attachment/album/201801/16/221329ny1z989ijy1dzdz3.png" alt="Kile LaTeX 编辑器"></p><p>位于我们最好 LaTeX 编辑器清单的最后一位是 <a href="https://kile.sourceforge.io/" target="_blank" rel="noopener">Kile</a> 编辑器。有些朋友对 Kile 推崇备至，很大程度上是因为其提供某些特色功能。</p><p>Kile 不仅仅是一款编辑器，它还是一款类似 Eclipse 的 IDE 工具，提供了针对文档和项目的一整套环境。除了快速编译和预览功能，你还可以使用诸如命令的自动补全 、插入引用，按照章节来组织文档等功能。你真的应该使用 Kile 来见识其潜力。</p><p>Kile 在 Linux 和 Windows 平台下都可获取到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以上面便是我们推荐的 LaTeX 编辑器，你可以在 Ubuntu 或其他 Linux 发行版本中使用它们。</p><p>当然，我们可能还遗漏了某些可以在 Linux 上使用并且有趣的 LaTeX 编辑器。如若你正好知道它们，请在下面的评论中让我们知晓。</p><hr><p>via: <a href="https://itsfoss.com/LaTeX-editors-linux/" target="_blank" rel="noopener">https://itsfoss.com/LaTeX-editors-linux/</a><br>publish: <a href="https://linux.cn/article-9247-1.html" target="_blank" rel="noopener">https://linux.cn/article-9247-1.html</a></p><p>作者：<a href="https://itsfoss.com/author/ankush/" target="_blank" rel="noopener">Ankush Das</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：一旦你克服了 LaTeX 的学习曲线，就没有什么比 LaTeX 更棒了。下面介绍的是针对 Linux 和其他平台的最好的 LaTeX 编辑器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;LaTeX-是什么？&quot;&gt;&lt;a href=&quot;#LaTeX-是什么？&quot; class=&quot;headerlink&quot; title=&quot;LaTeX 是什么？&quot;&gt;&lt;/a&gt;LaTeX 是什么？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.LaTeX-project.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LaTeX&lt;/a&gt; 是一个文档制作系统。与纯文本编辑器不同，在 LaTeX 编辑器中你不能只写纯文本，为了组织文档的内容，你还必须使用一些 LaTeX 命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201801/16/221313a94bb1t5s954w9as.jpg&quot; alt=&quot;LaTeX 示例&quot;&gt;&lt;/p&gt;
&lt;p&gt;LaTeX 编辑器一般用在出于学术目的的科学研究文档或书籍的出版，最重要的是，当你需要处理包含众多复杂数学符号的文档时，它能够为你带来方便。当然，使用 LaTeX 编辑器是很有趣的，但它也并非总是很有用，除非你对所要编写的文档有一些特别的需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="LaTeX" scheme="https://fsslc.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>减小 VBoX 虚拟磁盘大小</title>
    <link href="https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/"/>
    <id>https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/</id>
    <published>2016-12-18T08:28:48.000Z</published>
    <updated>2020-03-21T06:47:20.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何使用 VBOX 自带工具减小虚拟磁盘大小</p></blockquote><div style="text-align: center"><img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/Virtualbox_logo.png" style="zoom:25%;" /></div><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ, WPS, MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。</p><p>虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。</p><blockquote><p>WPS 终于出了 <a href="https://www.wps.com/linux/" target="_blank" rel="noopener">Linux 版本</a>了，还算良心，就 鹅厂 还一直没有什么进展。。</p></blockquote><a id="more"></a><p>问题来了，便开始上网搜索方法。在<a href="http://my.oschina.net/tsl0922/blog/188276" target="_blank" rel="noopener">开源中国的一个博客</a>里面找到了方法，下面进行简单的记录。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据博主的文章，要达到减小 VBox 虚拟磁盘的大小，主要有两个步骤：</p><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p>首先需要在虚拟机里面的系统下做碎片整理。</p><p>对于 Linux 系统，可以使用：</p><pre><code class="lang-bash">sudo dd if=/dev/zero of=/EMPTY bs=1Msudo rm -f /EMPTY</code></pre><p>对于 Windows 系统，则需要使用 <a href="http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx" target="_blank" rel="noopener">Sysinternals Suite</a>，点击上面的链接可以到微软的页面下进行下载。下载解压后，通过 CMD ，运行：</p><pre><code class="lang-bash">sdelete -z c:</code></pre><p>等待进度完成即可。然后关闭虚拟机。</p><h3 id="压缩磁盘"><a href="#压缩磁盘" class="headerlink" title="压缩磁盘"></a>压缩磁盘</h3><p>如果虚拟磁盘是 <code>Virtual Box</code> 自家的 <code>VDI</code> 格式，则只需要先通过终端到达含有后缀为 <code>.vdi</code> 的文件所在的那个目录，再执行：</p><pre><code class="lang-bash">VBoxManage modifyhd win7.vdi --compact</code></pre><p>这样就可以达到压缩磁盘的目的。</p><p>如果虚拟磁盘是 <code>VMDK</code> 的格式，则可以使用 vmware 自带的 <code>vmware-vdiskmanager</code> 工具，具体命令如下：</p><pre><code class="lang-bash">vmware-vdiskmanager -k disk.vmdk</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://my.oschina.net/tsl0922/blog/188276" target="_blank" rel="noopener">如何减小VirtualBox虚拟硬盘文件的大小</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如何使用 VBOX 自带工具减小虚拟磁盘大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/Virtualbox_logo.png&quot; style=&quot;zoom:25%;&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;缘由&lt;/h2&gt;&lt;p&gt;由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ, WPS, MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。&lt;/p&gt;
&lt;p&gt;虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WPS 终于出了 &lt;a href=&quot;https://www.wps.com/linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 版本&lt;/a&gt;了，还算良心，就 鹅厂 还一直没有什么进展。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="VBox" scheme="https://fsslc.github.io/tags/VBox/"/>
    
  </entry>
  
  <entry>
    <title>在 Archlinux 中安装 OpenDX</title>
    <link href="https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/"/>
    <id>https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/</id>
    <published>2016-12-15T08:02:31.000Z</published>
    <updated>2020-03-21T05:27:51.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Archlinux 中安装 OpenDX</p></blockquote><p><a href="http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/">前面</a> 我说过， OpenDX 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 <code>sudo apt install dx dxsamples</code> 安装这个可视化软件。</p><p>现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。</p><a id="more"></a><p><strong>UPDATE</strong><br>现在下面那个久未更新的镜像网站已经不存在了，而我也没有保存那个安装包，所以只好自己想办法了。还好 Debian 还在维护这两个包，所以我就借鉴它的编译脚本来写成适合 Archlinux 编译的脚本。目前通过我自己编写的编译脚本编译这两个软件包基本可以使用，但还是有点小问题：</p><ol><li>Debian 维护者里面的那个仓库中，包含很多与 Debian 系统相关的补丁，我只清理了一点，有些可能没有清理干净；</li><li>有时会占用 100% 的 CPU，到时直接杀掉那个进程即可(PS: <code>htop</code>这个工具非常好用，推荐大家使用 ^_^ )；</li><li>在 dx 的窗口中仍然不能直接达到 samples 目录。</li></ol><hr><p>自己编译又不想安装那么多的依赖，最后在<a href="http://mirror.lzjtu.edu.cn/archlinux/community/os/x86_64/" target="_blank" rel="noopener">国内某个久未更新的镜像网站</a> 中找到了别人打包好的二进制文件，下载那个名为 OpenDX-4.4.4-2.pkg.tar.gz 的安装包后，可以直接使用命令 <code>sudo pacman -U OpenDX-4.4.4-2.pkg.tar.gz</code> 进行安装。</p><blockquote><p>现在这个镜像网站好像不能访问了 %&gt;_&lt;%&gt;</p></blockquote><p>这样安装后，可能会有些依赖问题，例如我的系统里面会报 netcdf 和 tiff 的动态链接库找不到，而我已经安装了它们，所以只需要创建一些软链接就可以了。</p><pre><code class="lang-bash">sudo ln -s /usr/lib/libnetcdf.so.12.0.0 /usr/lib/libnetcdf.so.4sudo ln -s /usr/lib/libtiff.so.5.2.4 /usr/lib/libtiff.so.3</code></pre><hr><p>最后附上我改写的编译脚本和相关的源文件：</p><pre><code class="lang-bash">链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxt</code></pre><p>如果只需要编译这两个包，只需要下载 <code>OpenDX_AUR_build_scripts.zip</code> 这个压缩包就行了。另外的东西是用来编译 AFEPack 的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Archlinux 中安装 OpenDX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/&quot;&gt;前面&lt;/a&gt; 我说过， OpenDX 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 &lt;code&gt;sudo apt install dx dxsamples&lt;/code&gt; 安装这个可视化软件。&lt;/p&gt;
&lt;p&gt;现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="OpenDX" scheme="https://fsslc.github.io/tags/OpenDX/"/>
    
      <category term="Archlinux" scheme="https://fsslc.github.io/tags/Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 构建 AFEPack 镜像</title>
    <link href="https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/"/>
    <id>https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/</id>
    <published>2016-12-15T07:24:09.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦</p></blockquote><p>先前写了一篇<a href="http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/">如何在 Ubuntu 安装 AFEPack 的教程</a>，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在<a href="https://hub.docker.com/r/xywei/afebackpack/" target="_blank" rel="noopener">这里</a>。先前也知道 docker 掀起的热潮，但一直没有学习它。</p><a id="more"></a><p>关于 docker 的学习，网上一搜一大堆。我自己买了本 杨保华、戴王剑、曹亚仑 编著的《Docker 技术入门与实践》，利用一个下午学会了基本操作，后面的有些功能自己用不到就没有再深究下去。闲话少说，下面进入正题。</p><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p>首先，要构建 docker 镜像，你需要安装 <code>docker</code>，具体安装过程见官网或者 Google 、Baidu 一下。</p><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><p>要想实现自动构建 Docker 镜像，就需要编写 Dockerfile。只要知道 Dockerfile 编写时需要用的一些指令和编译安装的命令就可以了。</p><p>下面是我最后写好的 Dockerfile 。我在下面用中文添加注释，原文件参考我 GitHub 上的项目<a href="https://github.com/FSSlc/AFEPackDocker" target="_blank" rel="noopener">AFEPackDocker</a>。</p><pre><code class="lang-bash">FROM ubuntu:16.04                                   # 以 ubuntu 16.04 作为镜像的基础系统MAINTAINER FSSlc, liuchang011235 AT gmail DOT com   # 维护者的相关信息# install essential packagesRUN \                                               # RUN 后面跟上要运行的命令即可  mkdir -p /root/Pkg &amp;&amp; \  # use aliyun&#39;s mirror for better download speed  sed -i &#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&#39; /etc/apt/sources.list &amp;&amp; \  apt-get update &amp;&amp; \  apt-get install -y make automake autoconf wget build-essential \  libdeal.ii-dev mpi-default-dev nano # libhypre-dev trilinos-all-dev petsc-dev --no-install-recommends## set some env varibles                            # 设置与 AFEPack 相关的环境变量COPY env.txt /root/Pkg/env.txt ## prepare AFEPack easymeshRUN \cd /root/Pkg &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/AFEPack-snapshot.tar.gz &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/source_code/easymesh.c.gz &amp;&amp; \tar -xzf ./AFEPack-snapshot.tar.gz -C /root/Pkg/  &amp;&amp; \gunzip easymesh.c.gz &amp;&amp; \## compile and install AFEPackcat /root/Pkg/env.txt &gt;&gt; /root/.bashrc &amp;&amp; . /root/.bashrc &amp;&amp; \cd /root/Pkg/AFEPack &amp;&amp; \                           # 将 ubuntu 中安装的 deal.ii 库文件改名ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.g.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.g.so &amp;&amp; \ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.so.8.1.0  /usr/lib/x86_64-linux-gnu/libdeal_II.so &amp;&amp; \aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; \env EXTRA_INCDIR=&quot;-I/usr/include/deal.II/&quot; EXTRA_LIBDIR=&quot;-L/usr/lib/x86_64-linux-gnu/&quot; ./configure &amp;&amp; \# make -j8 &amp;&amp; make install                      # 下面分开编译 AFEPack，直接编译会报错，镜像就编译不下去了cd ./template/ &amp;&amp; make -j8 &amp;&amp; cd ../library/ &amp;&amp; make -j8 &amp;&amp; make install &amp;&amp; \cd ../example/ &amp;&amp; make -j8 &amp;&amp; \## compile and install easymeshcd /root/Pkg/ &amp;&amp; \gcc -o easymesh easymesh.c -lm &amp;&amp; \mv ./easymesh /usr/local/bin/ &amp;&amp; \## do some clean work                           # 清理一些不需要的文件，减小镜像大小rm easymesh.c AFEPack-snapshot.tar.gz env.txt &amp;&amp; \rm -rf /var/lib/apt/lists/*CMD [&quot;/bin/bash&quot;]</code></pre><p><strong>UPDATE</strong><br>为了能够本地编译安装 AFEPack 的镜像，我编写了两个 Dockerfile，一个是直接使用<br>Ubuntu 16.04 里面 8.1 版本的 deal.II，另一个是在 Ubuntu 14.04 里使用源码编译的 deal.II 6.3.1，请自行选择。</p><p><strong>UPDATE 20181103</strong><br>好久没有更新了，最近在做 docker 相关的事。了解到 docker 可以进行所谓的多阶段构建了。这个功能可以进一步地减小镜像的大小，所以我今天就尝试了一下，效果还是很明显的。从原来的 <code>1.07GB</code> 减少到现在的 <code>573MB</code>。 </p><p>另外 AFEPack 的包做了一些更新，居然默认 <code>std=c++14</code> 了！所以原来的 Dockerfile 可能不能使用了，所以我顺便做了更新。从构建的结果看，<code>step-7</code> 这个例子跑不通，这次更新后的 Dockerfile 都有这个问题，它们获取的<br>AFEPack 源码都是今天我从官网下载的。但是我放在 docker Hub 的镜像可以运行。。。</p><h2 id="使用-docker-build-命令构建镜像"><a href="#使用-docker-build-命令构建镜像" class="headerlink" title="使用 docker build 命令构建镜像"></a>使用 <code>docker build</code> 命令构建镜像</h2><p>编写完 Dockerfile 后，便可以构建镜像了。使用的命令是：</p><pre><code class="lang-bash">sudo docker build  -t afepack:v0 .</code></pre><p>其中 <code>-t</code> 选项是指定编译后镜像的名称，即所谓的 <code>tag</code> 。</p><p>具体使用时，一般运行：</p><pre><code class="lang-bash">docker run -ti -v $HOME/Pkg:/opt afepack:v0 bash</code></pre><p>上面的命令将启动一个容器，其中的 <code>-v</code> 选项将把主机中的 <code>$HOME/Pkg</code> 目录挂载到容器中的 <code>/opt</code> 目录，这样我们便可以在 <code>$HOME/Pkg</code> 中让主机和容器之间进行数据交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先前写了一篇&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/&quot;&gt;如何在 Ubuntu 安装 AFEPack 的教程&lt;/a&gt;，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在&lt;a href=&quot;https://hub.docker.com/r/xywei/afebackpack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。先前也知道 docker 掀起的热潮，但一直没有学习它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="Docker" scheme="https://fsslc.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] awk 系列：如何使用 awk 按模式筛选文本或字符串</title>
    <link href="https://fsslc.github.io/2016/07/21/Translate-Part-3-How-to-Use-Awk-to-Filter-Text-or-Strings-Using-Pattern-Specific-Actions/"/>
    <id>https://fsslc.github.io/2016/07/21/Translate-Part-3-How-to-Use-Awk-to-Filter-Text-or-Strings-Using-Pattern-Specific-Actions/</id>
    <published>2016-07-21T00:02:28.000Z</published>
    <updated>2020-03-22T03:02:48.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 awk 根据模式筛选文本或字符串</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.tecmint.com/wp-content/uploads/2016/04/Use-Awk-to-Filter-Text-or-Strings-Using-Pattern.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>作为 awk 命令系列的第三部分，这次我们将看一看如何基于用户定义的特定模式来筛选文本或字符串。</p><p>在筛选文本时，有时你可能想根据某个给定的条件或使用一个可被匹配的特定模式，去标记某个文件或数行字符串中的某几行。使用 awk 来完成这个任务是非常容易的，这也正是 awk 中可能对你有所帮助的几个功能之一。</p><p>让我们看一看下面这个例子，比方说你有一个写有你想要购买的食物的购物清单，其名称为 food_prices.list，它所含有的食物名称及相应的价格如下所示：</p><pre><code class="lang-bash">$ cat food_prices.listNo    Item_Name        Quantity    Price1    Mangoes               10        $2.452    Apples               20        $1.503    Bananas               5        $0.904    Pineapples           10        $3.465    Oranges               10        $0.786    Tomatoes           5        $0.557    Onions               5        $0.45</code></pre><p>然后，你想使用一个 <code>(*)</code> 符号去标记那些单价大于 $2 的食物，那么你可以通过运行下面的命令来达到此目的：</p><pre><code class="lang-bash">$ awk &#39;/ *\$[2-9]\.[0-9][0-9] */ { print $1, $2, $3, $4, &quot;*&quot; ; } / *\$[0-1]\.[0-9][0-9] */ { print ; }&#39; food_prices.list</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.tecmint.com/wp-content/uploads/2016/04/Filter-and-Print-Text-Using-Awk.gif" alt="打印出单价大于 $2 的项目" title="">                </div>                <div class="image-caption">打印出单价大于 $2 的项目</div>            </figure><p>从上面的输出你可以看到在含有 芒果（mangoes） 和菠萝（pineapples）的那行末尾都已经有了一个 <code>(*)</code> 标记。假如你检查它们的单价，你可以看到它们的单价的确超过了 $2 。</p><p>在这个例子中，我们已经使用了两个模式：</p><ul><li>第一个模式: <code>/ *\$[2-9]\.[0-9][0-9] */</code> 将会得到那些含有食物单价大于 $2 的行，</li><li>第二个模式: <code>/*\$[0-1]\.[0-9][0-9] */</code> 将查找那些食物单价小于 $2 的那些行。</li></ul><p>上面的命令具体做了什么呢？这个文件有四个字段，当模式一匹配到含有食物单价大于 $2 的行时，它便会输出所有的四个字段并在该行末尾加上一个 <code>(*)</code> 符号来作为标记。</p><p>第二个模式只是简单地输出其他含有食物单价小于 $2 的行，按照它们出现在输入文件 food_prices.list 中的样子。</p><p>这样你就可以使用模式来筛选出那些价格超过 $2 的食物项目，尽管上面的输出还有些问题，带有 <code>(*)</code> 符号的那些行并没有像其他行那样被格式化输出，这使得输出显得不够清晰。</p><p>我们在 awk 系列的第二部分中也看到了同样的问题，但我们可以使用下面的两种方式来解决：</p><p>1、可以像下面这样使用 printf 命令，但这样使用又长又无聊：</p><pre><code class="lang-bash">$ awk &#39;/ *\$[2-9]\.[0-9][0-9] */ { printf &quot;%-10s %-10s %-10s %-10s\n&quot;, $1, $2, $3, $4 &quot;*&quot; ; } / *\$[0-1]\.[0-9][0-9] */ { printf &quot;%-10s %-10s %-10s %-10s\n&quot;, $1, $2, $3, $4; }&#39; food_prices.list</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.tecmint.com/wp-content/uploads/2016/04/Filter-and-Print-Items-Using-Awk-and-Printf.gif" alt="使用 Awk 和 Printf 来筛选和输出项目" title="">                </div>                <div class="image-caption">使用 Awk 和 Printf 来筛选和输出项目</div>            </figure><p>2、 使用 <code>$0</code> 字段。Awk 使用变量 <strong>0</strong> 来存储整个输入行。对于上面的问题，这种方式非常方便，并且它还简单、快速：</p><pre><code class="lang-bash">$ awk &#39;/ *\$[2-9]\.[0-9][0-9] */ { print $0 &quot;*&quot; ; } / *\$[0-1]\.[0-9][0-9] */ { print ; }&#39; food_prices.list</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.tecmint.com/wp-content/uploads/2016/04/Filter-and-Print-Items-Using-Awk-and-Variable.gif" alt="使用 Awk 和变量来筛选和输出项目" title="">                </div>                <div class="image-caption">使用 Awk 和变量来筛选和输出项目</div>            </figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这就是全部内容了，使用 awk 命令你便可以通过几种简单的方法去利用模式匹配来筛选文本，帮助你在一个文件中对文本或字符串的某些行做标记。</p><p>希望这篇文章对你有所帮助。记得阅读这个系列的下一部分，我们将关注在 awk 工具中使用比较运算符。</p><hr><p>via: <a href="http://www.tecmint.com/awk-filter-text-or-string-using-patterns/" target="_blank" rel="noopener">http://www.tecmint.com/awk-filter-text-or-string-using-patterns/</a><br>publish: <a href="https://linux.cn/article-7599-1.html" target="_blank" rel="noopener">https://linux.cn/article-7599-1.html</a></p><p>作者：<a href="http://www.tecmint.com/author/aaronkili/" target="_blank" rel="noopener">Aaron Kili</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 awk 根据模式筛选文本或字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;http://www.tecmint.com/wp-content/uploads/2016/04/Use-Awk-to-Filter-Text-or-Strings-Using-Pattern.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Awk" scheme="https://fsslc.github.io/tags/Awk/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 《道德经》之项目管理</title>
    <link href="https://fsslc.github.io/2016/05/24/Translate-The-Tao-of-project-management/"/>
    <id>https://fsslc.github.io/2016/05/24/Translate-The-Tao-of-project-management/</id>
    <published>2016-05-24T07:58:06.000Z</published>
    <updated>2020-03-22T03:42:03.555Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/BUSINESS_orgchart1.png?itok=tukiFj89" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html" target="_blank" rel="noopener">道德经</a>，<a href="https://en.wikipedia.org/wiki/Tao_Te_Ching" target="_blank" rel="noopener">被认为</a>是由圣人<a href="http://plato.stanford.edu/entries/laozi/" target="_blank" rel="noopener">老子</a>于公元前六世纪时所编写，是现存最为广泛翻译的经文之一。从<a href="https://en.wikipedia.org/wiki/Taoism" target="_blank" rel="noopener">宗教</a>到<a href="http://www.imdb.com/title/tt0234853/" target="_blank" rel="noopener">关于约会的有趣电影</a>等方方面面，它都深深地影响着它们，作者们借用它来做隐喻，以解释各种各样的事情（甚至是<a href="http://www.mit.edu/~xela/tao.html" target="_blank" rel="noopener">编程</a>）。</p><p>在思考有关开放性组织的项目管理时，我的脑海中便立马浮现出上面的这段文字。</p><a id="more"></a><p>这听起来可能会有点奇怪。若要理解我的这种想法从何而来，你应该读读 <em>《开放性组织：点燃激情提升执行力》</em> 这本书，它是红帽公司总裁、首席执行官 Jim Whitehurst  所写的一本有关企业文化和新领导力范式的宣言。在这本书中，Jim（还有来自其他红帽人的一点帮助）解释了传统组织机构（一种 “自上而下” 的方式，来自高层的决策被传达到员工，而员工通过晋升和薪酬来激励）和开放性组织机构（一种 自下而上 的方式，领导专注于激励和鼓励，员工被充分授权以各尽其能）之间的差异。</p><p>在开放性组织中的员工都是被激情、目标和参与感所激励，这个观点正是我认为项目管理者所应该关注的。</p><p>要解释这一切，我将从<em>道德经</em>上寻找依据。</p><h3 id="不要让工作职衔框住自身"><a href="#不要让工作职衔框住自身" class="headerlink" title="不要让工作职衔框住自身"></a>不要让工作职衔框住自身</h3><blockquote><p>道，可道也，(The tao that can be told)</p><p>非恒道也。(is not the eternal Tao)</p><p>名，可名也，(The name that can be named)</p><p>非恒名也。(is not the eternal Name.)</p><p>“无”，名天地之始；(The unnameable is the eternally real.)</p><p>“有”，名万物之母。(Naming is the origin of all particular things.)</p></blockquote><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#1" target="_blank" rel="noopener"><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html" target="_blank" rel="noopener">1</a></a></p><p>项目管理到底是什么？作为一个项目管理者应该做些什么呢？</p><p>如您所想，项目管理者的一部分工作就是管理项目：收集需求、与项目相关人员沟通、设置项目优先级、安排任务、帮助团队解决困扰。许多机构都可以教你如何做好项目管理，并且这些技能你值得拥有。</p><p>然而，在开放性组织中，字面上的项目管理技能仅仅只是项目管理者需要做到的一小部分，这些组织需要更多其他的东西：即勇气。如果你擅长于管理项目（或者是真的擅长于任何工作），那么你就进入了舒适区。这时候就是需要鼓起勇气开始尝试冒险之时。</p><p>您有勇气跨出舒适区吗？向权威人士提出挑战性的问题，可能会引发对方的不快，但也可能会开启一个更好的方法，您有勇气这样做吗？有确定需要做的下一件事，然后真正去完成它的勇气吗？有主动去解决因为交流的鸿沟而遗留下来的问题的勇气吗？有去尝试各种事情的勇气吗？有失败的勇气吗？</p><p>道德经的开篇（上面引用的）就表明词语（words）、标签（labels）、名字（names）这些是有限制的，当然也包括工作职衔。在开放性组织中，项目经理不仅仅是执行管理项目所需的机械任务，而且要帮助团队完成组织的使命，尽管这已经被限定了。</p><h3 id="联系起合适的人"><a href="#联系起合适的人" class="headerlink" title="联系起合适的人"></a>联系起合适的人</h3><blockquote><p>三十辐共一轂，(We join spokes together in a wheel, )</p><p>当其无，(but it is the center hole)</p><p>有车之用。(that makes the wagon move.)</p></blockquote><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#11" target="_blank" rel="noopener"><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#38" target="_blank" rel="noopener">11</a></a></p><p>当我过渡到项目管理的工作时，我必须学会的最为困难的一课是：并不是所有解决方案都是可完全地接受，甚至有的连预期都达不到。这对我来说是全新的一页。我<em>喜欢</em>全部都能解决。但作为项目管理者，我的角色更多的是与人沟通—使得那些确实有解决方案的人可以更高效地合作。</p><p>这并不是逃避责任或者不负责。这意味着可以很舒适的说，“我不知道，但我会给你找出答案”，然后就可迅速地结束这个循环。</p><p>想像一下马车的车轮，如果没有毂中的孔洞所提供的稳定性和方向，辐条便会失去支持，车轮也会散架。在一个开放性的组织中，项目管理者可以通过把合适的人凝聚在一起，培养正确的讨论话题来帮助团队保持持续向前的动力。</p><h3 id="信任你的团队"><a href="#信任你的团队" class="headerlink" title="信任你的团队"></a>信任你的团队</h3><blockquote><p>太上，不知有之；(When the Master governs, the people</p></blockquote><p>are hardly aware that he exists.)</p><blockquote><p>其次，亲而誉之；(Next best is a leader who is loved.)</p><p>其次，畏之；(Next, one who is feared.)</p><p>其次，侮之。(The worst is one who is despised.)</p><p>信不足焉，(If you don’t trust the people, )</p><p>有不信焉。(you make them untrustworthy.)</p><p>悠兮，其贵言。(The Master doesn’t talk, he acts.)</p><p>功成事遂，(When his work is done, )</p><p>百姓皆谓：“我自然”。(the people say, “Amazing:</p></blockquote><p>we did it, all by ourselves!”)<br><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#17" target="_blank" rel="noopener">[17]</a></p><p><a href="https://opensource.com/users/rebecca" target="_blank" rel="noopener">Rebecca Fernandez</a> 曾经告诉我开放性组织的领导与其它组织的领导者最大的不同点在于，我们不是去取得别人的信任，而是信任别人。</p><p>开放性组织会雇佣那些非常聪明的，且对公司正在做的事情充满激情的人来做工作。为了能使他们能更好的工作，我们会提供其所需，并尊重他们的工作方式。</p><p>至于原因，我认为从道德经中摘出的上面一段就说的很清楚。</p><h3 id="顺其自然"><a href="#顺其自然" class="headerlink" title="顺其自然"></a>顺其自然</h3><blockquote><p>上德无为而无以为；(The Master does nothing</p></blockquote><p>yet he leaves nothing undone.)</p><blockquote><p>下德为之而有以为。(The ordinary man is always doing things,</p></blockquote><p>yet many more are left to be done.)<br><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#38" target="_blank" rel="noopener">[38]</a></p><p>你认识那类总是极其忙碌的人吗？认识那些因为有太多事情要做而看起来疲倦和压抑的人吗？</p><p>不要成为那样的人。</p><p>我知道说比做容易。帮助我没有成为那类人的最重要的东西是：我时刻记着<em>大家都很忙</em>这件事。我没有一个那样无聊的同事。</p><p>但总需要有人成为在狂风暴雨中仍保持镇定的人。总需要有人能够宽慰团队告诉他们一切都会好起来，我们将在现实和一天中工作时间有限的情况下，找到方法使得任务能够完成（因为事实就是这样的，而且我们必须这样）。</p><p>成为那样的人吧。</p><p>对于上面这段道德经所说的，我的理解是那些总是谈论他或她正在做什么的人实际上并<em>没有时间</em>去做他们谈论的事。如果相比于你周围的人，你能把你的工作做的毫不费劲，那就说明你的工作做对了。</p><h3 id="做一名文化传教士"><a href="#做一名文化传教士" class="headerlink" title="做一名文化传教士"></a>做一名文化传教士</h3><blockquote><p>上士闻道，(When a superior man hears of the Tao, )</p><p>勤而行之；(he immediately begins to embody it.)</p><p>中士闻道，(When an average man hears of the Tao, )</p><p>若存若亡；(he half believes it, half doubts it.)</p><p>下士闻道，(When a foolish man hears of the Tao, )</p><p>大笑之。(he laughs out loud.)</p><p>不笑不足以為道。(If he didn’t laugh, it wouldn’t be the Tao.)</p></blockquote><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#41" target="_blank" rel="noopener">[41]</a></p><p>去年秋天，我和一群联邦雇员参加了一堂 MBA 的商业准则课程。当我开始介绍我们公司的文化、价值和伦理框架时，我得到的直接印象是：我的同学和教授都认为我就像一个天真可爱的小姑娘，做着许多关于公司应该如何运作的<a href="https://opensource.com/open-organization/15/9/reflections-open-organization-starry-eyed-dreamer" target="_blank" rel="noopener">甜美白日梦</a>。他们告诉我事情不可能是他们看起来的那样，他们还告诉我应该进一步考察。</p><p>所以我照做了。</p><p>然而我发现的是：事情<em>恰好</em>是他们看起来的那样。</p><p>在开放性组织，关于企业文化，人们应该随着企业的成长而时时维护那些文化，以使它随时精神焕发，充满斗志。我（和其它开源组织的成员）并不想过着如我同学们所描述的那样，“为生活而工作”。我需要有激情、有目标，需要明白自己的日常工作是如何对那些我所坚信的东西做贡献的。</p><p>作为一个项目管理者，你可能会认为在你的团队中，你的工作对培养你们公司的企业文化没有多少帮助。然而你的工作正是孕育文化本身。</p><h3 id="Kaizen-持续改善"><a href="#Kaizen-持续改善" class="headerlink" title="Kaizen (持续改善)"></a>Kaizen (持续改善)</h3><blockquote><p>为学日益，(In pursuit of knowledge, every day something is added.)</p><p>为道日损。(In the practice of the Tao, every day something is dropped.)</p><p>损之又损，(Less and less do you need to force things, )</p><p>以至于无为。(until finally you arrive at non-action.)</p><p>无为而无不为。(When nothing is done, nothing is left undone.)</p></blockquote><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#48" target="_blank" rel="noopener">[48]</a></p><p>项目管理的常规领域都太过于专注最新、最强大的的工具，但对于应该使用哪种工具，这个问题的答案总是一致的：“最简单的”。</p><p>例如，我将任务列表放在桌面的一个文本文件中，因为它很单纯，不会受到不必要的干扰。您想介绍给团队的，无论是何种工具、流程和程序都应该是能提高效率，排除障碍的，而不是引入额外的复杂性。所以与其专注于工具，还不如专注于要使用这些工具来解决的<em>问题</em>。</p><p>作为一个项目经理，我最喜爱的部分是在敏捷世界中，我有自由抛弃那些没有成效的东西的权利。这与 <a href="https://www.kaizen.com/about-us/definition-of-kaizen.html" target="_blank" rel="noopener">kaizen</a> 的概念相关，或叫 “持续改进”。不要害怕尝试和失败。失败是我们在探索什么能够起作用，什么不能起作用的过程中所用的标签，这是提高的唯一方式。</p><p>最好的过程都不是一蹴而就的。作为项目管理者，你应该通过支持他们，而不是强迫他们去做某些事来帮助你的团队。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><blockquote><p>天下皆谓我”道”大，(Some say that my teaching is nonsense.)</p><p>似不肖。(Others call it lofty but impractical.)</p><p>夫唯大，(But to those who have looked inside themselves, )</p><p>故似不肖。(this nonsense makes perfect sense.)</p><p>若肖，(And to those who put it into practice, )</p><p>久矣其细也夫！(this loftiness has roots that go deep.)</p></blockquote><p><a href="http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html#67" target="_blank" rel="noopener">[67]</a></p><p>我相信开放性组织正在做的事。开放性组织在管理领域的工作几乎与他们提供的产品和服务一样重要。我们有机会以身作则，激发他人的激情和目的，创造激励和充分授权的工作环境。</p><p>我鼓励你们找到办法把这些想法融入到自己的项目和团队中，看看会发生什么。了解你们组织的使命，知晓你的项目是如何为这个使命做贡献的。鼓起勇气，尝试某些看起来没有多少成效的事，同时不要忘记和我们的社区分享你所学到的经验，这样我们就可以继续改进。</p><hr><p>via: <a href="https://opensource.com/open-organization/16/2/tao-project-management" target="_blank" rel="noopener">https://opensource.com/open-organization/16/2/tao-project-management</a><br>publish: <a href="https://linux.cn/article-7385-1.html" target="_blank" rel="noopener">https://linux.cn/article-7385-1.html</a></p><p>作者：<a href="https://opensource.com/users/amatlack" target="_blank" rel="noopener">Allison Matlack</a><br>译者：<a href="https://github.com/runningwater" target="_blank" rel="noopener">runningwater</a><br>校对：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/BUSINESS_orgchart1.png?itok=tukiFj89&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://acc6.its.brooklyn.cuny.edu/~phalsall/texts/taote-v3.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;道德经&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Tao_Te_Ching&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;被认为&lt;/a&gt;是由圣人&lt;a href=&quot;http://plato.stanford.edu/entries/laozi/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;老子&lt;/a&gt;于公元前六世纪时所编写，是现存最为广泛翻译的经文之一。从&lt;a href=&quot;https://en.wikipedia.org/wiki/Taoism&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宗教&lt;/a&gt;到&lt;a href=&quot;http://www.imdb.com/title/tt0234853/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于约会的有趣电影&lt;/a&gt;等方方面面，它都深深地影响着它们，作者们借用它来做隐喻，以解释各种各样的事情（甚至是&lt;a href=&quot;http://www.mit.edu/~xela/tao.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编程&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;在思考有关开放性组织的项目管理时，我的脑海中便立马浮现出上面的这段文字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="项目管理" scheme="https://fsslc.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="道德经" scheme="https://fsslc.github.io/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 如何在 Linux 中根据国家位置来阻断网络流量</title>
    <link href="https://fsslc.github.io/2016/01/14/Translate-How-to-block-network-traffic-by-country-on-Linux/"/>
    <id>https://fsslc.github.io/2016/01/14/Translate-How-to-block-network-traffic-by-country-on-Linux/</id>
    <published>2016-01-14T01:12:52.000Z</published>
    <updated>2020-03-24T00:49:37.968Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根据 IP 地址进行网络流量阻断</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200324084400.png" alt="source: https://www.needpix.com/photo/download/1790674/network-networking-block-chain-communication-media-connection-business-internet-multimedia" title="">                </div>                <div class="image-caption">source: https://www.needpix.com/photo/download/1790674/network-networking-block-chain-communication-media-connection-business-internet-multimedia</div>            </figure><a id="more"></a><p>作为一名维护 Linux 生产服务器的系统管理员，你可能会遇到这样一些情形：你需要<strong>根据地理位置，选择性地阻断或允许网络流量通过。</strong> 例如你正经历一次由注册在某个特定国家的 IP 发起的 DoS 攻击；或者基于安全考虑，你想阻止来自未知国家的 SSH 登录请求；又或者你的公司对某些在线视频有分销权，它要求只能在特定的国家内合法发行；抑或是由于公司的政策，你需要阻止某个本地主机将文件上传至任意一个非美国的远程云端存储。</p><p>所有的上述情形都需要设置防火墙，使之具有<strong>基于国家位置过滤流量</strong>的功能。有几个方法可以做到这一点，其中之一是你可以使用 TCP wrappers 来为某个应用（例如 SSH，NFS， httpd）设置条件阻塞。但其缺点是你想要保护的那个应用必须以支持 TCP wrappers 的方式构建。另外，TCP wrappers 并不总是能够在各个平台中获取到（例如，Arch Linux <a href="http://xmodulo.com/block-unwanted-ip-addresses-linux.html" target="_blank" rel="noopener">放弃了</a>对它的支持）。另一种方式是结合基于国家的 GeoIP 信息，设置 <a href="http://xtables-addons.sourceforge.net/geoip.php" target="_blank" rel="noopener">ipset</a>，并将它应用到 iptables 的规则中。后一种方式看起来更有希望一些，因为基于 iptables 的过滤器是与应用无关的，且容易设置。</p><p>在本教程中，我将展示 <strong>另一个基于 iptables 的 GeoIP 过滤器，它由 xtables-addons 来实现</strong>。对于那些不熟悉它的人来说， xtables-addons 是用于 netfilter/iptables 的一系列扩展。一个包含在 xtables-addons 中的名为 xt_geoip 的模块扩展了 netfilter/iptables 的功能，使得它可以根据流量来自或流向的国家来进行过滤，IP 掩蔽（NAT）或丢包。若你想使用 xt_geoip，你不必重新编译内核或 iptables，你只需要使用当前的内核构建环境（/lib/modules/`uname -r`/build）以模块的形式构建 xtables-addons。同时也不需要进行重启。只要你构建并安装了 xtables-addons ， xt_geoip 便能够配合 iptables 使用。</p><p>至于 xt_geoip 和 ipset 之间的比较，<a href="http://xtables-addons.sourceforge.net/geoip.php" target="_blank" rel="noopener">xtables-addons 的官方网站</a> 上是这么说的： 相比于 ipset，xt_geoip 在内存占用上更胜一筹，但对于匹配速度，基于哈希的 ipset 可能更有优势。</p><p>在教程的余下部分，我将展示<strong>如何使用 iptables/xt_geoip 来根据流量的来源地或流入的国家阻断网络流量</strong>。</p><h3 id="在-Linux-中安装-xtables-addons"><a href="#在-Linux-中安装-xtables-addons" class="headerlink" title="在 Linux 中安装 xtables-addons"></a>在 Linux 中安装 xtables-addons</h3><p>下面介绍如何在各种 Linux 平台中编译和安装 xtables-addons。</p><p>为了编译 xtables-addons，首先你需要安装一些依赖软件包。</p><h4 id="在-Debian，Ubuntu-或-Linux-Mint-中安装依赖"><a href="#在-Debian，Ubuntu-或-Linux-Mint-中安装依赖" class="headerlink" title="在 Debian，Ubuntu 或 Linux Mint 中安装依赖"></a>在 Debian，Ubuntu 或 Linux Mint 中安装依赖</h4><pre><code class="lang-bash">$ sudo apt-get install iptables-dev xtables-addons-common libtext-csv-xs-perl pkg-config</code></pre><h4 id="在-CentOS，RHEL-或-Fedora-中安装依赖"><a href="#在-CentOS，RHEL-或-Fedora-中安装依赖" class="headerlink" title="在 CentOS，RHEL 或 Fedora 中安装依赖"></a>在 CentOS，RHEL 或 Fedora 中安装依赖</h4><p>CentOS/RHEL 6 需要事先设置好 EPEL 仓库（为 perl-Text-CSV_XS 所需要）。</p><pre><code class="lang-bash">$ sudo yum install gcc-c++ make automake kernel-devel-`uname -r` wget unzip iptables-devel perl-Text-CSV_XS</code></pre><h4 id="编译并安装-xtables-addons"><a href="#编译并安装-xtables-addons" class="headerlink" title="编译并安装 xtables-addons"></a>编译并安装 xtables-addons</h4><p>从 <code>xtables-addons</code> 的<a href="http://xtables-addons.sourceforge.net/" target="_blank" rel="noopener">官方网站</a> 下载源码包，然后按照下面的指令编译安装它。</p><pre><code class="lang-bash">$ wget http://downloads.sourceforge.net/project/xtables-addons/Xtables-addons/xtables-addons-2.10.tar.xz$ tar xf xtables-addons-2.10.tar.xz$ cd xtables-addons-2.10$ ./configure$ make$ sudo make install</code></pre><p>需要注意的是，对于基于红帽的系统（CentOS、RHEL、Fedora），它们默认开启了 SELinux，所以有必要像下面这样调整 SELinux 的策略。否则，SELinux 将阻止 iptables 加载 xt_geoip 模块。</p><pre><code class="lang-bash">$ sudo chcon -vR --user=system_u /lib/modules/$(uname -r)/extra/*.ko$ sudo chcon -vR --type=lib_t /lib64/xtables/*.so</code></pre><h3 id="为-xtables-addons-安装-GeoIP-数据库"><a href="#为-xtables-addons-安装-GeoIP-数据库" class="headerlink" title="为 xtables-addons 安装 GeoIP 数据库"></a>为 xtables-addons 安装 GeoIP 数据库</h3><p>下一步是安装 GeoIP 数据库，它将被 xt_geoip 用来查询 IP 地址与国家地区之间的对应关系。方便的是，<code>xtables-addons</code> 的源码包中带有两个帮助脚本，它们被用来从 MaxMind 下载 GeoIP 数据库并将它转化为 xt_geoip 可识别的二进制形式文件；它们可以在源码包中的 geoip 目录下找到。请遵循下面的指导来在你的系统中构建和安装 GeoIP 数据库。</p><pre><code class="lang-bash">$ cd geoip$ ./xt_geoip_dl$ ./xt_geoip_build GeoIPCountryWhois.csv$ sudo mkdir -p /usr/share/xt_geoip$ sudo cp -r {BE,LE} /usr/share/xt_geoip</code></pre><p>根据 <a href="https://support.maxmind.com/geoip-faq/geoip2-and-geoip-legacy-databases/how-accurate-are-your-geoip2-and-geoip-legacy-databases/" target="_blank" rel="noopener">MaxMind</a> 的说明,他们的 GeoIP 数据库能够以 99.8% 的准确率识别出 ip 所对应的国家，并且每月这个数据库将进行更新。为了使得本地安装的 GeoIP 数据是最新的，或许你需要设置一个按月执行的 <a href="http://ask.xmodulo.com/add-cron-job-linux.html" target="_blank" rel="noopener">cron job</a> 来时常更新你本地的 GeoIP 数据库。</p><h3 id="阻断来自或流向某个国家的网络流量"><a href="#阻断来自或流向某个国家的网络流量" class="headerlink" title="阻断来自或流向某个国家的网络流量"></a>阻断来自或流向某个国家的网络流量</h3><p>一旦 xt_geoip 模块和 GeoIP 数据库安装好后，你就可以在 iptabels 命令中使用 geoip 的匹配选项。</p><pre><code class="lang-bash">$ sudo iptables -m geoip --src-cc country[,country...] --dst-cc country[,country...]</code></pre><p>你想要阻断流量的那些国家是使用<a href="https://en.wikipedia.org/wiki/ISO_3166-1" target="_blank" rel="noopener">2个字母的 ISO3166 代码</a> 来特别指定的（例如 US（美国）、CN（中国）、IN（印度）、FR（法国））。</p><p>例如，假如你想阻断来自也门（YE） 和 赞比亚（ZM）的流量，下面的 iptabels 命令便可以达到此目的。</p><pre><code class="lang-bash">$ sudo iptables -I INPUT -m geoip --src-cc YE,ZM -j DROP</code></pre><p>假如你想阻断流向中国（CN） 的流量，可以运行下面的命令：</p><pre><code class="lang-bash">$ sudo iptables -A OUTPUT -m geoip --dst-cc CN -j DROP</code></pre><p>匹配条件也可以通过在 <code>--src-cc</code> 或 <code>--dst-cc</code> 选项前加 <code>!</code> 来达到相反的目的：</p><p>假如你想在你的服务器上阻断来自所有非美国的流量，可以运行：</p><pre><code class="lang-bash">$ sudo iptables -I INPUT -m geoip ! --src-cc US -j DROP</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://c2.staticflickr.com/6/5654/23665427845_050241b03f_c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="对于使用-Firewall-cmd-的用户"><a href="#对于使用-Firewall-cmd-的用户" class="headerlink" title="对于使用 Firewall-cmd 的用户"></a>对于使用 Firewall-cmd 的用户</h4><p>某些发行版本例如 CentOS/RHEL7 或 Fedora 已经用 firewalld 替代了 iptables 来作为默认的防火墙服务。在这些系统中，你可以类似使用 xt_geoip 那样，使用 firewall-cmd 来阻断流量。利用 firewall-cmd 命令，上面的三个例子可被重新写为：</p><pre><code class="lang-bash">$ sudo firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -m geoip --src-cc YE,ZM -j DROP$ sudo firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -m geoip --dst-cc CN -j DROP$ sudo firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -m geoip ! --src-cc US -j DROP</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本教程中，我展示了使用 iptables/xt_geoip 来根据流量的来源地或流入的国家轻松地阻断网络流量。假如你有这方面的需求，把它部署到你的防火墙系统中可以使之成为一个实用的办法。作为最后的警告，我应该提醒你的是：在你的服务器上通过基于 GeoIP 的流量过滤来禁止特定国家的流量并不总是万无一失的。GeoIP 数据库本身就不是很准确或齐全，且流量的来源或目的地可以轻易地通过使用 VPN、Tor 或其他任意易受攻击的中继主机来达到欺骗的目的。基于地理位置的过滤器甚至可能会阻止本不该阻止的合法网络流量。在你决定把它部署到你的生产环境之前请仔细考虑这个限制。</p><hr><p>via: <a href="http://xmodulo.com/block-network-traffic-by-country-linux.html" target="_blank" rel="noopener">http://xmodulo.com/block-network-traffic-by-country-linux.html</a></p><p>作者：<a href="http://xmodulo.com/author/nanni" target="_blank" rel="noopener">Dan Nanni</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;根据 IP 地址进行网络流量阻断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200324084400.png&quot; alt=&quot;source: https://www.needpix.com/photo/download/1790674/network-networking-block-chain-communication-media-connection-business-internet-multimedia&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;source: https://www.needpix.com/photo/download/1790674/network-networking-block-chain-communication-media-connection-business-internet-multimedia&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="阻断网络" scheme="https://fsslc.github.io/tags/%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C/"/>
    
      <category term="xtables-addons" scheme="https://fsslc.github.io/tags/xtables-addons/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 AFEPack</title>
    <link href="https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/</id>
    <published>2015-11-03T06:02:55.000Z</published>
    <updated>2020-03-21T05:14:01.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 AFEPack</p></blockquote><p><strong>Update</strong><br>相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考<a href="https://hub.docker.com/r/fsslc/afepack/" target="_blank" rel="noopener">我的说明</a>进行安装，当然，当时做的时候有些库可能用不了了。。</p><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）</p><a id="more"></a><h2 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h2><p>首先，下载好 deal.II、AFEPack、mpich（非必须） 这几个软件的安装包。</p><p>其中的 deal.II 和 AFEPack 可以到我的百度网盘去下载，这个是我从我大学同学的未来的师兄那里获得的，而那位师兄的老师正是这个软件包的作者 李若 老师。由于高版本的 deal.II 版本经过了许多的修改，且鉴于 AFEPack 几乎停滞的开发状态，我们采用的是 deal.II 的 6.3.1 版本。而 mpich 则可以到官网去下载最新的稳定版本。</p><p>相关软件的下载地址为：</p><p>deal.II 和 AFEPack : 链接: <a href="https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g</a> 密码: utxt<br>mpich : <a href="http://www.mpich.org/downloads/" target="_blank" rel="noopener">http://www.mpich.org/downloads/</a></p><p>下载好这些包后，将他们进行解压备用。</p><h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>接下来，安装一些必要的软件。</p><p>首先安装 boost 库。这个可以用命令行，也可以使用 synaptic (新得立) 这个图形化的包管理软件来安装。命令行需要使用的命令为：</p><pre><code class="lang-bash">sudo apt-get install libboost-dbg  libboost-all-dev</code></pre><p>接着安装自动化产生 <code>makefile</code> 的相关工具。其中 <code>aclocal</code> 已经被包括在 <code>autoconf</code> 里了。</p><pre><code class="lang-bash">sudo apt-get install autoconf automake</code></pre><p>接着安装编译器，由于某些原因，编译 AFEPack 时，用高版本(如 4.8)的 gcc 和 g++ 会出错，所以需要安装对应的低版本的包。这里安装 4.6 版本。</p><pre><code class="lang-bash">sudo apt-get install gcc-4.6 g++-4.6 gfortran#  降低 gcc，g++ 的版本，可以在后面改回来cd /usr/binsudo ln -s gcc-4.6 gccsudo ln -s g++-4.6 g++</code></pre><h2 id="安装-deal-II"><a href="#安装-deal-II" class="headerlink" title="安装 deal.II"></a>安装 deal.II</h2><p>根据李若老师的解释，他选用这个包的原因是看上了这个包里面 <code>lac</code> 、 <code>base</code> 中的代码，即关于基础线性代数相关的代码写得很好，所以才采用了 deal.II 。所以我们可以只编译里面的部分文件，当然如果你不在乎占用一点额外的磁盘空间，也可以选择完整安装。</p><p>关于安装路径，下面以我的安装位置 <code>/home/lc/Pkg/deal.II</code> 来举例，其中 <code>/home/lc</code> 为我的家目录，可以对应地修改，也可以安装到其他路径，如 <code>/usr/local/deal.II</code> 等。</p><p>首先，进入解压后的 deal.II 目录，我的在 <code>/home/lc/Pkg/deal.II</code> 。 然后在终端中依次输入下面的命令，其中 # 后的内容为注释，可以忽略。</p><pre><code class="lang-bash">cd /home/lc/Pkg/deal.II # 进入解压后的 deal.II 目录./configuremake -j4 lac base contrib # -j 选项是启用多线程，以此来加快编译的速度，后面的数字最好与你机子的 CPU 的线程数相同或更少# 或者使用 make all 来完整安装</code></pre><p>经过一段时间后(根据你的机器配置而定)，就把需要的文件编译好了。下面需要做一些软链接。在以前安装时，我尝试过直接把 deal.II 编译后产生的相应目录加在系统变量中，然后再安装 AFEPack，结果 AFEPack 不能找到 deal.II 的头文件，所以还是做个链接。具体的原因我也不清楚，可能需要问作者本人。</p><p>下面是我做链接时使用的命令，请相应做些修改：</p><pre><code class="lang-bash">cd /usr/local/includesudo ln -s ~/Pkg/deal.II/deal.II/include/ .sudo ln -s ~/Pkg/deal.II/lac/include/lac/ .sudo ln -s ~/Pkg/deal.II/base/include/base/ .sudo ln -s ~/Pkg/deal.II/contrib/tbb/tbb22_20090809oss/include/tbb/ .# 这里的 tbb22_20090809oss 可能会有所不同，但一般这个目录都是以 tbb 开头的，可用 Tab 键来自动补全；# 最后的 `.` 代指当前目录 ，以下类型cd /usr/local/libsudo ln -s ~/Pkg/deal.II/lib/lib* .</code></pre><h2 id="安装-mpich"><a href="#安装-mpich" class="headerlink" title="安装 mpich"></a>安装 mpich</h2><p><strong>这个不是必须的，除了 mpich，也可以直接安装<br>OpenMPI</strong>。</p><p>这个的安装可以根据解压后文件夹中的指示来操作，一般都是如下几个命令：</p><pre><code class="lang-bash">cd /home/lc/Pkg/mpich2/ # 进入 mpich2 解压后的目录，根据你自己的情况调整./configuremake -j4sudo make install</code></pre><p>这样就安装好了 mpich。</p><p>当然，我们也可以直接使用软件源里面的 mpich，这样或许更省事些。</p><h2 id="安装-AFEPack"><a href="#安装-AFEPack" class="headerlink" title="安装 AFEPack"></a>安装 AFEPack</h2><p>现在进行 AFEPack 的安装。首先利用 autotools 套件中的软件(即 aclocal，autoconf，automake 等)来自动生成 configure 文件。使用的命令如下：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPackaclocalautoconfautomake --add-missing</code></pre><p>然后把</p><pre><code class="lang-bash"># AFEPack templeteexport AFEPACK_TEMPLATE_PATH=&quot;/home/lc/Pkg/AFEPack/template/triangle:/home/lc/Pkg/AFEPack/template/rectangle:/home/lc/Pkg/AFEPack/template/interval:/home/lc/Pkg/AFEPack/template/twin_triangle:/home/lc/Pkg/AFEPack/template/tetrahedron:/home/lc/Pkg/AFEPack/template/twin_tetrahedron:/home/lc/Pkg/AFEPack/template/four_tetrahedron&quot;</code></pre><p>加到 <code>～/.bashrc</code> 文件中，然后使用 <code>source ~/.bashrc</code> 来使更改生效。</p><p>接着对 AFEPack 进行配置和编译。</p><pre><code class="lang-bash">./configuremake -j4</code></pre><p>编译期间会报错停掉，报 mpi.h 找不到。这时仍然继续，输入：</p><pre><code class="lang-bash">make install</code></pre><p>然后进入 AFEPack 目录下的 template 目录，来编译模板。我使用的命令为：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPack/templatemake</code></pre><p>现在来编译关于 mpi 的静态文件。这里需要 MPI 的相关库，这里我们使用的是 mpich。</p><pre><code class="lang-bash">~/Pkg/AFEPack/library/mpimake -j4</code></pre><p>example 子目录下有一些实用的工具，我们现在来编译它们。</p><pre><code class="lang-bash">cd ~/Pkg/AFEPack/examplemake -j4</code></pre><p>最后执行下面的命令来使得 <code>ld</code> 能够找到 <code>AFEPack.so</code> 等静态库。</p><pre><code class="lang-bash">cd ～/Pkg/AFEPacksudo ldconfig</code></pre><p>至此， AFEPack 的安装就结束了。</p><p>如果你在安装期间有什么问题，可以来询问我，我尽量帮忙。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="dsec.pku.edu.cn/~rli/software_e.php">AFEPack 官网</a></li><li><a href="https://zhuanlan.zhihu.com/p/25360918" target="_blank" rel="noopener">尝试在ubuntu 16.04下安装AFEPack</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 AFEPack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;br&gt;相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考&lt;a href=&quot;https://hub.docker.com/r/fsslc/afepack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的说明&lt;/a&gt;进行安装，当然，当时做的时候有些库可能用不了了。。&lt;/p&gt;
&lt;h2 id=&quot;系统准备&quot;&gt;&lt;a href=&quot;#系统准备&quot; class=&quot;headerlink&quot; title=&quot;系统准备&quot;&gt;&lt;/a&gt;系统准备&lt;/h2&gt;&lt;p&gt;我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="deal.II" scheme="https://fsslc.github.io/tags/deal-II/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下 OpenDX Data Explorer 的字体问题</title>
    <link href="https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/"/>
    <id>https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/</id>
    <published>2015-11-03T05:51:25.000Z</published>
    <updated>2020-03-21T06:47:47.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解决在 Ubuntu 下 OpenDX Data Explorer 的字体问题</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/OpenDX.png" alt="OpenDX Logo" title="">                </div>                <div class="image-caption">OpenDX Logo</div>            </figure><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近一直在学习使用李若老师的 AFEPack 软件包，其中这个包输出的图形格式一般为 OpenDX，但据网上的一些评论，它基本上处于类似渡渡鸟的境地了。但自己能力有限，还不能更改它输出为 Vtk 等现在主流的图像格式，所以还是先用着吧。</p><p>现在读取 OpenDX 格式的软件好像就只有 <code>OpenDX Data Explorer</code> 了。自从 IBM 开源了 OpenDX 后，就没有多少官方的支持，现在它的开发主要由一个名为 <code>Visualization and Imagery Solutions, Inc.</code> 的公司负责。在 Ubuntu 中，可以直接通过软件源安装编译好的 dx 软件。</p><p>安装后，可以在终端中使用 dx 命令来启动 OpenDX Data Explorer。但终端始终会出现类似如下的警告：</p><pre><code class="lang-bash">Cannot convert string &quot;-*-helvetica-bold-r-*-*-16-*&quot; to type FontStruct</code></pre><p>于是乎，便利用网络来搜索答案。下面是解决办法。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>搜索的过程就不说了，反正还是 Google 强。</p><p>最开始说的是先确认下有没有安装这些字体。一般是先建议你安装两个字体包，使用的命令是：</p><pre><code class="lang-bash">sudo apt-get install xfonts-75dpi xfonts-100dpi</code></pre><p>它们默认是安装在 <code>/usr/share/fonts/X11/</code> 目录中。</p><p>然后可以使用下面的命令来查看是否安装了上面警告中的字体：</p><pre><code class="lang-bash">xlsfonts -fn &quot;-*-helvetica-bold-r-*-*-10-*-*-*-*-*-*-*&quot;</code></pre><p>其中的 <code>*</code> 都是一些匹配。可以类似地修改匹配格式。</p><p>但是安装完后还是没有解决问题。于是又搜。</p><p>最后在<a href="http://www.linuxquestions.org/questions/linux-software-2/error-message-regarding-fonts-in-grace-943919/" target="_blank" rel="noopener">这个网页</a>里面找到了解决办法。</p><p>原来，在安装完这些字体后，我们还需要一些设置，具体的命令是：</p><pre><code class="lang-bash">xset +fp /usr/share/fonts/X11/75dpi/xset +fp /usr/share/fonts/X11/100dpi/</code></pre><p>至于上面的命令具体执行了什么步骤，可以 <code>man xset</code> 。随后问题便解决了。遇到类似的问题（例如某个软件中文乱码，呈现出方框），似乎都可以这样解决。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>最后说说我对 OpenDX 的看法吧。</p><p>刚开始入门的时候，总感觉资料很少，这个软件不太好使用。相比于 ViSit 或 ParaView 等软件，dx 太难用了，什么都要自己定义，而且找到的资料也不是很多；所以对它的印象不好。</p><p>现在由于导师分配的任务，我需要使用 AFEPack 来求解方程，最后需要用 dx 来展示结果。通过这几天的摸索，感觉了它的强大。现在基本明白了为什么李若老师喜欢这种数据格式和这个软件的原因了。说到底，还是需要折腾。</p><p>至于学习资料。安装好 dx 后，一般可以在 <code>/usr/share/dx/samples</code> 找到示例代码；文档说明的话，可以看 <code>/usr/share/dx/html</code> 里面的东西，这些 html 文件里面包含的内容其实很多的。一步一步的看下去还是有很多收获的。</p><p>至于 <code>Visualization and Imagery Solutions, Inc.</code> 公司出的那本名为 <code>OpenDX---Paths to Visualization</code> 的书，我觉得自带的 html 文件内容或许更多一些，当然看看还是不错的。</p><p>以前我在<a href="http://web.engr.oregonstate.edu/~mjb/OpenDX/" target="_blank" rel="noopener">这个网站</a>找到了很多关于 OpenDX 的资料，现在仍然推荐去看看那里的东西。</p><p>TODO： 通过 Ubuntu 仓库安装 dx 软件有一个问题：</p><p>在经过一段时间的使用后， dx 会吃掉 100% 的 CPU。根据我的搜索，现在还没有找到解决办法，自编译的 dx 就好像没有这个问题。后面再搜索一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在 Ubuntu 下 OpenDX Data Explorer 的字体问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/OpenDX.png&quot; alt=&quot;OpenDX Logo&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;OpenDX Logo&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Font" scheme="https://fsslc.github.io/tags/Font/"/>
    
      <category term="OpenDX" scheme="https://fsslc.github.io/tags/OpenDX/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 FEniCS</title>
    <link href="https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/</id>
    <published>2015-10-12T04:32:13.000Z</published>
    <updated>2020-03-21T05:19:10.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 FEniCS</p></blockquote><p><img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/fenics_banner.png" alt="FEniCS Logo" style="zoom:50%;" /></p><p><strong>Update 20161212</strong><br>现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看<a href="https://fenics-containers.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">官网的说明</a>。这样就可以少折腾了。</p><a id="more"></a><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近导师去开了个会议，从其他人那里打听到有很多人都在 FEniCS 的基础上写代码了。导师她最开始认为，它是用来写 Fortran 代码的一个平台，加之她主要使用的编程语言为 Fortran，所以希望我们能够去学习一下。</p><p>第一次看到 FEniCS 这个词，应该可以追溯到我大四做毕业论文的时候。那时想找个软件来书写有限元程序，因为自己从底层开始写起太费事了。通过搜索，找到了许多软件，具体可以看看这个链接。通过试用，左右权衡，最后决定使用 deal.II 来做毕业论文。</p><p>当时对于 FEniCS 的认识是：</p><pre><code>它是用 Python 写的，自己对 Python 不熟悉，查找到的资料不是很齐全；当时自己尝试从 PPA 安装了 FEniCS， 但程序运行地不是很顺利；</code></pre><p>现在，通过这一两天的使用，觉得这货实在是太简单了，用 Python 根据它自定义的 UFL 语言来自动生成可执行代码，最后使用 OpenGL 和 VTK 来生成图形和 vtu 文件。当然，方便的代价就是编译过程的时间有点长；毕竟鱼和熊掌是不能兼得的。</p><p>PS：FEnics 还可以与 C, C++, Fortran, 或 MATLAB 交互，具体可以看<a href="https://hplgit.github.io/fenics-mixed/doc/web/index.html" target="_blank" rel="noopener">这里的文档</a>。</p><h2 id="FEniCS-的安装过程"><a href="#FEniCS-的安装过程" class="headerlink" title="FEniCS 的安装过程"></a>FEniCS 的安装过程</h2><h3 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h3><p>首先我的安装平台为 ubuntu 14.04, 64 位，但从自己安装的过程来看，其他系统应该也可以安装，大体步骤是一致的，具体可以看官网的说明。</p><p>特别说明：对于使用 Windows 系统的同学，你就别指望能够完美安装和运行 FEniCS 了，官网上说了， Windows 平台的安装包没有更新了。所以还是尽快学习一些 Linux 或 Unix 这类系统的使用方法吧。命令行真的非常好用，包管理器的使用也非常方便。</p><p>下面我是通过 Anaconda 这个 Python 集成环境来安装 FEniCS 的，所以你需要安装好 Anaconda。可以到官网的下载页面 去下载相应版本的安装包，这里我们使用的是 Anaconda-2.3.0-Linux-x86_64.sh，至于安装，该页面里有提示，这里不赘述了。</p><p>另外，在运行 FEniCS 的程序之前，需要安装好 gcc g++ gfortran 等编译器，不然会出现意想不到的错误。可以使用如下的命令来安装这些软件：</p><pre><code class="lang-bash">sudo apt-get install build-essential gfortran</code></pre><h3 id="具体的安装过程"><a href="#具体的安装过程" class="headerlink" title="具体的安装过程"></a>具体的安装过程</h3><p>根据官网的解释，有如下几种方法可以来进行安装：</p><ol><li>直接添加 PPA 来进行下载。</li></ol><p>但安装尝试后，会引入许多不必要的安装依赖如 texlive 等，为了不污染系统，所以没有采取这种方法。当然，如果你订阅了他们的 PPA，这种方式能够使你获取到最新的更新。如果你没有‘洁癖’，可以尝试这种方法。</p><p>(注： 最近(2015-12) 找到了如何在安装有 Texlive 发型包的情况下，不再引起上面需要安装 texlive 依赖的方法，具体请参考<a href="http://www.latexstudio.net/archives/4017.html" target="_blank" rel="noopener">这篇文章</a>的最后一段，但请自己制作 dummy package，因为在安装时，可能会出现一点问题，请根据问题的描述更改相应的配置文件。 )</p><ol><li>通过下载脚本编译。</li></ol><p>通过下面的这个脚本来从源文件编译安装 FEniCS。</p><pre><code class="lang-bash">curl -s http://fenicsproject.org/fenics-install.sh | bash</code></pre><p>但在尝试的过程中，总是提示 SSL 认证失败。无果，所以放弃了这种方法。</p><ol><li>直接下载虚拟机镜像来运行。</li></ol><p>将镜像导入 Vbox 后，大概用了 7G 的空间，镜像里的系统使用的是 Lubuntu，感觉很精简，但没有自己安装的 Ubuntu 体验好。又考虑到空间占用的原因，亦弃之。</p><ol><li>通过 Anaconda 来安装 FEniCS。</li></ol><p>可以根据<a href="https://github.com/juanlu001/fenics-recipes" target="_blank" rel="noopener">这个网页</a>的指导安装。</p><p>这个 github 仓库里面用的命令是：</p><pre><code class="lang-bash">conda install fenics mkl --channel juanlu001</code></pre><p>而官网里面使用的命令是：</p><pre><code class="lang-bash">conda create --name fenics27 python=2.7source activate fenics27conda install fenics --channel juanlu001</code></pre><p>我最开始是根据 Github 上的命令来安装的。而再给其他人安装的时候，我特别使用了官网了给出的命令，现在大致知道了它们之间的区别：前者是直接将 FEniCS 安装到 Anaconda 的目录里面，而后者是创建了一个新的环境，单独进行了安装。考虑到简洁性，我推荐第二个命令。</p><p>在终端中依次输入上面的命令后，会大概下载 300M 左右的安装包，最后安装完毕会有 4G 左右(加上 Anaconda 原来安装后的文件)。经过一段漫长的等待后，FEniCS 就安装好了。</p><h2 id="安装后需要做的事"><a href="#安装后需要做的事" class="headerlink" title="安装后需要做的事"></a>安装后需要做的事</h2><p>安装完成后，自然需要运行一下 FEniCS 自带的示例程序，它们一般在 <code>~/anaconda/envs/fenics27/share/dolfin/</code> 目录下。随便进入某个示例目录，可以有名为 <code>cpp</code> 和 <code>python</code> 的两个目录。先进入 python 这个目录试试效果。</p><p>在终端运行：</p><pre><code class="lang-bash">python filename.py # 注意请将这句中的 filename 换为具体的程序名称</code></pre><p>然后终端会报错，大致意思是没有找到 <code>dolfin</code> 这个 module。这应该是环境变量的问题，最后通过搜索，参考<a href="https://answers.launchpad.net/dolfin/+question/166153" target="_blank" rel="noopener">这里的说明</a>，我们需要将 dolfin.conf 这个文件加到 PYTHONPATH 环境变量中。命令为：</p><pre><code class="lang-bash">source &lt;PATH_TO_YOUR_DOLFIN_INSTALLATION&gt;/share/dolfin/dolfin.conf</code></pre><p>对于使用 Anaconda 安装 FEniCS 的情况，dolfin.conf 一般在 <code>~/anaconda/envs/fenics27/share/dolfin</code> 目录里。</p><p>最好是将这个上面这个命令写入你本地的 <code>.bashrc</code> 文件里面，然后用 <code>source ~/.bashrc</code> 更新环境变量。</p><p>这个做完后，总该可以运行程序了吧。可惜，还不行。你会看终端里报错，提示说某些 VTK 的动态链接库找不到，根据 Github 里的 <a href="https://github.com/Juanlu001/fenics-recipes/issues/33" target="_blank" rel="noopener">issue</a>，需要使用下面的命令将 VTK 的版本降低：</p><pre><code class="lang-bash">conda list vtkconda install &quot;vtk=5.10&quot;</code></pre><p>这样就可以运行程序了。在程序执行的开始，你可能会看到有些提示，说 MKL 库有 30 天的试用期限，要你购买。对于这种情况，Anaconda 给学校和科研机构提供有学术版的许可，只要你使用 edu 的邮箱就可以申请到, <a href="https://store.continuum.io/cshop/academicanaconda" target="_blank" rel="noopener">申请地址</a> 。</p><p>申请后，会得到一个 license 文件，将其放在 <code>~/.continuum</code> 目录下即可。</p><p>另外，我发现我自己申请的 license 同样也可以用在别人的机器上，不知这是不是一个 bug。</p><h3 id="安装后软件的学习"><a href="#安装后软件的学习" class="headerlink" title="安装后软件的学习"></a>安装后软件的学习</h3><p>关于入门，可以直接看官网的文档，例如 tutorial，The FEniCS Book, Manual。</p><p>PS： 可以到<a href="https://launchpadlibrarian.net/83776282/fenics-book-2011-10-27-final.pdf" target="_blank" rel="noopener">这里</a>下载到 The FEniCS Book。</p><p>关于这两天学习的感受：我是从 tutorial 入门的，看了过后感觉这货居然这么简单，相比于我用 deal.II 写代码，这不知要轻松多少倍。另外，tutorial 里面的例子有些代码不能运行了，应该是 dolfin(或其他组件) 更新的缘故，而文档还没有被更新。下一步继续看文档来学习。</p><p>以后深入后，再写点东西来分享。</p><p><strong>UPDATE 2018.07.31</strong><br>有几点需要更新的：</p><ol><li><p>偶然发现了这个 <a href="http://www.fenics-hpc.org" target="_blank" rel="noopener">网站</a>， 似乎是将 fenics 应用到 HPC 领域中，并且在 edx 中开了<a href="https://www.edx.org/course/high-performance-finite-element-modeling-kthx-hpfem01-1x#" target="_blank" rel="noopener">一门 MOOC</a></p></li><li><p>关于学习资源，可以看看 <a href="http://people.cs.uchicago.edu/~ridg/" target="_blank" rel="noopener">这个老师的主页</a>，里面课程中有一些 notes。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 FEniCS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/fenics_banner.png&quot; alt=&quot;FEniCS Logo&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 20161212&lt;/strong&gt;&lt;br&gt;现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看&lt;a href=&quot;https://fenics-containers.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网的说明&lt;/a&gt;。这样就可以少折腾了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="FEniCS" scheme="https://fsslc.github.io/tags/FEniCS/"/>
    
      <category term="Anaconda" scheme="https://fsslc.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装设置 deal.II、VisIt 和 ParaView</title>
    <link href="https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/</id>
    <published>2015-10-10T04:07:08.000Z</published>
    <updated>2020-03-21T06:36:40.088Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何在 Ubuntu 中安装设置 deal.II、VisIt 和 ParaView</p></blockquote><h2 id="deal-II-的安装与配置"><a href="#deal-II-的安装与配置" class="headerlink" title="deal.II 的安装与配置"></a>deal.II 的安装与配置</h2><p><img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200321141619.png" alt="deal.II Logo" style="zoom:200%;" style="margin: 0 auto;" /></p><a id="more"></a><h3 id="deal-II-的安装"><a href="#deal-II-的安装" class="headerlink" title="deal.II 的安装"></a>deal.II 的安装</h3><p>关于安装，有如下几种方式：</p><ol><li><p>到 deal.II 的下载页面去下载打包好的文件：</p><p> 对于 Ubuntu、Mac、Debain 都已经有编译好的二进制文件，Arch、Gentoo 可以分别通过 AUR 和 Gentoo Science Overlay 来得到；</p></li><li><p>利用 docker 来生成相关的镜像，具体可以参考<a href="https://hub.docker.com/r/dealii/dealii/" target="_blank" rel="noopener">这里</a>；</p></li><li><p>基于源码安装：</p><p> 官网上推荐 <a href="https://github.com/dealii/candi" target="_blank" rel="noopener">candi</a>，也可以通过 <a href="https://spack.io/" target="_blank" rel="noopener">spack</a>来安装。</p></li></ol><p>可以按照<a href="https://www.dealii.org/download.html" target="_blank" rel="noopener">官网的指南</a>来进行按照。</p><p>下面是我自己的安装过程，算是一个记录吧。</p><p>下载好源文件后，进行解压，然后进入解压的目录，具体安装方法可以通过 README.md 这个文件知晓。需要注意的是 deal.II 是一套有限元 C++ 库，所以在 Linux 上面需要进行编译安装。编译时，需要使用 cmake 和 make，所以先将这两个软件安装好。<br>然后依次执行下面的命令来进行编译安装：</p><pre><code class="lang-bash">cmake -DCMAKE_INSTALL_PREFIX=/path/where/deal.II/should/be/intalled/to ..make install  # (alternatively $ make -j&lt;N&gt; install)</code></pre><p>这里需要注意的是：</p><ol><li>如果 deal.II 的安装为一般用户不可写的目录，需要 <code>sudo</code> 命令；</li><li>为了加快编译的速度，在第二句中，在 make 后加上 <code>-jN</code> 参数，其中 N 最好不要超过电脑的最大 CPU 数目；</li></ol><p>执行完上面的命令后，接着就是漫长的等待了。在我的机子上 (Ubuntu 14.04, x86_64, Intel® Core™ i5-2430M CPU @ 2.40GHz × 4，SSD) 编译安装总共花了将近 40 min；一般的机子大概需要 1 个小时左右。</p><h3 id="deal-II-的配置"><a href="#deal-II-的配置" class="headerlink" title="deal.II 的配置"></a>deal.II 的配置</h3><p>首先是 将 deal.II 的目录加入系统环境变量之中，只需要在 <code>~/.bashrc</code> 中加入如下几行代码即可：</p><pre><code class="lang-bash"># deal.II 环境变量export PATH=/opt/deal.II:$PATHDEAL_II_DIR=/opt/deal.II</code></pre><p>在具体使用时，主要使用这三个命令：</p><pre><code class="lang-bash">cmake .make # 也可以直接使用 make release, 这样编译出来的出现运行快些make run</code></pre><p>关于 deal.II 的学习，开发者为自学者提供了详尽的文档，可以在 deal.II 的下载页面里找到离线的文档，并且在 deal.II 的安装目录下有文档中的示例代码；</p><p>另外，deal.II 的主要开发者 Wolfgan Bangerth 还在他的教学网址上提供了讲义和授课的<a href="http://www.math.colostate.edu/~bangerth/videos.html" target="_blank" rel="noopener">视频链接</a>(不过视频在 YouTube 上)。</p><p><strong>Update 20161210</strong><br>这里只是介绍了最简单的安装，要安装额外的软件库还需要自己去安装。可以参考 <a href="https://github.com/dealii/docker-files" target="_blank" rel="noopener">这里</a> 中的命令来进行安装。当然，在 Ubuntu 、Debian 、Gentoo 中有官方支持的版本，如果嫌麻烦，可以直接用包管理器安装。</p><h2 id="VisIt-的安装和配置"><a href="#VisIt-的安装和配置" class="headerlink" title="VisIt 的安装和配置"></a>VisIt 的安装和配置</h2><p><img src="https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200321141515.jpg" alt="VisIt Logo" style="zoom:80%;" /></p><h3 id="VisIt-的安装"><a href="#VisIt-的安装" class="headerlink" title="VisIt 的安装"></a>VisIt 的安装</h3><p>安装方面，首先到<a href="https://wci.llnl.gov/simulation/computer-codes/visit/" target="_blank" rel="noopener">官网</a>的下载页面里下载相关的包，并在同一页面下载 <code>Visit install script</code> 文件，具体安装过程，可以参考同一页面的 <code>Visit install notes</code> 。</p><h3 id="VisIt-的配置"><a href="#VisIt-的配置" class="headerlink" title="VisIt 的配置"></a>VisIt 的配置</h3><p>关于配置，在 <code>~/.bashrc</code> 中加入如下几行代码来添加环境变量：</p><pre><code class="lang-bash"># visit 环境变量export PATH=/opt/visit:$PATH</code></pre><p>当然，如果你想和我一样，想为 <code>VisIt</code> 添加一个快捷方式，来达到 在系统的应用里面直接点击图标就启动软件的目的，可以按照下面方法来进行。</p><p>首先创建一个名为 <code>visit.desktop</code> 的文件，然后进行编辑，将如下的内容复制到该文件中(当然你可以进行自定义)：</p><pre><code class="lang-bash">[Desktop Entry]Version=2.8.1Type=ApplicationName=VisItGenericName=image viewerComment=VisIt is an Open Source, interactive, scalable, visualization, animation and analysis tool.Exec=/opt/visit/bin/visitTerminal=falseMimeType=image/vtk;Icon=/opt/visit/visit.jpgCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><p>注意: 上面的 Icon 后面的图片是我从 visit 官网里下载的，当然可以使用其他图片。</p><p>最后保持修改的文件，然后将该文件移动到 <code>/usr/share/applications/</code> 目录中。当然，你也可以直接在这个目录中创建这个文件。这样，你就可以在系统的应用中找到 visit 了，通过点击图标就可以启动 visit。</p><h2 id="Paraview-的安装和配置"><a href="#Paraview-的安装和配置" class="headerlink" title="Paraview 的安装和配置"></a>Paraview 的安装和配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.paraview.org/wp-content/uploads/2018/02/ParaView_Logo.svg" alt="paraview Logo" title="">                </div>                <div class="image-caption">paraview Logo</div>            </figure><h3 id="Paraview-的安装"><a href="#Paraview-的安装" class="headerlink" title="Paraview 的安装"></a>Paraview 的安装</h3><p>当然，对于各种发行版本，对应的软件仓库里面可能已经有 paraview 的二进制包了，可以直接用相应的包管理器下载安装。</p><p>下面介绍的是自己手动安装 paraview 的过程。</p><p>首先到<a href="https://www.paraview.org/" target="_blank" rel="noopener">官网</a>的下载页面上选择适合自己机子的相应压缩包并下载。然后解压，将解压的文件夹复制到需要安装的位置即可。</p><h3 id="Paraview-的配置"><a href="#Paraview-的配置" class="headerlink" title="Paraview 的配置"></a>Paraview 的配置</h3><p>关于配置，和 visit 基本相似。</p><p>首先添加环境变量：</p><pre><code class="lang-bash"># paraview 环境变量export PATH=/opt/paraview:$PATH</code></pre><p>然后制作图标；方法与上面一致，这里只列出 <code>paraview.desktop</code> 文件的内容：</p><pre><code class="lang-bash">[Desktop Entry]Version=4.2Type=ApplicationName=ParaviewGenericName=image viewerComment=ParaView is an open-source, multi-platform data analysis and visualization applicationExec=/opt/paraview/bin/paraviewTerminal=falseMimeType=image/vtk;Icon=/opt/paraview/share/icons/hicolor/96x96/apps/paraview.pngCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写这个文档的目的主要是为了进行一些纪录，好在遗忘的时候可以查看，也当做是备份。<br>有限元软件当然不止这几个，还有如 gmesh、freefem++、getfem++ 等等，这里就不介绍了。总之学习之路漫漫，吾将上下而求索。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何在 Ubuntu 中安装设置 deal.II、VisIt 和 ParaView&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;deal-II-的安装与配置&quot;&gt;&lt;a href=&quot;#deal-II-的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;deal.II 的安装与配置&quot;&gt;&lt;/a&gt;deal.II 的安装与配置&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FSSlc/blogImg/master/img/20200321141619.png&quot; alt=&quot;deal.II Logo&quot; style=&quot;zoom:200%;&quot; style=&quot;margin: 0 auto;&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="deal.II" scheme="https://fsslc.github.io/tags/deal-II/"/>
    
      <category term="Paraview" scheme="https://fsslc.github.io/tags/Paraview/"/>
    
      <category term="VisIt" scheme="https://fsslc.github.io/tags/VisIt/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] LINUX 101: 让你的 SHELL 更强大</title>
    <link href="https://fsslc.github.io/2015/07/29/Translate-LINUX-101-POWER-UP-YOUR-SHELL/"/>
    <id>https://fsslc.github.io/2015/07/29/Translate-LINUX-101-POWER-UP-YOUR-SHELL/</id>
    <published>2015-07-29T00:00:27.000Z</published>
    <updated>2020-03-24T01:14:00.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我们的关于 shell 基础的指导下, 得到一个更灵活, 功能更强大且多彩的命令行界面</p></blockquote><p><strong>为何要这样做?</strong></p><ul><li>使得在 shell 提示符下过得更轻松, 高效</li><li>在失去连接后恢复先前的会话</li><li>Stop pushing around that fiddly rodent!</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/29/000326wwpxmtpvpnzq9ddz.png" alt="bash1" title="">                </div>                <div class="image-caption">bash1</div>            </figure><p>这是我的命令行提示符的设置。对于这个小的终端窗口来说，这或许有些长。但你可以根据你的喜好来调整它。</p><p>作为一个 Linux 用户, 你可能熟悉 shell (又名为命令行)。 或许你需要时不时的打开终端来完成那些不能在 GUI 下处理的必要任务，抑或是因为你处在一个将窗口铺满桌面的环境中，而 shell 是你与你的 linux 机器交互的主要方式。</p><a id="more"></a><p>在上面那些情况下，你可能正在使用你所使用的发行版本自带的 Bash 配置。 尽管对于大多数的任务而言，它足够好了，但它可以更加强大。 在本教程中，我们将向你展示如何使得你的 shell 提供更多有用信息、更加实用且更适合工作。 我们将对提示符进行自定义，让它比默认情况下提供更好的反馈，并向你展示如何使用炫酷的 <code>tmux</code> 工具来管理会话并同时运行多个程序。 并且，为了让眼睛舒服一点，我们还将关注配色方案。那么，进击吧，少女！</p><h3 id="让提示符更美妙"><a href="#让提示符更美妙" class="headerlink" title="让提示符更美妙"></a>让提示符更美妙</h3><p>大多数的发行版本配置有一个非常简单的提示符，它们大多向你展示了一些基本信息， 但提示符可以为你提供更多的内容。例如，在 Debian 7 下，默认的提示符是这样的:</p><pre><code class="lang-bash">mike@somebox:~$</code></pre><p>上面的提示符展示出了用户、主机名、当前目录和账户类型符号（假如你切换到 root 账户， <strong>$</strong> 会变为 <strong>#</strong>)。 那这些信息是在哪里存储的呢? 答案是：在 <strong>PS1</strong> 环境变量中。 假如你键入 <code>echo $PS1</code> ， 你将会在这个命令的输出字符串的最后有如下的字符：</p><pre><code class="lang-bash">\u@\h:\w$</code></pre><p>这看起来有一些丑陋，并在瞥见它的第一眼时，你可能会开始尖叫，认为它是令人恐惧的正则表达式，但我们不打算用这些复杂的字符来煎熬我们的大脑。这不是正则表达式，这里的斜杠是转义序列，它告诉提示符进行一些特别的处理。 例如，上面的 <strong>u</strong> 部分，告诉提示符展示用户名， 而 w 则展示工作路径.</p><p>下面是一些你可以在提示符中用到的字符的列表:</p><ul><li>d 当前的日期</li><li>h 主机名</li><li>n 代表换行的字符</li><li>A 当前的时间 (HH: MM)</li><li>u 当前的用户</li><li>w (小写) 整个工作路径的全称</li><li>W (大写) 工作路径的简短名称</li><li>$ 一个提示符号，对于 root 用户为 # 号</li><li>! 当前命令在 shell 历史记录中的序号</li></ul><p>下面解释 <strong>w</strong> 和 <strong>W</strong> 选项的区别: 对于前者，你将看到你所在的工作路径的完整地址，（例如 <strong>/usr/local/bin</strong>），而对于后者， 它则只显示 <strong>bin</strong> 这一部分。</p><p>现在，我们该怎样改变提示符呢? 你需要更改 <strong>PS1</strong> 环境变量的内容，试试下面这个：</p><pre><code class="lang-bash">export PS1=&quot;I am \u and it is \A $&quot;</code></pre><p>现在，你的提示符将会像下面这样：</p><pre><code class="lang-bash">I am mike and it is 11:26 $</code></pre><p>从这个例子出发，你就可以按照你的想法来试验一下上面列出的其他转义序列。 但等等 – 当你登出后，你的这些努力都将消失，因为在你每次打开终端时，<strong>PS1</strong> 环境变量的值都会被重置。解决这个问题的最简单方式是打开 <strong>.bashrc</strong> 配置文件（在你的家目录下） 并在这个文件的最下方添加上完整的 <code>export</code> 命令。在每次你启动一个新的 shell 会话时，这个 <strong>.bashrc</strong> 会被 <code>Bash</code> 读取, 所以你的加强的提示符就可以一直出现。你还可以使用额外的颜色来装扮提示符。刚开始，这将有点棘手，因为你必须使用一些相当奇怪的转义序列，但结果是非常漂亮的。 将下面的字符添加到你的 <strong>PS1</strong>字符串中的某个位置，最终这将把文本变为红色：</p><pre><code class="lang-bash">\[\e[31m\]</code></pre><p>你可以将这里的 31 更改为其他的数字来获得不同的颜色:</p><ul><li>30 黑色</li><li>32 绿色</li><li>33 黄色</li><li>34 蓝色</li><li>35 洋红色</li><li>36 青色</li><li>37 白色</li></ul><p>所以，让我们使用先前看到的转义序列和颜色来创造一个提示符，以此来结束这一小节的内容。深吸一口气, 弯曲你的手指，然后键入下面这只“野兽”：</p><pre><code class="lang-bash">export PS1=&quot;(\!) \[\e[31m\] \[\A\] \[\e[32m\]\u@\h \[\e[34m\]\w \[\e[30m\]$&quot;</code></pre><p>上面的命令提供了一个 Bash 命令历史序号、当前的时间、彩色的用户或主机名组合、以及工作路径。假如你“野心勃勃”，利用一些惊人的组合，你还可以更改提示符的背景色和前景色。非常有用的 Arch wiki 有一个关于颜色代码的完整列表：<a href="http://tinyurl.com/3gvz4ec" target="_blank" rel="noopener">http://tinyurl.com/3gvz4ec</a>。</p><blockquote><p><strong>Shell 精要</strong></p><p>假如你是一个彻底的 Linux 新手并第一次阅读这份杂志，或许你会发觉阅读这些教程有些吃力。 所以这里有一些基础知识来让你熟悉一些 shell。 通常在你的菜单中， shell 指的是 Terminal、 XTerm 或 Konsole， 当你启动它后， 最为实用的命令有这些：</p><p><strong>ls</strong> (列出文件名); <strong>cp one.txt two.txt</strong> (复制文件); <strong>rm file.txt</strong> (移除文件); <strong>mv old.txt new.txt</strong> (移动或重命名文件); </p><p><strong>cd /some/directory</strong> (改变目录); <strong>cd ..</strong> (回到上级目录); <strong>./program</strong> (在当前目录下运行一个程序); <strong>ls &gt; list.txt</strong> (重定向输出到一个文件)。</p><p>几乎每个命令都有一个手册页用来解释其选项（例如 <strong>man ls</strong> – 按 Q 来退出）。在那里，你可以知晓命令的选项，这样你就知道 <strong>ls -la</strong> 展示一个详细的列表，其中也列出了隐藏文件， 并且在键入一个文件或目录的名字的一部分后， 可以使用 Tab 键来自动补全。</p></blockquote><h3 id="Tmux-针对-shell-的窗口管理器"><a href="#Tmux-针对-shell-的窗口管理器" class="headerlink" title="Tmux: 针对 shell 的窗口管理器"></a>Tmux: 针对 shell 的窗口管理器</h3><p>在文本模式的环境中使用一个窗口管理器 – 这听起来有点不可思议， 是吧？ 然而，你应该记得当 Web 浏览器第一次实现分页浏览的时候吧？ 在当时， 这是在可用性上的一个重大进步，它减少了桌面任务栏的杂乱无章和繁多的窗口列表。 对于你的浏览器来说，你只需要一个按钮便可以在浏览器中切换到你打开的每个单独网站， 而不是针对每个网站都有一个任务栏或导航图标。 这个功能非常有意义。</p><p>若有时你同时运行着几个虚拟终端，你便会遇到相似的情况； 在这些终端之间跳转，或每次在任务栏或窗口列表中找到你所需要的那一个终端，都可能会让你觉得麻烦。 拥有一个文本模式的窗口管理器不仅可以让你像在同一个终端窗口中运行多个 shell 会话，而且你甚至还可以将这些窗口排列在一起。</p><p>另外，这样还有另一个好处：可以将这些窗口进行分离和重新连接。想要看看这是如何运行的最好方式是自己尝试一下。在一个终端窗口中，输入 <code>screen</code> （在大多数发行版本中，它已经默认安装了或者可以在软件包仓库中找到）。 某些欢迎的文字将会出现 – 只需敲击 Enter 键这些文字就会消失。 现在运行一个交互式的文本模式的程序，例如 <code>nano</code> ， 并关闭这个终端窗口。</p><p>在一个正常的 shell 对话中， 关闭窗口将会终止所有在该终端中运行的进程 – 所以刚才的 Nano 编辑对话也就被终止了， 但对于 screen 来说，并不是这样的。打开一个新的终端并输入如下命令：</p><pre><code class="lang-bash">screen -r</code></pre><p>瞧，你刚开打开的 Nano 会话又回来了！</p><p>当刚才你运行 <strong>screen</strong> 时， 它会创建了一个新的独立的 shell 会话， 它不与某个特定的终端窗口绑定在一起，所以可以在后面被分离并重新连接（即 <strong>-r</strong> 选项）。</p><p>当你正使用 SSH 去连接另一台机器并做着某些工作时， 但并不想因为一个脆弱的连接而影响你的进度，这个方法尤其有用。假如你在一个 <strong>screen</strong> 会话中做着某些工作，并且你的连接突然中断了（或者你的笔记本没电了，又或者你的电脑报废了——不是这么悲催吧），你只需重新连接或给电脑充电或重新买一台电脑，接着运行 <strong>screen -r</strong> 来重新连接到远程的电脑，并在刚才掉线的地方接着开始。</p><p>现在，我们都一直在讨论 GNU 的 <strong>screen</strong>，但这个小节的标题提到的是 tmux。 实质上， <strong>tmux</strong> （terminal multiplexer） 就像是 <strong>screen</strong> 的一个进阶版本，带有许多有用的额外功能，所以现在我们开始关注 tmux。 某些发行版本默认包含了 <strong>tmux</strong>； 在其他的发行版本上，通常只需要一个 <strong>apt-get、 yum install</strong> 或 <strong>pacman -S</strong> 命令便可以安装它。</p><p>一旦你安装了它过后，键入 <strong>tmux</strong> 来启动它。接着你将注意到，在终端窗口的底部有一条绿色的信息栏，它非常像传统的窗口管理器中的任务栏： 上面显示着一个运行着的程序的列表、机器的主机名、当前时间和日期。 现在运行一个程序，同样以 Nano 为例， 敲击 Ctrl+B 后接着按 C 键， 这将在 tmux 会话中创建一个新的窗口，你便可以在终端的底部的任务栏中看到如下的信息:</p><pre><code class="lang-bash">0:nano- 1:bash*</code></pre><p>每一个窗口都有一个数字，当前呈现的程序被一个星号所标记。  Ctrl+B 是与 tmux 交互的标准方式， 所以若你敲击这个按键组合并带上一个窗口序号， 那么就会切换到对应的那个窗口。你也可以使用 Ctrl+B 再加上 N 或 P 来分别切换到下一个或上一个窗口 – 或者使用 Ctrl+B 加上 L 来在最近使用的两个窗口之间来进行切换（有点类似于桌面中的经典的 Alt+Tab 组合键的效果）。 若需要知道窗口列表，使用 Ctrl+B 再加上 W。</p><p>目前为止，一切都还好：现在你可以在一个单独的终端窗口中运行多个程序，避免混乱（尤其是当你经常与同一个远程主机保持多个 SSH 连接时）。 当想同时看两个程序又该怎么办呢？</p><p>针对这种情况， 可以使用 tmux 中的窗格。 敲击 Ctrl+B 再加上 % ， 则当前窗口将分为两个部分：一个在左一个在右。你可以使用 Ctrl+B 再加上 O 来在这两个部分之间切换。 这尤其在你想同时看两个东西时非常实用， – 例如一个窗格看指导手册，另一个窗格里用编辑器看一个配置文件。</p><p>有时，你想对一个单独的窗格进行缩放，而这需要一定的技巧。 首先你需要敲击 Ctrl+B 再加上一个 :（冒号），这将使得位于底部的 tmux 栏变为深橙色。 现在，你进入了命令模式，在这里你可以输入命令来操作 tmux。 输入 <strong>resize-pane -R</strong> 来使当前窗格向右移动一个字符的间距， 或使用 <strong>-L</strong> 来向左移动。 对于一个简单的操作，这些命令似乎有些长，但请注意，在 tmux 的命令模式（前面提到的一个分号开始的模式）下，可以使用 Tab 键来补全命令。 另外需要提及的是， <strong>tmux</strong> 同样也有一个命令历史记录，所以若你想重复刚才的缩放操作，可以先敲击 Ctrl+B 再跟上一个分号，并使用向上的箭头来取回刚才输入的命令。</p><p>最后，让我们看一下分离和重新连接 - 即我们刚才介绍的 screen 的特色功能。 在 tmux 中，敲击 Ctrl+B 再加上 D 来从当前的终端窗口中分离当前的 tmux 会话。这使得这个会话的一切工作都在后台中运行、使用 <code>tmux a</code> 可以再重新连接到刚才的会话。但若你同时有多个 tmux 会话在运行时，又该怎么办呢? 我们可以使用下面的命令来列出它们：</p><pre><code class="lang-bash">tmux ls</code></pre><p>这个命令将为每个会话分配一个序号； 假如你想重新连接到会话 1， 可以使用 <code>tmux a -t 1</code> .tmux 是可以高度定制的，你可以自定义按键绑定并更改配色方案， 所以一旦你适应了它的主要功能，请钻研指导手册以了解更多的内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/29/000335nb3m5bfx778bmh3s.jpg" alt="tmux" title="">                </div>                <div class="image-caption">tmux</div>            </figure><p>上图中， tmux 开启了两个窗格： 左边是 Vim 正在编辑一个配置文件，而右边则展示着指导手册页。</p><blockquote><p><strong>Zsh: 另一个 shell</strong></p><p>选择是好的，但标准同样重要。 你要知道几乎每个主流的 Linux 发行版本都默认使用 Bash shell – 尽管还存在其他的 shell。 Bash 为你提供了一个 shell 能够给你提供的几乎任何功能，包括命令历史记录，文件名补全和许多脚本编程的能力。它成熟、可靠并文档丰富 – 但它不是你唯一的选择。</p><p>许多高级用户热衷于 Zsh， 即 Z shell。 这是 Bash 的一个替代品并提供了 Bash 的几乎所有功能，另外还提供了一些额外的功能。 例如， 在 Zsh 中，你输入 <strong>ls</strong> ，并敲击 Tab 键可以得到 <strong>ls</strong> 可用的各种不同选项的一个大致描述。 而不需要再打开 man page 了！</p><p>Zsh 还支持其他强大的自动补全功能： 例如，输入 <strong>cd /u/lo/bi</strong> 再敲击 Tab 键， 则完整的路径名 <strong>/usr/local/bin</strong> 就会出现（这里假设没有其他的路径包含 <strong>u</strong>, <strong>lo</strong> 和 <strong>bi</strong> 等字符）。 或者只输入 <strong>cd</strong> 再跟上 Tab 键，则你将看到着色后的路径名的列表 – 这比 Bash 给出的简单的结果好看得多。</p><p>Zsh 在大多数的主要发行版本上都可以得到了； 安装它后并输入 <strong>zsh</strong> 便可启动它。 要将你的默认 shell 从 Bash 改为 Zsh， 可以使用 <strong>chsh</strong> 命令。 若需了解更多的信息，请访问 <a href="http://www.zsh.org/" target="_blank" rel="noopener">www.zsh.org</a>。</p></blockquote><h3 id="“未来”的终端"><a href="#“未来”的终端" class="headerlink" title="“未来”的终端"></a>“未来”的终端</h3><p>你或许会好奇为什么包含你的命令行提示符的应用被叫做终端。 这需要追溯到 Unix 的早期， 那时人们一般工作在一个多用户的机器上，这个巨大的电脑主机将占据一座建筑中的一个房间， 人们通过某些线路，使用屏幕和键盘来连接到这个主机， 这些终端机通常被称为“哑终端”， 因为它们不能靠自己做任何重要的执行任务 – 它们只展示通过线路从主机传来的信息，并输送回从键盘的敲击中得到的输入信息。</p><p>今天，我们在自己的机器上执行几乎所有的实际操作，所以我们的电脑不是传统意义下的终端，这就是为什么诸如 <strong>XTerm</strong>、 Gnome Terminal、 Konsole 等程序被称为“终端模拟器” 的原因 – 他们提供了同昔日的物理终端一样的功能。事实上，在许多方面它们并没有改变多少。诚然，现在我们有了反锯齿字体，更好的颜色和点击网址的能力，但总的来说，几十年来我们一直以同样的方式在工作。</p><p>所以某些程序员正尝试改变这个状况。 <strong>Terminology</strong> (<a href="http://tinyurl.com/osopjv9" target="_blank" rel="noopener">http://tinyurl.com/osopjv9</a>)， 它来自于超级时髦的 Enlightenment 窗口管理器背后的团队，旨在让终端步入到 21 世纪，例如带有在线媒体显示功能。你可以在一个充满图片的目录里输入 <strong>ls</strong> 命令，便可以看到它们的缩略图，或甚至可以直接在你的终端里播放视频。 这使得一个终端有点类似于一个文件管理器，意味着你可以快速地检查媒体文件的内容而不必用另一个应用来打开它们。</p><p>接着还有 Xiki (<a href="http://www.xiki.org/" target="_blank" rel="noopener">www.xiki.org</a>)，它自身的描述为“命令的革新”。它就像是一个传统的 shell、一个 GUI 和一个 wiki 之间的过渡；你可以在任何地方输入命令，并在后面将它们的输出存储为笔记以作为参考，并可以创建非常强大的自定义命令。用几句话是很能描述它的，所以作者们已经创作了一个视频来展示它的潜力是多么的巨大(请看 <strong>Xiki</strong> 网站的截屏视频部分)。</p><p>并且 Xiki 绝不是那种在几个月之内就消亡的昙花一现的项目，作者们成功地进行了一次 Kickstarter 众筹，在七月底已募集到超过 $84, 000。 是的, 你没有看错 – $84K 来支持一个终端模拟器。这可能是最不寻常的集资活动了，因为某些疯狂的家伙已经决定开始创办它们自己的 Linux 杂志 …… </p><h3 id="下一代终端"><a href="#下一代终端" class="headerlink" title="下一代终端"></a>下一代终端</h3><p>许多命令行和基于文本的程序在功能上与它们的 GUI 程序是相同的，并且常常更加快速和高效。我们的推荐有：<br><strong>Irssi</strong> (IRC 客户端); <strong>Mutt</strong> (mail 客户端); <strong>rTorrent</strong> (BitTorrent); <strong>Ranger</strong> (文件管理器); <strong>htop</strong> (进程监视器)。 若给定在终端的限制下来进行 Web 浏览， Elinks 确实做的很好，并且对于阅读那些以文字为主的网站例如 Wikipedia 来说。它非常实用。</p><blockquote><p><strong>微调配色方案</strong></p><p>在《Linux Voice》杂志社中，我们并不迷恋那些养眼的东西，但当你每天花费几个小时盯着屏幕看东西时，我们确实认识到美学的重要性。我们中的许多人都喜欢调整我们的桌面和窗口管理器来达到完美的效果，调整阴影效果、摆弄不同的配色方案，直到我们 100% 的满意（然后出于习惯, 摆弄更多的东西）。</p><p>但我们倾向于忽视终端窗口，它理应也获得我们的喜爱，并且在 <a href="http://ciembor.github.io/4bit" target="_blank" rel="noopener">http://ciembor.github.io/4bit</a> 你将看到一个极其棒的配色方案设计器，对于所有受欢迎的终端模拟器（<strong>XTerm, Gnome Terminal, Konsole 和 Xfce4 Terminal 等都是支持的应用。</strong>），它可以输出其设定。移动滑块直到你看到配色方案最佳， 然后点击位于该页面右上角的 <code>得到方案</code> 按钮。</p><p>相似的，假如你在一个文本编辑器，如 Vim 或 Emacs 上花费了很多的时间，使用一个精心设计的调色板也是非常值得的。 <strong>Solarized</strong> <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">http://ethanschoonover.com/solarized</a> 是一个卓越的方案，它不仅漂亮，而且因追求最大的可用性而设计，在其背后有着大量的研究和测试。</p></blockquote><hr><p>via: <a href="http://www.linuxvoice.com/linux-101-power-up-your-shell-8/" target="_blank" rel="noopener">http://www.linuxvoice.com/linux-101-power-up-your-shell-8/</a><br>publish: <a href="https://linux.cn/article-5910-1.html" target="_blank" rel="noopener">https://linux.cn/article-5910-1.html</a></p><p>作者：<a href="http://www.linuxvoice.com/author/ben_everard/" target="_blank" rel="noopener">Ben Everard</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我们的关于 shell 基础的指导下, 得到一个更灵活, 功能更强大且多彩的命令行界面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为何要这样做?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得在 shell 提示符下过得更轻松, 高效&lt;/li&gt;
&lt;li&gt;在失去连接后恢复先前的会话&lt;/li&gt;
&lt;li&gt;Stop pushing around that fiddly rodent!&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201507/29/000326wwpxmtpvpnzq9ddz.png&quot; alt=&quot;bash1&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;bash1&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;这是我的命令行提示符的设置。对于这个小的终端窗口来说，这或许有些长。但你可以根据你的喜好来调整它。&lt;/p&gt;
&lt;p&gt;作为一个 Linux 用户, 你可能熟悉 shell (又名为命令行)。 或许你需要时不时的打开终端来完成那些不能在 GUI 下处理的必要任务，抑或是因为你处在一个将窗口铺满桌面的环境中，而 shell 是你与你的 linux 机器交互的主要方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="终端" scheme="https://fsslc.github.io/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="shell" scheme="https://fsslc.github.io/tags/shell/"/>
    
      <category term="tmux" scheme="https://fsslc.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] lolcat ：一个在 Linux 终端中输出彩虹特效的命令行工具</title>
    <link href="https://fsslc.github.io/2015/07/13/Translate-Lolcat-A-Command-Line-Tool-to-Output-Rainbow-Of-Colors-in-Linux-Terminal/"/>
    <id>https://fsslc.github.io/2015/07/13/Translate-Lolcat-A-Command-Line-Tool-to-Output-Rainbow-Of-Colors-in-Linux-Terminal/</id>
    <published>2015-07-13T00:34:55.000Z</published>
    <updated>2020-03-22T03:28:53.381Z</updated>
    
    <content type="html"><![CDATA[<p>那些相信 Linux 命令行是单调无聊且没有任何乐趣的人们，你们错了，这里有一些有关 Linux 的文章, 它们展示着 Linux 是如何的有趣和“淘气” 。</p><ul><li><a href="https://linux.cn/article-2831-1.html" target="_blank" rel="noopener">Linux命令及Linux终端的20个趣事</a></li><li><a href="https://linux.cn/article-4128-1.html" target="_blank" rel="noopener">终端中的乐趣：6个有趣的Linux命令行工具</a></li><li><a href="https://linux.cn/article-4088-1.html" target="_blank" rel="noopener">Linux终端的乐趣之把玩字词计数</a></li></ul><p>在本文中，我将讨论一个名为“lolcat”的小工具 – 它可以在终端中生成彩虹般的颜色。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233817ti7ujuuu3t257es5.png" alt="为终端生成彩虹般颜色的输出的 Lolcat 命令" title="">                </div>                <div class="image-caption">为终端生成彩虹般颜色的输出的 Lolcat 命令</div>            </figure><a id="more"></a><h4 id="何为-lolcat"><a href="#何为-lolcat" class="headerlink" title="何为 lolcat ?"></a>何为 lolcat ?</h4><p>Lolcat 是一个针对 Linux，BSD 和 OSX 平台的工具，它类似于 <a href="http://www.tecmint.com/13-basic-cat-command-examples-in-linux/" target="_blank" rel="noopener">cat 命令</a>，并为 <code>cat</code> 的输出添加彩虹般的色彩。 Lolcat 主要用于在 Linux 终端中为文本添加彩虹般的色彩。</p><h3 id="在-Linux-中安装-Lolcat"><a href="#在-Linux-中安装-Lolcat" class="headerlink" title="在 Linux 中安装 Lolcat"></a>在 Linux 中安装 Lolcat</h3><p><strong>1. Lolcat 工具在许多 Linux 发行版的软件仓库中都可获取到，但可获得的版本都有些陈旧，而你可以通过 git 仓库下载和安装最新版本的 lolcat。</strong></p><p>由于 Lolcat 是一个 ruby gem 程序，所以在你的系统中必须安装有最新版本的 RUBY。</p><pre><code class="lang-bash"># apt-get install ruby      [在基于 APT 的系统中]# yum install ruby          [在基于 Yum 的系统中]# dnf install ruby          [在基于 DNF 的系统中]</code></pre><p>一旦 ruby 软件包安装成功，请确保验证安装的 ruby 的版本。</p><pre><code class="lang-bash"># ruby --versionruby 2.1.5p273 (2014-11-13) [x86_64-linux-gnu]</code></pre><p><strong>2. 接着使用下面的命令来从 lolcat 的 git 仓库中下载和安装最新版本的 lolcat。</strong></p><pre><code class="lang-bash"># wget https://github.com/busyloop/lolcat/archive/master.zip# unzip master.zip# cd lolcat-master/bin# gem install lolcat</code></pre><p>一旦 lolcat 安装后，你可以检查它的版本号。</p><pre><code class="lang-bash"># lolcat --versionlolcat 42.0.99 (c)2011 moe@busyloop.net</code></pre><h3 id="Lolcat-的用法"><a href="#Lolcat-的用法" class="headerlink" title="Lolcat 的用法"></a>Lolcat 的用法</h3><p><strong>3. 在开始使用 lolcat 之前，使用下面的命令来了解它可用的选项和其帮助文档。</strong></p><pre><code class="lang-bash"># lolcat -h</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233818tb261kz6h1k6mz1r.png" alt="Lolcat 的帮助文档" title="">                </div>                <div class="image-caption">Lolcat 的帮助文档</div>            </figure><p><strong>4. 接着, 通过管道连接 lolcat 和其他命令，例如 ps, date 和 cal:</strong></p><pre><code class="lang-bash">  # ps | lolcat  # date | lolcat  # cal | lolcat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233818rjrol0uoro9r9jtm.png" alt="ps 命令的输出" title="">                </div>                <div class="image-caption">ps 命令的输出</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233819vrz5h2l5o5lgz75k.png" alt="Date 的输出" title="">                </div>                <div class="image-caption">Date 的输出</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233819jz0lczc97rc2uwcl.png" alt="Calendar 的输出" title="">                </div>                <div class="image-caption">Calendar 的输出</div>            </figure><p><strong>5. 使用 lolcat 来展示一个脚本文件的代码:</strong></p><pre><code class="lang-bash"># lolcat test.sh</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233821mjgssa2sh8j08xhx.png" alt="用 lolcat 来展示代码" title="">                </div>                <div class="image-caption">用 lolcat 来展示代码</div>            </figure><p><strong>6. 通过管道连接 lolcat 和 figlet 命令。Figlet 是一个展示由常规的屏幕字符组成的巨大字符串的应用。我们可以通过管道将 figlet 的输出连接到 lolcat 中来展示出如下的多彩输出:</strong></p><pre><code class="lang-bash"># echo I ❤ Tecmint | lolcat# figlet I Love Tecmint | lolcat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233822gjm7mvsxyag7qgj3.png" alt="多彩的文字" title="">                </div>                <div class="image-caption">多彩的文字</div>            </figure><p><strong>注</strong>: 注意， ❤ 是一个 unicode 字符。要安装 figlet，你需要像下面那样使用 yum 和 apt 来得到这个软件包:</p><pre><code class="lang-bash"># apt-get figlet# yum install figlet# dnf install figlet</code></pre><p><strong>7. 给文本赋予彩虹颜色的动画:</strong></p><pre><code class="lang-bash">$ echo I ❤ Tecmit | lolcat -a -d 500</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233823jehnp3kpni8z9pzm.gif" alt="动的文本" title="">                </div>                <div class="image-caption">动的文本</div>            </figure><p>这里选项 <code>-a</code> 指的是 Animation(动画)， <code>-d</code> 指的是 duration(持续时间)。在上面的例子中，持续 500 次动画。</p><p><strong>8. 在彩虹般的颜色下阅读 man 页(例如 <code>man ls</code> ):</strong></p><p><em>动的文本</em></p><pre><code class="lang-bash"># man ls | lolcat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233824jka0omoajr6o0mj6.png" alt="多彩地显示文件" title="">                </div>                <div class="image-caption">多彩地显示文件</div>            </figure><p><strong>9. 通过管道连接 lolcat 和 cowsay。cowsay 是一个可配置的正在思考或说话的奶牛，这个程序也支持其他的动物。</strong></p><p>使用下面的命令来安装 cowsay :</p><pre><code class="lang-bash"># apt-get cowsay# yum install cowsay# dnf install cowsay</code></pre><p>安装后，使用下面的命令来显示在 cowsay 中的所有动物：</p><pre><code class="lang-bash"># cowsay -l</code></pre><p><strong>样例输出</strong></p><pre><code class="lang-bash">Cow files in /usr/share/cowsay/cows:apt beavis.zen bong bud-frogs bunny calvin cheese cock cower daemon defaultdragon dragon-and-cow duck elephant elephant-in-snake eyes flaming-sheepghostbusters gnu head-in hellokitty kiss kitty koala kosh luke-koalamech-and-cow meow milk moofasa moose mutilated pony pony-smaller ren sheepskeleton snowman sodomized-sheep stegosaurus stimpy suse three-eyes turkeyturtle tux unipony unipony-smaller vader vader-koala www</code></pre><p>通过管道连接 lolcat 和 cowsay 后的输出，并且使用了‘gnu’形象的 cowfile。</p><pre><code class="lang-bash"># cowsay -f gnu ☛ Tecmint ☚ is the best Linux Resource Available online | lolcat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233824aum0w02gxuk4d6dz.png" alt="使用 Lolcat 的 Cowsay" title="">                </div>                <div class="image-caption">使用 Lolcat 的 Cowsay</div>            </figure><p><strong>注</strong>: 你可以在将 lolcat 和其他任何命令用管道连接起来在终端中得到彩色的输出。</p><p><strong>10. 你可以为最常用的命令创建别名来使得命令的输出呈现出彩虹般的色彩。你可以像下面那样为 ‘ls -l‘ 命令创建别名，这个命令输出一个目录中包含内容的列表。</strong></p><pre><code class="lang-bash"># alias lolls=&quot;ls -l | lolcat&quot;# lolls</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201507/12/233825jl9mg6o8ga5walpm.png" alt="多彩的 Alias 命令" title="">                </div>                <div class="image-caption">多彩的 Alias 命令</div>            </figure><p>你可以像上面建议的那样，为任何命令创建别名。为了使得别名永久生效，你需要添加相关的代码(上面的代码是 ls -l 的别名) 到 <code>~/.bashrc</code> 文件中，并登出后再重新登录来使得更改生效。</p><p>现在就是这些了。我想知道你是否曾经注意过 lolcat 这个工具？你是否喜欢这篇文章？欢迎在下面的评论环节中给出你的建议和反馈。喜欢并分享我们，帮助我们传播。</p><hr><p>via: <a href="http://www.tecmint.com/lolcat-command-to-output-rainbow-of-colors-in-linux-terminal/" target="_blank" rel="noopener">http://www.tecmint.com/lolcat-command-to-output-rainbow-of-colors-in-linux-terminal/</a><br>publish: <a href="https://linux.cn/article-5798-1.html" target="_blank" rel="noopener">https://linux.cn/article-5798-1.html</a></p><p>作者：<a href="http://www.tecmint.com/author/avishek/" target="_blank" rel="noopener">Avishek Kumar</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那些相信 Linux 命令行是单调无聊且没有任何乐趣的人们，你们错了，这里有一些有关 Linux 的文章, 它们展示着 Linux 是如何的有趣和“淘气” 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.cn/article-2831-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux命令及Linux终端的20个趣事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.cn/article-4128-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;终端中的乐趣：6个有趣的Linux命令行工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.cn/article-4088-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux终端的乐趣之把玩字词计数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，我将讨论一个名为“lolcat”的小工具 – 它可以在终端中生成彩虹般的颜色。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201507/12/233817ti7ujuuu3t257es5.png&quot; alt=&quot;为终端生成彩虹般颜色的输出的 Lolcat 命令&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;为终端生成彩虹般颜色的输出的 Lolcat 命令&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Linux" scheme="https://fsslc.github.io/tags/Linux/"/>
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="终端" scheme="https://fsslc.github.io/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="lolcat" scheme="https://fsslc.github.io/tags/lolcat/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] Sleuth Kit：一个用来分析磁盘映像和恢复文件的开源取证工具</title>
    <link href="https://fsslc.github.io/2015/05/30/Translate-Sleuth-Kit-Open-Source-Forensic-Tool-to-Analyze-Disk-Images-and-Recover-Files/"/>
    <id>https://fsslc.github.io/2015/05/30/Translate-Sleuth-Kit-Open-Source-Forensic-Tool-to-Analyze-Disk-Images-and-Recover-Files/</id>
    <published>2015-05-30T14:24:23.000Z</published>
    <updated>2020-03-06T14:30:29.026Z</updated>
    
    <content type="html"><![CDATA[<p>SIFT 是一个由 SANS 公司提供的基于 Ubuntu 的取证发行版。它包含许多取证工具，如 Sleuth kit/Autopsy 。但 Sleuth kit/Autopsy 可以直接在 Ubuntu 或 Fedora 发行版本上直接安装，而不必下载 SIFT 的整个发行版本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222403pq3faq0a68f8o8j0.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>Sleuth Kit/Autopsy 是一个开源的电子取证调查工具，它可以用于从磁盘映像中恢复丢失的文件，以及为了特殊事件进行磁盘映像分析。 Autopsy 工具是 sleuth kit 的一个网页接口，支持 sleuth kit 的所有功能。这个工具在 Windows 和 Linux 平台下都可获取到。</p><h3 id="安装-Sleuth-kit"><a href="#安装-Sleuth-kit" class="headerlink" title="安装 Sleuth kit"></a>安装 Sleuth kit</h3><p>首先，从 <a href="http://www.sleuthkit.org/sleuthkit/download.php" target="_blank" rel="noopener">sleuthkit</a> 的网站下载 Sleuth kit 软件。使用下面的命令在虚拟终端下使用 wget 命令来下载它，下图展示了这个过程。</p><pre><code class="lang-bash"># wget http://cznic.dl.sourceforge.net/project/sleuthkit/sleuthkit/4.1.3/sleuthkit-4.1.3.tar.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222504s0b7grgsoqu8yjes.png" alt="下载 Sleuth Kit" title="">                </div>                <div class="image-caption">下载 Sleuth Kit</div>            </figure><p>使用下面的命令解压 sleuthkit-4.1.3.tar.gz 并进入解压后的目录：</p><pre><code class="lang-bash"># tar -xvzf sleuthkit-4.1.3.tar.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222420yoczb7obpm11ymay.png" alt="解压过程" title="">                </div>                <div class="image-caption">解压过程</div>            </figure><p>在安装 sleuth kit 之前，运行下面的命令来执行所需的检查：</p><pre><code class="lang-bash">#./configure</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222421f0zphnpvhs8y1hep.png" alt="configure" title="">                </div>                <div class="image-caption">configure</div>            </figure><p>然后使用 Make 命令来编译 sleuth kit ：</p><pre><code class="lang-bash">#make</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222422ke7p4up3cc4zexrr.png" alt="make" title="">                </div>                <div class="image-caption">make</div>            </figure><p>最后，使用下面的命令将它安装到 <strong>/usr/local</strong> 目录下：</p><pre><code class="lang-bash">#make install</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222422ttpra550o6yftm5n.png" alt="安装" title="">                </div>                <div class="image-caption">安装</div>            </figure><h3 id="安装-Autopsy-工具"><a href="#安装-Autopsy-工具" class="headerlink" title="安装 Autopsy 工具"></a>安装 Autopsy 工具</h3><p>Sleuth kit 已经安装完毕，现在我们将为它安装 autopsy 界面。从 <a href="http://www.sleuthkit.org/autopsy/download.php" target="_blank" rel="noopener">sleuthkit 的 autopsy 页面</a>下载 Autopsy 软件。使用下面的命令在虚拟终端下使用 wget 命令来下载它，下图展示了这个过程。</p><pre><code class="lang-bash"># wget http://kaz.dl.sourceforge.net/project/autopsy/autopsy/2.24/autopsy-2.24.tar.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222422l59daai59a9ah9ja.png" alt="Autpsy 的下载链接" title="">                </div>                <div class="image-caption">Autpsy 的下载链接</div>            </figure><p>使用下面的命令解压 autopsy-2.24.tar.gz 并进入解压后的目录：</p><pre><code class="lang-bash"># tar -xvzf autopsy-2.24.tar.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222423ijz6c8il5ioi8k78.png" alt="Autopsy 的解压" title="">                </div>                <div class="image-caption">Autopsy 的解压</div>            </figure><p>autopsy 的配置脚本将询问 NSRL (National Software Reference Library) 和 <strong>Evidence_Locker</strong> 文件夹的路径。</p><p>当弹窗问及 NSRL 时，输入 “n”，并在 <strong>/usr/local</strong> 目录下创建名为 Evidence_Locker 的文件夹。Autopsy 将在 Evidence_Locker 文件夹下存储配置文件，审计记录和输出文件。</p><pre><code class="lang-bash">#mkdir /usr/local/Evidence_Locker#cd autopsy-2.24#./configure</code></pre><p>![Autopsy 配置脚本](<a href="https://img.linux.net.cn/data/attachment/album/201505/30/222424k55u5ox5oku3hkzk.png" target="_blank" rel="noopener">https://img.linux.net.cn/data/attachment/album/201505/30/222424k55u5ox5oku3hkzk.png</a></p><p>在安装过程中添加完 Evidence_Locker 的安装路径后， autopsy 在那里存储配置文件并展现如下的信息来运行 autopsy 程序。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222424kqmqbholbb1bqhqc.png" alt="启动 Autopsy" title="">                </div>                <div class="image-caption">启动 Autopsy</div>            </figure><p>在虚拟终端中键入 <strong>./autopsy</strong> 命令来启动 Sleuth kit 工具的图形界面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222425p9w6k67ctzh2td46.png" alt="Autopsy" title="">                </div>                <div class="image-caption">Autopsy</div>            </figure><p>在浏览器中键入下面的地址来访问 autopsy 的界面：</p><pre><code class="lang-bash">http://localhost:9999/autopsy</code></pre><p>下图展现了 autopsy 插件的主页面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222425lru6lruif70zqrlh.png" alt="主页" title="">                </div>                <div class="image-caption">主页</div>            </figure><p>在 autopsy 工具中，点击 <strong>新案例</strong> 按钮来开始进行分析。键入案例名称，此次调查的描述和检查人的姓名，下图有具体的展示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222426g5pwn7cncz04vv82.png" alt="创建新事件" title="">                </div>                <div class="image-caption">创建新事件</div>            </figure><p>在接下来的网页中，将展示在上一个的网页中键入的详细信息。接着点击 <strong>增加主机</strong> 按钮来添加有关要分析的机器的详细信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222426fag7aaasffal0foa.png" alt="增加主机" title="">                </div>                <div class="image-caption">增加主机</div>            </figure><p>在下一个网页中键入主机名，相关的描述和要分析的机器的时区设置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222427q7dydrbmpqp17y4z.png" alt="添加主机的详细信息" title="">                </div>                <div class="image-caption">添加主机的详细信息</div>            </figure><p>添加主机后，点击 <strong>增加映像</strong> 按钮来为取证分析添加映像文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222427b51twt5si1ux5gxi.png" alt="添加映像" title="">                </div>                <div class="image-caption">添加映像</div>            </figure><p>在接下来的网页中点击 <strong>增加映像文件</strong> 按钮。它将打开一个新的网页，来询问映像文件的路径和选择映像的类型以及导入的方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222428d4xyvxxkxy5vs5kn.png" alt="添加映像文件" title="">                </div>                <div class="image-caption">添加映像文件</div>            </figure><p>正如下图中展示的那样，我们已经键入了 Linux 映像文件的路径。在我们这个例子中，映像文件类型是磁盘分区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222428tl0pmeaajojnx6si.png" alt="添加映像分区" title="">                </div>                <div class="image-caption">添加映像分区</div>            </figure><p>点击“下一步”按钮并在下一页中选择 <strong>计算散列值</strong> 的选项，这在下图中有展示。它也将检测所给映像的文件系统类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222428vc8hh8kfhkmlgg8m.png" alt="映像和文件系统详情" title="">                </div>                <div class="image-caption">映像和文件系统详情</div>            </figure><p>下面的图片展示了静态分析之前映像文件的 MD5 散列值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222429gmz3p3k3dr73hb1f.png" alt="散列值" title="">                </div>                <div class="image-caption">散列值</div>            </figure><p>在下一个网页中， autopsy 展现了有关映像文件的如下信息：</p><ul><li>映像的挂载点</li><li>映像的名称</li><li>所给映像的文件系统类型</li></ul><p>点击 <strong>详情</strong> 按钮来获取更多有关所给映像文件的信息。它还提供了从映像文件的卷中导出未分配的片段和字符串的数据信息，这在下图中有展现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222429dbtk7a03mqz0ufa0.png" alt="映像的详细信息" title="">                </div>                <div class="image-caption">映像的详细信息</div>            </figure><p>在下图中那样，点击 <strong>分析</strong> 按钮来开始分析所给映像。它将开启另一个页面，其中包含了映像分析的多个选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222430tyg1g2czv256vd62.png" alt="分析" title="">                </div>                <div class="image-caption">分析</div>            </figure><p>在映像分析过程中，Autopsy 提供了如下的功能：</p><ul><li>文件分析</li><li>关键字搜索</li><li>文件类型</li><li>映像详情</li><li>数据单元</li></ul><p>下图展示的是在给定的 Linux 分区映像上进行文件分析：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222431azn6kp6firwc5qpf.png" alt="映像的分析" title="">                </div>                <div class="image-caption">映像的分析</div>            </figure><p>它将从所给映像中提取所有的文件和文件夹。在下图中也展示了已被删除的文件的提取：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/30/222432zrnndmb1qdrv2dqr.png" alt="已被删除的文件" title="">                </div>                <div class="image-caption">已被删除的文件</div>            </figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>希望这篇文章能够给那些进入磁盘映像静态分析领域的新手提供帮助。Autopsy 是 sleuth kit 的网页界面，提供了在 Windows 和 Linux 磁盘映像中进行诸如字符串提取，恢复被删文件，时间线分析，网络浏览历史，关键字搜索和邮件分析等功能。</p><hr><p>via: <a href="http://linoxide.com/ubuntu-how-to/autopsy-sleuth-kit-installation-ubuntu/" target="_blank" rel="noopener">http://linoxide.com/ubuntu-how-to/autopsy-sleuth-kit-installation-ubuntu/</a><br>public: <a href="https://linux.cn/article-5541-1.html" target="_blank" rel="noopener">https://linux.cn/article-5541-1.html</a></p><p>作者：<a href="http://linoxide.com/author/naveeda/" target="_blank" rel="noopener">nido</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SIFT 是一个由 SANS 公司提供的基于 Ubuntu 的取证发行版。它包含许多取证工具，如 Sleuth kit/Autopsy 。但 Sleuth kit/Autopsy 可以直接在 Ubuntu 或 Fedora 发行版本上直接安装，而不必下载 SIFT 的整个发行版本。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201505/30/222403pq3faq0a68f8o8j0.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="取证工具" scheme="https://fsslc.github.io/tags/%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 如何在 Linux 中产生、加密或解密随机密码 </title>
    <link href="https://fsslc.github.io/2015/05/22/Translate-How-to-Generate-or-Encrypt-or-Decrypt-Random-Passwords-in-Linux/"/>
    <id>https://fsslc.github.io/2015/05/22/Translate-How-to-Generate-or-Encrypt-or-Decrypt-Random-Passwords-in-Linux/</id>
    <published>2015-05-22T05:47:55.000Z</published>
    <updated>2020-03-06T14:42:55.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍几款工具来生成随机密码</p></blockquote><p>我们一直积极地提供有关 Linux 技巧的系列文章，如果你错过了这个系列的最新文章，你或许可以去访问下面的链接。</p><ul><li><a href="https://linux.cn/article-5485-1.html" target="_blank" rel="noopener">Linux 中 5 个有趣的命令行技巧</a> </li></ul><p>在这篇文章中，我们将分享一些有趣 Linux 技巧，内容是有关如何产生随机密码以及加密或解密这些经过加盐或没有加盐处理的密码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225112hk0bbg8yyg11q0wg.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>安全是数字时代中的一个主要话题。在电脑，email，云端，手机，文档和其他的场合中，我们都会使用到密码。众所周知，选择密码的基本原则是 “易记，难猜”。考虑过使用基于机器自动生成的密码吗？相信我，Linux 非常擅长这方面的工作。</p><p><strong>1. 使用命令 <code>pwgen</code> 来生成一个长度为 10 个字符的独特的随机密码。假如你还没有安装 pwgen，请使用 Apt 或 YUM 等包管理器来安装它。</strong></p><pre><code class="lang-bash">$ pwgen 10 1</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225113cj49vaognvzanfov.gif" alt="生成一个独特的随机密码" title="">                </div>                <div class="image-caption">生成一个独特的随机密码</div>            </figure><p>一口气生成若干组长度为 50 个字符的唯一的随机密码!</p><pre><code class="lang-bash">$ pwgen 50</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225114g0xf9gdzgxx5ce9x.gif" alt="生成多组随机密码" title="">                </div>                <div class="image-caption">生成多组随机密码</div>            </figure><p><strong>2. 你还可以使用 <code>makepasswd</code> 来每次生成一个给定长度的独特的随机密码。在你把玩 makepasswd 命令之前，请确保你已经安装了它。如若没有安装它，试试使用 Apt 或 YUM 包管理器来安装 <code>makepasswd</code> 这个软件包。</strong></p><p>生成一个长度为 10 个字符的随机密码。该命令产生的密码的长度默认为 10。</p><pre><code class="lang-bash">$ makepasswd</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225115f297xwyziwq23324.gif" alt="使用 makepasswd 生成独特的密码" title="">                </div>                <div class="image-caption">使用 makepasswd 生成独特的密码</div>            </figure><p>生成一个长度为 50 个字符的随机密码。</p><pre><code class="lang-bash">$ makepasswd  --char 50</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225116y1mv05n6ha7171n3.gif" alt="生成长度为 50 的密码" title="">                </div>                <div class="image-caption">生成长度为 50 的密码</div>            </figure><p>生成 7 个长度为 20 个字符的随机密码。</p><pre><code class="lang-bash">$ makepasswd --char 20 --count 7</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225122qvenx1t8xsozd18s.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>3. 使用带“盐”的 Crypt(注：这里应该指的是一个函数，可以参考<a href="http://man7.org/linux/man-pages/man3/crypt.3.html" target="_blank" rel="noopener">这里</a> ) 来加密一个密码。提供手动或自动添加 “盐”。</strong></p><p>对于那些不清楚 <strong>盐</strong> 的意义的人，这里的 “盐” 指的是一个随机数据，它作为密码生成函数的一个额外的输入， 目的是保护密码免受词典攻击。</p><p>在执行下面的操作前，请确保你已经安装了 <code>mkpasswd</code> 。</p><p>下面的命令将带 “盐” 加密一个密码。“盐” 的值是随机自动生成的。所以每次你运行下面的命令时，都将产生不同的输出，因为它每次接受了随机取值的 “盐”。</p><pre><code class="lang-bash">$ mkpasswd tecmint</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225122r7n2nkei25ivckqn.gif" alt="使用 Crypt 来加密密码" title="">                </div>                <div class="image-caption">使用 Crypt 来加密密码</div>            </figure><p>现在让我们来手动定义 “盐” 的值。每次它将产生相同的结果。请注意你可以输入任何你想输入的值来作为 “盐” 的值。</p><pre><code class="lang-bash">$ mkpasswd tecmint -s tt</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225124fj6r3pfj2dq0p25w.gif" alt="带“盐”加密密码" title="">                </div>                <div class="image-caption">带“盐”加密密码</div>            </figure><p>另外， mkpasswd 还是交互式的，假如你在命令中没有提供密码，它将主动询问你来输入密码。</p><p><strong>4. 使用 aes-256-cbc 加密算法并使用带“盐”的密码(如 “tecmint”) 加密一个字符串(如 “Tecmint-is-a-Linux-Community”)。</strong></p><pre><code class="lang-bash"># echo Tecmint-is-a-Linux-Community | openssl enc -aes-256-cbc -a -salt -pass pass:tecmint</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225125mhz0g6ao99o5v006.gif" alt="在 Linux 中加密一个字符串" title="">                </div>                <div class="image-caption">在 Linux 中加密一个字符串</div>            </figure><p>在上面例子中， <a href="http://linux.cn/article-3948-1.html" target="_blank" rel="noopener">echo 命令</a>的输出通过管道传递给了 openssl 命令，使得该输出通过加密编码方式(enc：Encoding with Cipher ) 所加密，这个过程中使用了 aes-256-cbc 加密算法，并附带了密码 (tecmint) 和 “盐” 。</p><p><strong>5. 使用 openssl 命令的 -aes-256-cbc 解密选项来解密上面的字符串。</strong></p><pre><code class="lang-bash"># echo U2FsdGVkX18Zgoc+dfAdpIK58JbcEYFdJBPMINU91DKPeVVrU2k9oXWsgpvpdO/Z | openssl enc -aes-256-cbc -a -d -salt -pass pass:tecmint</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/21/225126qhhaaupzazagouip.gif" alt="在 Linux 中解密字符串" title="">                </div>                <div class="image-caption">在 Linux 中解密字符串</div>            </figure><p>现在就是这些内容了。</p><p>保持联系，保持连接，敬请关注。不要忘了在下面的评论中提供给我们您有价值的反馈。</p><hr><p>via: <a href="http://www.tecmint.com/generate-encrypt-decrypt-random-passwords-in-linux/" target="_blank" rel="noopener">http://www.tecmint.com/generate-encrypt-decrypt-random-passwords-in-linux/</a><br>publish: <a href="https://linux.cn/article-5486-1.html" target="_blank" rel="noopener">https://linux.cn/article-5486-1.html</a></p><p>作者：<a href="http://www.tecmint.com/author/avishek/" target="_blank" rel="noopener">Avishek Kumar</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍几款工具来生成随机密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们一直积极地提供有关 Linux 技巧的系列文章，如果你错过了这个系列的最新文章，你或许可以去访问下面的链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.cn/article-5485-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 中 5 个有趣的命令行技巧&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇文章中，我们将分享一些有趣 Linux 技巧，内容是有关如何产生随机密码以及加密或解密这些经过加盐或没有加盐处理的密码。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201505/21/225112hk0bbg8yyg11q0wg.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="密码生成" scheme="https://fsslc.github.io/tags/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 一大波你可能不知道的 Linux 网络工具 </title>
    <link href="https://fsslc.github.io/2015/05/12/Translate-Bringing-a-Bunch-of-Best-Known-Linux-Network-Tools/"/>
    <id>https://fsslc.github.io/2015/05/12/Translate-Bringing-a-Bunch-of-Best-Known-Linux-Network-Tools/</id>
    <published>2015-05-12T06:52:49.000Z</published>
    <updated>2020-03-06T14:07:38.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍一大波的网络工具</p></blockquote><p>如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm, tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。</p><p>鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在这篇教程中，我不打算将它们所有包括在内。</p><a id="more"></a><p>上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，以防你想知道究竟是哪个应用在消耗了你的整个网络资源； iftop 可以被用来展示每个套接字连接的带宽使用情况，而像 nload 这类的工具可以帮助你得到有关整个带宽的信息。</p><h3 id="1-nethogs"><a href="#1-nethogs" class="headerlink" title="1) nethogs"></a>1) nethogs</h3><p>nethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。</p><p>一个 Linux 用户可以使用 <strong>nethogs</strong> 来显示每个进程的 TCP 下载和上传速率，可以使用命令 <strong>nethogs eth0</strong> 来监控一个指定的设备，上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。</p><p>对我而言， nethogs 是非常容易使用的，或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。</p><p>例如要想使用混杂模式来嗅探，可以像下面展示的命令那样使用选项 -p：</p><pre><code class="lang-bash">nethogs -p wlan0</code></pre><p>假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。</p><p>（LCTT 译注：关于 nethogs 的更多信息可以参考：<a href="https://linux.cn/article-2808-1.html" target="_blank" rel="noopener">https://linux.cn/article-2808-1.html</a> ）</p><h3 id="2-nload"><a href="#2-nload" class="headerlink" title="2) nload"></a>2) nload</h3><p>nload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145257j2fumafcy1nnh1hm.png" alt="network monitoring tools in linux" title="">                </div>                <div class="image-caption">network monitoring tools in linux</div>            </figure><p>正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，也展示了诸如被传输数据的总量和最小/最大网络速率等信息。</p><p>而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的：</p><pre><code class="lang-bash">nload</code></pre><p>我很确信的是：我们关于如何使用 nload 的详细教程将帮助到新的 Linux 用户，甚至可以帮助那些正寻找关于 nload 信息的老手。</p><p>（LCTT 译注：关于 nload 的更新信息可以参考：<a href="https://linux.cn/article-5114-1.html" target="_blank" rel="noopener">https://linux.cn/article-5114-1.html</a> ）</p><h3 id="3-slurm"><a href="#3-slurm" class="headerlink" title="3) slurm"></a>3) slurm</h3><p>slurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 <strong>c</strong> 用来切换到经典模式， <strong>s</strong> 切换到分图模式， <strong>r</strong> 用来重绘屏幕， <strong>L</strong> 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，<strong>m</strong> 用来在经典分图模式和大图模式之间进行切换， <strong>q</strong> 退出 slurm。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145258ddyrnzs2soddg18r.png" alt="linux network load monitoring tools" title="">                </div>                <div class="image-caption">linux network load monitoring tools</div>            </figure><p>在网络负载监控工具 slurm 中，还有许多其它的按键可用，你可以很容易地使用下面的命令在 man 手册中学习它们。</p><pre><code class="lang-bash">man slurm</code></pre><p>slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，使用 apt-get 安装命令来轻松地下载它：</p><pre><code class="lang-bash">sudo apt-get install slurm</code></pre><p>我们已经在一个<a href="http://linoxide.com/ubuntu-how-to/monitor-network-load-slurm-tool/" target="_blank" rel="noopener">教程</a>中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。</p><h3 id="4-iftop"><a href="#4-iftop" class="headerlink" title="4) iftop"></a>4) iftop</h3><p>当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，<strong>iftop</strong> 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，并且展示出一个表格来显示当前的一对主机间的带宽使用情况。</p><p>通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop：</p><pre><code class="lang-bash">sudo apt-get install iftop</code></pre><p>在你的机器上，可以使用下面的命令通过 yum 来安装 iftop：</p><pre><code class="lang-bash">yum -y install iftop</code></pre><p>（LCTT 译注：关于 nload 的更多信息请参考：<a href="https://linux.cn/article-1843-1.html" target="_blank" rel="noopener">https://linux.cn/article-1843-1.html</a> ）</p><h3 id="5-collectl"><a href="#5-collectl" class="headerlink" title="5) collectl"></a>5) collectl</h3><p>collectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式：</p><ul><li>记录模式</li><li>回放模式</li></ul><p><strong>记录模式</strong> 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。</p><p><strong>回放模式</strong></p><p>根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。</p><p>Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作：</p><pre><code class="lang-bash">sudo apt-get install collectl</code></pre><p>还可以使用下面的命令来安装 collectl， 因为对于这些发行版本（注：这里指的是用 yum 作为包管理器的发行版本），在它们官方的软件仓库中也含有 collectl：</p><pre><code class="lang-bash">yum install collectl</code></pre><p>（LCTT 译注：关于 collectl 的更多信息请参考： <a href="https://linux.cn/article-3154-1.html" target="_blank" rel="noopener">https://linux.cn/article-3154-1.html</a> ）</p><h3 id="6-Netstat"><a href="#6-Netstat" class="headerlink" title="6) Netstat"></a>6) Netstat</h3><p>Netstat 是一个用来监控<strong>传入和传出的网络数据包统计数据</strong>的接口统计数据命令行工具。它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。</p><p>Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netsta 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：</p><pre><code class="lang-bash">sudo apt-get install net-tools</code></pre><p>CentOS, Fedora, RHEL 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它：</p><pre><code class="lang-bash">yum install net-tools</code></pre><p>运行下面的命令使用 Netstat 来轻松地监控网络数据包统计数据：</p><pre><code class="lang-bash">netstat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145259ustjy0xut24ewr4r.png" alt="Netstat" title="">                </div>                <div class="image-caption">Netstat</div>            </figure><p>更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解：</p><pre><code class="lang-bash">man netstat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145259wia38exx1hapzhxx.png" alt="man netstat" title="">                </div>                <div class="image-caption">man netstat</div>            </figure><p>（LCTT 译注：关于 netstat 的更多信息请参考：<a href="https://linux.cn/article-2434-1.html" target="_blank" rel="noopener">https://linux.cn/article-2434-1.html</a>  ）</p><h3 id="7-Netload"><a href="#7-Netload" class="headerlink" title="7) Netload"></a>7) Netload</h3><p>netload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。它是 netdiag 软件的一部分。</p><p>我们可以在 fedora 中使用 yum 来安装 Netload，因为它在 fedora 的默认软件仓库中。但假如你运行的是 CentOS 或 RHEL，则我们需要安装 <a href="http://pkgs.org/centos-7/repoforge-x86_64/netwatch-1.0c-1.el7.rf.x86_64.rpm.html" target="_blank" rel="noopener">rpmforge 软件仓库</a>。</p><pre><code class="lang-bash"># yum install netdiag</code></pre><p>Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 <strong>apt</strong> 包管理器安装 <strong>netdiag</strong>：</p><pre><code class="lang-bash">$ sudo apt-get install netdiag</code></pre><p>为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令：</p><pre><code class="lang-bash">$ netload wlan2</code></pre><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 <code>ip link show</code> 命令。</p><h3 id="8-Nagios"><a href="#8-Nagios" class="headerlink" title="8) Nagios"></a>8) Nagios</h3><p>Nagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。</p><p>Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 <a href="http://localhost/nagios/" target="_blank" rel="noopener">http://localhost/nagios/</a> 或 <a href="http://localhost/nagios3/" target="_blank" rel="noopener">http://localhost/nagios3/</a> 便可以登录到这个 web 界面。假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145300xdap6drbdyybf4w4.png" alt="在 Chromium 浏览器中的 Nagios3" title="">                </div>                <div class="image-caption">在 Chromium 浏览器中的 Nagios3</div>            </figure><p>（LCTT 译注：关于 Nagios 的更多信息请参考：<a href="https://linux.cn/article-2436-1.html" target="_blank" rel="noopener">https://linux.cn/article-2436-1.html</a> ）</p><h3 id="9-EtherApe"><a href="#9-EtherApe" class="headerlink" title="9) EtherApe"></a>9) EtherApe</h3><p>EtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。</p><p>在 CentOS、Fedora、RHEL 等 Linux 发行版本中安装 etherape 是一件容易的事，因为在它们的官方软件仓库中就可以找到 etherape。我们可以像下面展示的命令那样使用 yum 包管理器来安装它：</p><pre><code class="lang-bash">yum install etherape</code></pre><p>我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 <strong>apt</strong> 包管理器来安装 EtherApe ：</p><pre><code class="lang-bash">sudo apt-get install etherape</code></pre><p>在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape：</p><pre><code class="lang-bash">sudo etherape</code></pre><p>然后， <strong>etherape</strong> 的 <strong>图形用户界面</strong> 便会被执行。接着，在菜单上面的 <strong>捕捉</strong> 选项下，我们可以选择 <strong>模式</strong>(IP，链路层，TCP) 和 <strong>接口</strong>。一切设定完毕后，我们需要点击 <strong>开始</strong> 按钮。接着我们便会看到类似下面截图的东西：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145301jybg1tyhobt7opxd.png" alt="EtherApe" title="">                </div>                <div class="image-caption">EtherApe</div>            </figure><h3 id="10-tcpflow"><a href="#10-tcpflow" class="headerlink" title="10) tcpflow"></a>10) tcpflow</h3><p>tcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。</p><p>通过 <strong>apt</strong> 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。</p><pre><code class="lang-bash">$ sudo apt-get install tcpflow</code></pre><p>我们可以使用下面的命令通过 <strong>yum</strong> 包管理器在 Fedora 、CentOS 、RHEL 及它们的衍生发行版本中安装 tcpflow：</p><pre><code class="lang-bash"># yum install tcpflow</code></pre><p>假如在软件仓库中没有找到它或不能通过 yum 包管理器来安装它，则我们需要像下面展示的那样从 <strong><a href="http://pkgs.repoforge.org/tcpflow/" target="_blank" rel="noopener">http://pkgs.repoforge.org/tcpflow/</a></strong> 上手动安装它：</p><p>假如你运行 64 位的 PC：</p><pre><code class="lang-bash"># yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.x86_64.rpm</code></pre><p>假如你运行 32 位的 PC：</p><pre><code class="lang-bash"># yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.i686.rpm</code></pre><p>我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如  x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。</p><pre><code class="lang-bash">$ sudo tcpflow -i eth0 port 8000</code></pre><p>注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称。</p><h3 id="11-IPTraf"><a href="#11-IPTraf" class="headerlink" title="11) IPTraf"></a>11) IPTraf</h3><p><a href="http://iptraf.seul.org/" target="_blank" rel="noopener">IPTraf</a> 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、 TCP/UDP 流量故障以及局域网内设备的包/字节计数。</p><p>在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 <strong>apt</strong> 包管理器轻松地安装 IPTraf：</p><pre><code class="lang-bash">$ sudo apt-get install iptraf</code></pre><p>我们可以使用下面的命令通过 <strong>yum</strong> 包管理器轻松地安装 IPTraf：</p><pre><code class="lang-bash"># yum install iptraf</code></pre><p>我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数：</p><pre><code class="lang-bash">$ sudo iptraf wlan2</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145301iahi0efpp4i1956p.png" alt="IPTraf" title="">                </div>                <div class="image-caption">IPTraf</div>            </figure><p>开始通常的网络接口统计，键入：</p><pre><code class="lang-bash"># iptraf -g</code></pre><p>查看接口 eth0 的详细统计信息，使用：</p><pre><code class="lang-bash"># iptraf -d eth0</code></pre><p>查看接口 eth0 的 TCP 和 UDP 监控信息，使用：</p><pre><code class="lang-bash"># iptraf -z eth0</code></pre><p>查看接口 eth0 的包的大小和数目，使用：</p><pre><code class="lang-bash"># iptraf -z eth0</code></pre><p>注意: 请将上面的 eth0 替换为你的接口名称。你可以通过运行 <code>ip link show</code> 命令来检查你的接口。</p><p>（LCTT 译注：关于 iptraf 的更多详细信息请参考：<a href="https://linux.cn/article-5430-1.html" target="_blank" rel="noopener">https://linux.cn/article-5430-1.html</a>  ）</p><h3 id="12-Speedometer"><a href="#12-Speedometer" class="headerlink" title="12) Speedometer"></a>12) Speedometer</h3><p>Speedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。</p><p>在默认的软件仓库中可以找到 Speedometer ，所以我们可以使用下面的命令通过 <strong>yum</strong> 包管理器轻松地安装 Speedometer：</p><pre><code class="lang-bash"># yum install speedometer</code></pre><p>我们可以使用下面的命令通过 <strong>apt</strong> 包管理器轻松地安装 Speedometer：</p><pre><code class="lang-bash">$ sudo apt-get install speedometer</code></pre><p>Speedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行：</p><pre><code class="lang-bash">$ speedometer -r wlan2 -t wlan2</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145302wwqjz555q57q0qg9.png" alt="Speedometer" title="">                </div>                <div class="image-caption">Speedometer</div>            </figure><p>注：请将上面的 wlan2 替换为你想要使用的网络接口名称。</p><h3 id="13-Netwatch"><a href="#13-Netwatch" class="headerlink" title="13) Netwatch"></a>13) Netwatch</h3><p>Netwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。</p><p>我们可以使用 yum 在 fedora 中安装 Netwatch，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL ， 我们需要安装 <a href="http://pkgs.org/centos-7/repoforge-x86_64/netwatch-1.0c-1.el7.rf.x86_64.rpm.html" target="_blank" rel="noopener">rpmforge 软件仓库</a>。</p><pre><code class="lang-bash"># yum install netwatch</code></pre><p>Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 <strong>apt</strong> 包管理器安装 <strong>netdiag</strong>：</p><pre><code class="lang-bash">$ sudo apt-get install netdiag</code></pre><p>为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code class="lang-bash">$ sudo netwatch -e wlan2 -nt</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145302x33zknj0rz6udj6w.png" alt="Netwatch" title="">                </div>                <div class="image-caption">Netwatch</div>            </figure><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 <code>ip link show</code> 命令。</p><h3 id="14-Trafshow"><a href="#14-Trafshow" class="headerlink" title="14) Trafshow"></a>14) Trafshow</h3><p>Trafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。它可以使用 pcap 类型的过滤器来筛选出特定的连接。</p><p>我们可以使用 yum 在 fedora 中安装 trafshow ，因为它在 fedora 的默认软件仓库中。但若你正运行着 CentOS 或 RHEL ， 我们需要安装 <a href="http://pkgs.org/centos-6/epel-x86_64/trafshow-5.2.3-6.el6.x86_64.rpm.html" target="_blank" rel="noopener">rpmforge 软件仓库</a>。</p><pre><code class="lang-bash"># yum install trafshow</code></pre><p>Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 <strong>apt</strong> 包管理器安装它：</p><pre><code class="lang-bash">$ sudo apt-get install trafshow</code></pre><p>为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令：</p><pre><code class="lang-bash">$ sudo trafshow -i wlan2</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145303mzuagwzxwpwxg6ng.png" alt="Trafshow" title="">                </div>                <div class="image-caption">Trafshow</div>            </figure><p>为了专门监控 tcp 连接，如下面一样添加上 tcp 参数：</p><pre><code class="lang-bash">$ sudo trafshow -i wlan2 tcp</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145304hueslqebrlg5z15n.png" alt="Trafshow tcp" title="">                </div>                <div class="image-caption">Trafshow tcp</div>            </figure><p>注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 <code>ip link show</code> 命令。</p><h3 id="15-Vnstat"><a href="#15-Vnstat" class="headerlink" title="15) Vnstat"></a>15) Vnstat</h3><p>与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。另外，它可以被用来生成一个网络使用历史记录的报告。</p><p>我们需要开启 EPEL 软件仓库，然后运行 <strong>yum</strong> 包管理器来安装 vnstat。</p><pre><code class="lang-bash"># yum install vnstat</code></pre><p>Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 <strong>apt</strong> 包管理器来安装它：</p><pre><code class="lang-bash">$ sudo apt-get install vnstat</code></pre><p>不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。</p><pre><code class="lang-bash">$ vnstat</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145304h9gd54rn8gnl89zn.png" alt="vnstat" title="">                </div>                <div class="image-caption">vnstat</div>            </figure><p>为了实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。</p><pre><code class="lang-bash">$ vnstat -l</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145305dj4ghh43n4lb5elk.png" alt="Vnstat 实时模式" title="">                </div>                <div class="image-caption">Vnstat 实时模式</div>            </figure><p>完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145305hqaj42j76jo8yssu.png" alt="Vnstat 实时结果" title="">                </div>                <div class="image-caption">Vnstat 实时结果</div>            </figure><h3 id="16-tcptrack"><a href="#16-tcptrack" class="headerlink" title="16) tcptrack"></a>16) tcptrack</h3><p><a href="http://linux.die.net/man/1/tcptrack" target="_blank" rel="noopener">tcptrack</a> 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，包括来源/目标地址、带宽使用情况等信息，这与 <strong>top</strong> 命令的输出非常类似 。</p><p>鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 <strong>apt</strong> 包管理器来安装 tcptrack。为此，我们需要在 shell 或虚拟终端中执行下面的命令：</p><pre><code class="lang-bash">$ sudo apt-get install tcptrack</code></pre><p>我们可以通过 yum 在 fedora 中安装它，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL 系统，我们需要安装 <a href="http://pkgs.org/centos-6/repoforge-x86_64/tcptrack-1.4.0-1.el6.rf.x86_64.rpm.html" target="_blank" rel="noopener">rpmforge 软件仓库</a>。为此，我们需要运行下面的命令：</p><pre><code class="lang-bash"># wget http://apt.sw.be/redhat/el6/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm# rpm -Uvh rpmforge-release*rpm# yum install tcptrack</code></pre><p>注：这里我们下载了 rpmforge-release 的当前最新版本，即 0.5.3-1，你总是可以从 rpmforge 软件仓库中下载其最新版本，并请在上面的命令中替换为你下载的版本。</p><p><strong>tcptrack</strong> 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用：</p><pre><code class="lang-bash">sudo tcptrack -i wlan2</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.linoxide.com/wp-content/uploads/2015/02/tcptrack.png" alt="tcptrack" title="">                </div>                <div class="image-caption">tcptrack</div>            </figure><p>假如你想监控特定的端口，则使用：</p><pre><code class="lang-bash"># tcptrack -i wlan2 port 80</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145306bwfbknz2kenblffy.png" alt="tcptrack port 80" title="">                </div>                <div class="image-caption">tcptrack port 80</div>            </figure><p>请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 <code>ip link show</code> 命令。</p><h3 id="17-CBM"><a href="#17-CBM" class="headerlink" title="17) CBM"></a>17) CBM</h3><p>CBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 <a href="http://www.isotton.com/utils/cbm/" target="_blank" rel="noopener">http://www.isotton.com/utils/cbm/</a> 上找到。</p><p>鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 <strong>apt</strong> 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code class="lang-bash">$ sudo apt-get install cbm</code></pre><p>我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm：</p><pre><code class="lang-bash">$ cbm</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201505/12/145307ht3e3tj4j5dp4ozm.png" alt="Color Bandwidth Meter" title="">                </div>                <div class="image-caption">Color Bandwidth Meter</div>            </figure><h3 id="18-bmon"><a href="#18-bmon" class="headerlink" title="18) bmon"></a>18) bmon</h3><p><a href="https://github.com/tgraf/bmon/" target="_blank" rel="noopener">Bmon</a> （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式。</p><p>bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code class="lang-bash">$ sudo apt-get install bmon</code></pre><p>我们可以使用下面的命令来运行 bmon 以监视我们的网络状态：</p><pre><code class="lang-bash">$ bmon</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.linoxide.com/wp-content/uploads/2015/02/bmon.png" alt="bmon" title="">                </div>                <div class="image-caption">bmon</div>            </figure><h3 id="19-tcpdump"><a href="#19-tcpdump" class="headerlink" title="19) tcpdump"></a>19) tcpdump</h3><p><a href="http://www.tcpdump.org/" target="_blank" rel="noopener">TCPDump</a> 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。</p><p>tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令：</p><pre><code class="lang-bash">$ sudo apt -get install tcpdump</code></pre><p>tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它：</p><pre><code class="lang-bash"># yum install tcpdump</code></pre><p>tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，我们有 wlan2 这个网络接口，所以可以像下面这样使用：</p><pre><code class="lang-bash">$ sudo tcpdump -i wlan2</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.linoxide.com/wp-content/uploads/2015/02/tcpdump.png" alt="tcpdump" title="">                </div>                <div class="image-caption">tcpdump</div>            </figure><p>假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子：</p><pre><code class="lang-bash">$ sudo tcpdump -i wlan2 &#39;port 80&#39;</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.linoxide.com/wp-content/uploads/2015/02/tcpdump-port.png" alt="tcpdump port" title="">                </div>                <div class="image-caption">tcpdump port</div>            </figure><h3 id="20-ntopng"><a href="#20-ntopng" class="headerlink" title="20) ntopng"></a>20) ntopng</h3><p>[ntopng][20] 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。</p><p>为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 <strong>编译 ntopng 所需的依赖软件包</strong>。你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们：</p><pre><code class="lang-bash">$ sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall</code></pre><p>现在，我们需要像下面一样针对我们的系统手动编译 ntopng ：</p><pre><code class="lang-bash">$ sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/download$ sudo tar zxfv ntopng-1.1_6932.tgz$ sudo cd ntopng-1.1_6932$ sudo ./configure$ sudo make$ sudo make install</code></pre><p>这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。</p><p>我们已经有了有关 ntopng 的使用方法的<a href="linoxide.com/monitoring-2/ntopng-network-monitoring-tool/">教程</a>，它既可以在命令行也可以在 Web 界面中使用，我们可以前往这些教程来获得有关 ntopng 的知识。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在这篇文章中，我们介绍了一些在 Linux 下的网络负载监控工具，这对于系统管理员甚至是新手来说，都是很有帮助的。在这篇文章中介绍的每一个工具都具有其特点，不同的选项等，但最终它们都可以帮助你来监控你的网络流量。</p><hr><p>via: <a href="http://linoxide.com/monitoring-2/network-monitoring-tools-linux/" target="_blank" rel="noopener">http://linoxide.com/monitoring-2/network-monitoring-tools-linux/</a><br>publish: <a href="https://linux.cn/article-5435-1.html" target="_blank" rel="noopener">https://linux.cn/article-5435-1.html</a></p><p>作者：<a href="http://linoxide.com/author/bobbin/" target="_blank" rel="noopener">Bobbin Zachariah</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍一大波的网络工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm, tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。&lt;/p&gt;
&lt;p&gt;鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在这篇教程中，我不打算将它们所有包括在内。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="网络工具" scheme="https://fsslc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 只有几百个字节大小的国际象棋程序 </title>
    <link href="https://fsslc.github.io/2015/04/25/Translate-Chess-in-a-Few-Bytes/"/>
    <id>https://fsslc.github.io/2015/04/25/Translate-Chess-in-a-Few-Bytes/</id>
    <published>2015-04-25T10:40:45.000Z</published>
    <updated>2020-03-06T14:22:50.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍几款占用非常小的象棋游戏</p></blockquote><p>当我在这里提到了 ZX81 电脑时，我已经暴露了我的年龄。ZX81 是一个由英国开发者（Sincilair 研究所）生产的家庭电脑，它拥有”高达” 1KB 的内存！上面的 1KB 并不是打印错误，这个家庭电脑确实只配置有 1KB 的板载内存。但这个内存大小上的限制并没有阻止爱好者制作种类繁多的软件。事实上，这个机器引发了一代编程奇才的出现，这让他们掌握了让程序在该机上运行起来的技能。这个机器可以通过一个 16 KB 的内存卡来进行升级，这就提供了更多的编程可能。但未经扩展的 1KB 机器仍然激励着编程者们发布卓越的软件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/25/184013j9unqq7xqqzu9zpo.jpg" alt="1K ZX Chess" title="">                </div>                <div class="image-caption">1K ZX Chess</div>            </figure><a id="more"></a><p>我最喜爱的 ZX81 游戏有： 模拟飞行（Flight Simulation）, 3D 版怪物迷宫（3D Monster Maze）, 小蜜蜂（Galaxians）, 以及最重要的 1K ZX Chess。 只有最后一个程序是为未扩展版的 ZX81 电脑设计的。事实上，David Horne 开发的 1K ZX Chess 只使用了仅仅 672 字节的 RAM（LCTT 译注：如果读者有兴趣，可以看看<a href="http://users.ox.ac.uk/~uzdm0006/scans/1kchess/" target="_blank" rel="noopener">这里</a>对该程序的代码及解释）。尽管如此，该游戏尽力去实现大多数的国际象棋规则，并提供了一个计算机虚拟对手。虽然一些重要的规则被忽略了（如：王车易位，兵的升变，和吃过路兵）<br>（LCTT 译注：参考了<a href="http://zh.wikibooks.org/zh/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B/%E8%A7%84%E5%88%99" target="_blank" rel="noopener">这里</a>和<a href="http://en.wikipedia.org/wiki/Rules_of_chess" target="_blank" rel="noopener">这里</a>），但能够和人工智能相对抗，这仍然令人惊讶。这个游戏占据了我逝去的青春里的相当一部分。</p><p>1K ZX Chess 保持了在所有计算机上国际象棋的最小实现的地位长达 33 年之久，直到今年由 BootChess 打破了该记录，紧接着由 Toledo AtomChess 打破。这三个程序都没有实现所有的国际象棋规则，所以为了完整性，我介绍了我最喜爱的那些实现了所有国际象棋规则的极小的国际象棋。</p><p>Linux 有着一系列极其强大的国际象棋引擎，如 Stockfish, Critter, Togo II, Crafty, GNU Chess 和 Komodo 。 在这篇文章精选的国际象棋程序虽敌不过这些好的国际象棋程序，但它们展示了使用微不足道的代码库究竟可以实现多少东西。</p><hr><h3 id="Toledo-Atomchess"><a href="#Toledo-Atomchess" class="headerlink" title="Toledo Atomchess"></a>Toledo Atomchess</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/25/184015lrqghr0rz0h1th33.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你可能已经看到了大量有关 BootChess 新闻报道，这个只用 487 字节写就的国际象棋程序，一举打破了先前最小的国际象棋程序 1K ZX Chess 的记录。所以，Óscar Toledo Gutiérrez 挽起袖子自己编写了一个更加紧凑的国际象棋游戏。Toledo Atomchess 是仅有 481 字节的 x86 汇编代码，都能放到引导扇区里。 在难以置信的代码大小下，这个引擎实现了一个可玩的国际象棋游戏。</p><p>特点包括:</p><ul><li>基本的棋子移动</li><li>用 ASCII 文本表现的棋盘</li><li>以代数形式来输入移动(注：如 D2D4)</li><li>3 层的搜索深度</li></ul><p>显然，为了将这个国际象棋程序压缩到 481 字节中，作者必须做出某些牺牲，这些局限包括：</p><ul><li>没有兵的升变</li><li>没有王车易位</li><li>没有吃过路兵</li><li>没有移动确认</li></ul><p>该作者也使用 C，JavaScript 和 Java 来写这个国际象棋程序，每种实现都非常小。</p><ul><li>网站: <a href="http://nanochess.org/chess6.html" target="_blank" rel="noopener">nanochess.org/chess6.html</a></li><li>开发者: Óscar Toledo Gutiérrez</li><li>协议: 非商业用途可免费使用</li><li>版本号: -</li></ul><hr><h3 id="BootChess"><a href="#BootChess" class="headerlink" title="BootChess"></a>BootChess</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/25/184016c922qucqqjr7cbrj.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>BootChess 是一个国际象棋的极其小巧的计算机实现。这个程序被塞进到仅仅 487 字节里，并可运行在 Windows, Mac OS X 和 Linux 等操作系统。BootChess 的棋盘和棋子单独用文本表示，其中 P 代表兵， Q 用来代表王后，以及“点”代表空白格子。</p><p>特点包括:</p><ul><li>象棋棋盘和用户输入的形象的文本表示</li><li>引导扇区大小（512 字节）的可玩的象棋游戏</li><li>只需 x86 bios 硬件引导程序（没有软件依赖）</li><li>所有主要的正规移动包括双兵开局</li><li>兵升变为王后(与 1k ZX Chess 相反)</li><li>名为 taxiMax &gt; minMax half-ply 的 CPU 人工智能</li><li>硬编码的西班牙白子开局</li></ul><p>同样，它也存在一些重要的限制。这些遗漏的功能包括：</p><ul><li>兵的低升变（升变为非王后的棋子）</li><li>吃过路兵</li><li>没有王车易位</li><li>3 次位置重复和局规则（注：下一步之前，同样的移动出现了两次；可以参考<a href="http://www.netplaces.com/chess-basics/ending-the-game/three-position-repetition.htm" target="_blank" rel="noopener">这里</a>）</li><li>50 步移动和局规则（注：在连续的50个回合内，双方既没有棋子被吃掉，也没有兵被移动过，则和局；可以参考<a href="http://www.chessvariants.org/d.chess/chess.html" target="_blank" rel="noopener">这里</a>）</li><li>没有开放式和封闭式布局</li><li><p>一个或多个 minMAX/negaMax 全层人工智能</p></li><li><p>网站: <a href="http://www.pouet.net/prod.php?which=64962" target="_blank" rel="noopener">www.pouet.net/prod.php?which=64962</a></p></li><li>开发者: Olivier “Baudsurfer/RSi” Poudade</li><li>协议: WTFPL v2</li><li>版本号: .02</li></ul><hr><h3 id="Micro-Max"><a href="#Micro-Max" class="headerlink" title="Micro-Max"></a>Micro-Max</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/25/184017vb55on5x5nbbqjbb.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Micro-Max 是一个用 133 行 C 语言写就的象棋源程序。</p><p>作者实现了一个 hash 变换表，该引擎检查输入移动的合法性，以及支持 FIDE（注： World Chess Federation 缩写，参见其<a href="https://www.fide.com/" target="_blank" rel="noopener">官网</a>） 的全部规则，除了低升变。</p><p>特点包括:</p><ul><li>递归的 negamax 搜索</li><li>反夺的静态搜索</li><li>反夺规则的扩展</li><li>迭代深化</li><li>最佳移动优先的 <code>排序</code> </li><li>存储分数和最佳移动的 Hash 表</li><li>完整的 FIDE 规则（除了低位升变）和移动合法性检查</li></ul><p>还有一个 1433个字符的较大版本，但允许你使用完整的 FIDE 规则的低升变。</p><ul><li>网站: <a href="http://home.hccnet.nl/h.g.muller/max-src2.html" target="_blank" rel="noopener">home.hccnet.nl/h.g.muller/max-src2.html</a></li><li>开发者: Harm Geert Muller</li><li>协议: The MIT License</li><li>版本号: 3.2</li></ul><hr><p>via: <a href="http://www.linuxlinks.com/article/20150222033906262/ChessBytes.html" target="_blank" rel="noopener">http://www.linuxlinks.com/article/20150222033906262/ChessBytes.html</a><br>public: <a href="https://linux.cn/article-5329-1.html" target="_blank" rel="noopener">https://linux.cn/article-5329-1.html</a></p><p>作者：Frazer Kline<br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍几款占用非常小的象棋游戏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我在这里提到了 ZX81 电脑时，我已经暴露了我的年龄。ZX81 是一个由英国开发者（Sincilair 研究所）生产的家庭电脑，它拥有”高达” 1KB 的内存！上面的 1KB 并不是打印错误，这个家庭电脑确实只配置有 1KB 的板载内存。但这个内存大小上的限制并没有阻止爱好者制作种类繁多的软件。事实上，这个机器引发了一代编程奇才的出现，这让他们掌握了让程序在该机上运行起来的技能。这个机器可以通过一个 16 KB 的内存卡来进行升级，这就提供了更多的编程可能。但未经扩展的 1KB 机器仍然激励着编程者们发布卓越的软件。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201504/25/184013j9unqq7xqqzu9zpo.jpg&quot; alt=&quot;1K ZX Chess&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;1K ZX Chess&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="游戏" scheme="https://fsslc.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 想找点激烈的游戏？那就试试这 13 款 Roguelike 游戏吧！</title>
    <link href="https://fsslc.github.io/2015/04/06/Translate-Intense-Gameplay-Try-these-13-Roguelike-games/"/>
    <id>https://fsslc.github.io/2015/04/06/Translate-Intense-Gameplay-Try-these-13-Roguelike-games/</id>
    <published>2015-04-06T00:25:53.000Z</published>
    <updated>2020-03-02T06:05:59.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍 13 款 Roguelike 类游戏</p></blockquote><p>Roguelike 是角色扮演游戏的一个子类。从字面上看，它的意思是 “像 Rogue 的游戏”。Rogue 是一个关于地下城冒险的视频游戏，于 1980 年第一次发行，以极其上瘾而著称。这个游戏的目标是取得深藏于第 26 层的 “Amulet of Yendor”，再返回到顶层逃出生天。</p><p>Roguelike 的准确定义并不存在，但这类游戏通常具有下面的特点：</p><ul><li>奇幻的叙事背景；</li><li>用程序产生关卡。游戏中的绝大多数场景在开始新的游戏时由游戏自动创建。这样做是为了鼓励玩家不断重玩; </li><li>回合制的地下城探险和战斗；</li><li>随机生成的基于贴片的图形环境；</li><li>随机发生战斗；</li><li>永久死亡 ：在游戏中，死亡真的存在，一旦你的角色死了，那就真的结束了；</li><li>高难度。</li></ul><a id="more"></a><p>这篇文章精心挑选了一些可运行在 Linux 平台下的 roguelike 游戏。假如你喜欢激烈、易上瘾的游戏，可以尝试这 13 款游戏。不要因它们原始的画质而退缩，一旦你沉浸其中，你将很快忘记画面的简陋。所有的这些都可以免费下载，并且几乎所有的游戏都是在开源协议下发行的。</p><hr><h3 id="Dungeon-Crawl-Stone-Soup"><a href="#Dungeon-Crawl-Stone-Soup" class="headerlink" title="Dungeon Crawl Stone Soup"></a>Dungeon Crawl Stone Soup</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183124a6h6arh02l26yxpy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dungeon Crawl Stone Soup 是一个开源的，单用户角色扮演类的 roguelike 游戏，玩家要在遍布危险而充满敌意的怪兽的地下城中进行探险和寻找宝藏，并在任务中拯救传说中的神秘 Zot 宝珠。</p><p>Dungeon Crawl Stone Soup 是 Linley 开发的 Dungeon Crawl 游戏的延续。它是公开开发的，并邀请 Crawl 社区的人员来参与其中。</p><p>Dungeon Crawl 有着超棒且深层次的战术游戏环节，创新的魔法和信仰系统，以及数量宏大的和你战斗的怪兽。Crawl 也是最难以攻陷的 roguelike 游戏之一。当你最终在游戏中通关，将胜利宣言张贴在 rec.games.roguelike.misc 时，你才会知道这有多么令人骄傲！</p><p>特点包括:</p><ul><li>丰富多彩的、富含深层次战术的 roguelike 游戏；</li><li>手绘地图；</li><li>无数的金库；</li><li>漂亮的界面；</li><li>创新的魔法和信仰系统；</li><li><p>各种神灵，角色，物品和聪明的怪兽；</p></li><li><p>网站: <a href="http://crawl.develz.org/" target="_blank" rel="noopener">crawl.develz.org</a></p></li><li>开发者: Stone Soup 开发小组</li><li>协议: Crawl General Public License</li><li>版本号: 0.15.2</li></ul><hr><h3 id="Dwarf-Fortress"><a href="#Dwarf-Fortress" class="headerlink" title="Dwarf Fortress"></a>Dwarf Fortress</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183127v0p0456e0nmnr0lp.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dwarf Fortress 是一个单人魔幻游戏，与 NetHack 类似。你可以在一个随机生成的持久的世界中，控制一个矮人哨兵或一个冒险者。</p><p>这个游戏的特色有：三种游戏模式(矮人要塞，冒险者，传说模式)，一个独特的随机生成的世界(由地形，野生生物和传奇生物等组成)， 阴森的战斗机制以及各种邪恶鱼群。</p><p>特点包括：</p><ul><li>在这个世界里，你想玩多久都可以。可以经历许多次游戏，记录历史事件，对更改进行跟踪等；</li><li>当你扮演的矮人在山群中寻找宝藏时，你可以对他们下达命令<ul><li>用各种材料来手工制作珍宝、物品，并可以用贵重金属、宝石等来改进它们；</li><li>通过各种手段保护你自己，防御来自敌对文明的袭击；</li><li>支持贵族，他们会管理你的民众</li><li>让你的矮人高兴起来，了解他们工作和休闲时的想法；</li><li>不同的 Z 坐标可以使你在多个层级上建造你的堡垒。建立塔台或征服地下深处；</li><li>建立水闸来灌溉作物或用水淹没你的对手；</li></ul></li><li>扮演一个探险者并进行探索，为荣誉而战或复仇<ul><li>与以前的游戏中的对手相遇；</li><li>在你经过的旅途中营救小城里的人们；</li><li>没有繁琐的情节，只需要探索；</li><li>无缝连接的漫游游戏世界-总共达到 197376 x 197376 平方 -可以在区域地图上更快速地穿行；</li><li>接受小镇或文明社会的领导所委托的任务；</li><li>可以找到你以前的角色，以一个新的角色带上他们来一场新的冒险，或者直接重新激活并使用他们；</li><li>通过 Z 轴使得你可以在各个地下城的不同层级间和结构间平滑的上下移动来和对手战斗；</li></ul></li><li>战斗模式是通过技巧、身体部位、搏斗、在不同区域间蓄势和躲避，体验流血、疼痛，恶心及其他感受；</li><li>一个动态的天气模型跟踪风，湿度及空气流动，以创造冷暖气流锋面、风、暴风雨雪；</li><li>超过 200 种岩石和矿物类型被引入到了游戏世界，它们被放置在合适的地理环境中；</li><li>通过可更改的文本文件来添加生物，武器，植物，金属和其他对象；</li><li><p>以 16 色(包括黑色)渲染的扩展 ASCII 字符集，以及 8 种背景颜色(包括黑色); </p></li><li><p>网站: <a href="http://www.bay12games.com/dwarves/index.html" target="_blank" rel="noopener">www.bay12games.com/dwarves/</a></p></li><li>开发者: Tarn Adams</li><li>协议: 免费软件</li><li>版本号: 0.40.19</li></ul><hr><h3 id="Ancient-Domains-of-Mystery"><a href="#Ancient-Domains-of-Mystery" class="headerlink" title="Ancient Domains of Mystery"></a>Ancient Domains of Mystery</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183129gnog9not3lggaso3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ancient Domains of Mystery (ADOM) 是一个 rogue-like 游戏，从 1994 年至今一直在不断开发。</p><p>它是一个包含复杂地下城的单用户游戏。你控制一个用种族、类别、属性、技巧和装备等描述的虚构角色。这个虚构角色正尝试着达到一个特定的目标（参考下面的介绍）并在一个困难的任务中取胜。为了完成任务，你必须在以前没有发现的隧道和地下城中探险，和丑陋的怪兽战斗，解开一系列遗忘的秘密，并找到宝藏。</p><p>在游戏期间，你在每次游戏时随机生成的各层地下城中探索。你也可能遇到某个特定的关卡，其中有着特定的挑战或者围绕某个特定主题而生成。</p><p>特点包括:</p><ul><li>拥有上百个地点的巨大游戏世界，例如城堡、随机生成的地下城、主题寺庙、墓地、古代遗迹、塔台和其他名胜；</li><li>各种各样的种族（矮人、drakeling、雾精灵、hurthling、兽人、巨魔、ratling 等等）（LCTT注：种族信息可以参考<a href="http://ancardia.wikia.com/wiki/Race" target="_blank" rel="noopener">这里</a> 和丰富的职业（战士、 元素法师、 刺客、 混沌骑士，决斗士等等）带来无限的游戏乐趣；</li><li>上百个怪兽和物品，其中的许多带有随机的增强特性；</li><li>迫使你在对力量的欲望和对诅咒的恐惧之间进行权衡的腐败体系；</li><li>法术、祈祷、思想技艺、炼金术、手工艺和更多；</li><li>多样的任务和分支故事主线；</li><li><p>许多完全不同的结局，可能改变现实本身。</p></li><li><p>网站: <a href="http://www.adom.de/" target="_blank" rel="noopener">www.adom.de</a></p></li><li>开发者: Thomas Biskup</li><li>协议: Postcardware</li><li>版本号: 1.20 Prelease 20</li></ul><hr><h3 id="Tales-of-Maj’Eyal-ToME"><a href="#Tales-of-Maj’Eyal-ToME" class="headerlink" title="Tales of Maj’Eyal (ToME)"></a>Tales of Maj’Eyal (ToME)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183205sa8m8jxbugiuubou.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Tales of Maj’Eyal (ToME) (注：中文译名为 马基埃亚尔的传说) 是一个免费、开源的 roguelike 角色扮演游戏，包含特色的战术回合制战役和先进角色构建。它作为运行在 T-Engine 4.0 中的一个模块而被创造。</p><p>现在处于王权世纪(Age of Ascendancy)，在长达一万年的冲突痛苦和混乱之后，我们所知的世界终于进入了一个相对和平的时期。 “魔法大爆裂（Spellblaze）” 留下的影响已经大为减缓, 大地的伤痕也慢慢地开始愈合。在薪火世纪（Age of Pyre）之后，各个文明也纷纷开始重建家园。(注：翻译来源于 <a href="http://www.qiyun.org/zhuanti/majiaiyaerdechuanshuo.htm" target="_blank" rel="noopener">这里</a>)</p><p>特点包括:</p><ul><li>适合于那些没有 rogueline 体验的玩家；</li><li>同时支持图形界面和 ASCII 模式；</li><li>某些角色拥有多达 40 种的能力；</li><li>天赋系统；</li><li>战役引擎；</li><li>在线的持久状态/成就追踪；</li><li>IRC 聊天客户端；</li><li>可扩展，可修改；</li><li>充满激情的音乐；</li><li><p>可解锁新的种族，类别，起始点，游戏模式和特点等；</p></li><li><p>网站: <a href="http://te4.org/" target="_blank" rel="noopener">te4.org</a></p></li><li>开发者: ToME 开发团队</li><li>协议: GNU GPL v3.0</li><li>版本号: 1.2.5</li></ul><hr><h3 id="Cataclysm-Dark-Days-Ahead"><a href="#Cataclysm-Dark-Days-Ahead" class="headerlink" title="Cataclysm Dark Days Ahead"></a>Cataclysm Dark Days Ahead</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183208illnjjazel3j3axn.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Cataclysm 是一个开源的 “后末世” roguelike 游戏，背景设定在由怪兽和僵尸带来的毁灭性的瘟疫后虚构的新英格兰(New England) 乡村。它是 Whale 开发的原有 Cataclysm 的继续，拓展了更多新的生物，建筑，游戏机制和其他特点。</p><p>尽管有些人描述它为一个 “僵尸游戏”，但 Cataclysm 远比一个“僵尸游戏”包含更多内容。玩家要在一个由程序生成的严酷、持久的世界中艰难生存下去。在一个死寂的文明世界中搜寻剩下的食物和装备，或者假如你足够幸运，搞到一辆装满汽油的汽车逃离 Dodge —这个如地狱一般的地方。从僵尸到巨型昆虫或机器人杀手以及更加奇怪和致命的东西，你要通过战斗来击败它们或逃离，以及和那些想要抢夺你的东西的那些同你一样的人战斗。</p><p>在许多方面上， Cataclysm 与大多数的 roguelike 游戏不同。它被设定在一个没有边界的三维世界里，而不是设定在一个垂直、线性的地下城中。这意味着相比于大多数的 roguel 游戏，探险将占一个更大的比重，而且这个游戏将具有更大的自由度。由于地图是如此的巨大，在每次游戏之间，它可以完全保持原样。假如你死了，并以一个新的角色开始，你的新游戏将会设定在同你最近呆过的游戏世界相同的世界里。同许多 roguelike 游戏一样，你可以获得先前角色的战利品；而与大多数 roguelike 不同的是，你也可以重新踏上先前角色的轨迹，并且对世界做出的任何戏剧性改变将会维持到你的下一次游戏。</p><p>特点包括:</p><ul><li>详细的角色创建，提供了数量众多的特性来选择；</li><li>防御模式，这是一个有着快节奏作战的休息模式；</li><li>Bionics；类似于在许多其他游戏里的魔法系统；</li><li>基因突变, 有好的和坏的变化；</li><li>无界的，完全随机的世界地图，可以在角色交替时保持不变；</li><li>创造物品<ul><li>新的制作方法可能需要通过练习或从书本中获得来磨练你的知识；</li></ul></li><li>逼真的火、烟和其他动态的地图特效；</li><li>昼/夜循环，需要睡觉。假如你必须的话，可以使用咖啡因来保持更长时间的清醒，但这不健康；</li><li>超过 300 种物品类型，包括众多的现实世界的枪支，药品和工具；<ul><li>许多药品是上瘾的，并需要持续使用来避免负面效果；</li></ul></li><li>通过修补门、窗、建造陷阱和巩固你的家的基石来防止一个僵尸的突然造访；</li><li>能够构建你自己的木屋，包括墙和屋顶；</li><li>可以驾驶在“后末世”发现的汽车兜风；<ul><li>这个可以根据你的需求来修改，或甚至你可以自己制造一辆；</li></ul></li><li>温度系统，太冷或太热都非常危险；</li><li>初步支持贴片界面；</li><li><p>根据选项生成世界，以及各种编辑方式；</p></li><li><p>网站: <a href="http://en.cataclysmdda.com/" target="_blank" rel="noopener">en.cataclysmdda.com</a></p></li><li>作者: Kevin Granade 及其他</li><li>协议: Creative Commons Attribution-ShareAlike 3.0 Unported License</li><li>版本号: 0. B</li></ul><hr><h3 id="Goblin-Hack"><a href="#Goblin-Hack" class="headerlink" title="Goblin Hack"></a>Goblin Hack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183221dhwiojw8fe7900wo.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Goblin Hack 是一个开源 roguelike 游戏，基于 OpenGL 的平滑滚动的ASCII 图形界面。这个游戏受 NetHack 外观的启发，但更加快速且使用更少的按键。</p><p>Goblin Hack 有一个简洁的界面，在今天这个过度强调渲染的游戏世界中，似乎它对所有年龄段的玩家都有吸引力，并启发了这些玩家的想象力。</p><p>在被投进一个随机的正在生成的地下城之前，玩家可以从几个角色类别中选择一个角色。</p><p>特点包括:</p><ul><li>令人印象深刻的界面(相比于许多其他的 roguelike 游戏)；</li><li>简洁的界面；</li><li>在被投进一个随机的正在生成的第一层地下城之前，玩家可以从几个角色类别中选择一个角色；</li><li><p>手动保存游戏；</p></li><li><p>网站: <a href="http://goblinhack.sourceforge.net/" target="_blank" rel="noopener">goblinhack.sourceforge.net</a>, <a href="https://github.com/goblinhack/goblinhack" target="_blank" rel="noopener">github.com/goblinhack/goblinhack</a></p></li><li>作者: Neil McGill</li><li>协议: GNU GPL v2</li><li>版本号: 1.19</li></ul><hr><h3 id="SLASH’EM"><a href="#SLASH’EM" class="headerlink" title="SLASH’EM"></a>SLASH’EM</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183224ckiy2wsxoj705x0e.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Super Lotsa Added Stuff Hack - Extended Magic (SLASH’EM) 是一个角色扮演游戏，在其中你控制一个单独的角色。SLASH’EM 是 NetHack 的一个变种。它拥有一个和 Rogue、ADOM、Anghand 及 NetHack 相似的界面和游戏玩法。你通过键盘来控制角色的动作，以一个俯视的视角来查看这个世界。</p><p>背景： Amulet of Yendor 已被偷走，不仅如此，偷走 amulet 的 Wizard of Yendor（坏蛋）似乎深藏于 Dungeons of Doom（危险的地方）。</p><p>特点包括:</p><ul><li>提供额外的特色、怪兽和项目；</li><li>新颖的特点包括僧人职业和类似推箱子的关卡；</li><li><p>主地下城比在 NetHack 中的要大很多；</p></li><li><p>网站: <a href="http://www.slashem.org/" target="_blank" rel="noopener">www.slashem.org</a></p></li><li>开发者:  Slash’EM 开发团队</li><li>协议: MIT License, NetHack General Public License</li><li>版本号: 0.0.7E7F3</li></ul><hr><h3 id="NetHack"><a href="#NetHack" class="headerlink" title="NetHack"></a>NetHack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183227gbbvxbzzajneo07k.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>NetHack 是一个极简，但又非常吸引人的具有地下城与龙风格的冒险游戏。“net”元素指的是它的发展已经根据网络进行了调整，“hack”元素指的是角色扮演游戏的一种类型，以乱砍、猛砍著称，着眼于战斗。</p><p>在 NetHack 中，你扮演凶猛的战士、巫师或许多其他职业中的一种，一路战斗着，为你的神灵获取 Amulet of Yendor（可以说这是一个倒退!）。在这个过程中，你可能会遇到一个或两个 quantum mechanic（LCTT 译注：从<a href="http://nethack.wikia.com/wiki/Quantum_mechanic" target="_blank" rel="noopener">这里</a>得知，这指的是一种怪兽），或者可能遇到一个小型的太空舰队，抑或是 —— 假如你<em>足够</em>幸运会遇到 —— Ravenous Bugblatter Beast of Traal。（LCTT 译注：我参考了<a href="http://nethack.wikia.com/wiki/Douglas_Adams" target="_blank" rel="noopener">这里</a>）。</p><p>特点包括:</p><ul><li>45-50 个关卡, 其中的大多数随机生成；</li><li>各种各样的物品：武器、盔甲、卷轴、药水、戒指、宝石和各种各样的工具，如钥匙和灯；</li><li>祝福和诅咒；</li><li>永久死亡: 若没有对当前的保存文件进行备份，失效的角色就找不回来了；</li><li><p>界面：</p><ul><li>文本模式；</li><li>图形化界面， 使用 X、Qt 工具集或 GNOME 库；</li></ul></li><li><p>网站: <a href="http://www.nethack.org/" target="_blank" rel="noopener">www.nethack.org</a></p></li><li>开发者: NetHack 开发团队</li><li>协议: NetHack 通用公共许可证</li><li>版本号: 3.4.3</li></ul><hr><h3 id="Ascii-Sector"><a href="#Ascii-Sector" class="headerlink" title="Ascii Sector"></a>Ascii Sector</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183228gztj827ygcvg8gq7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ascii Sector 是一个免费的太空战斗/探险/交易游戏，它基于经典的电脑游戏 <code>Wing Commander: Privateer</code> ，后者由 Origine Systems 公司于 1993 年发布。</p><p>在 Ascii Sector 中，刚开始你将驾驶一艘简易的飞船，然后可以通过接受任务或者贩卖物品来挣得足够多的钱以升级你的飞船或重新再买一艘。不管是在太空中，还是在地面上，抑或是在飞船上，你可以专注于致命的战斗；并且通过使用 Ascii Sector 的脚本语言，你还可以为游戏创造自己的任务或享受其他玩家创造的任务。</p><p>特点包括:</p><ul><li>使用 ANSI 字符集生成图形界面；</li><li>真正的深入到游戏中；</li><li>提供各种基地，任务，商品和飞船；</li><li>飞船型号包括: Broadsword, Centurion, Demon, Dralthi, Drayman, Galaxy, Gladius, Gothri, Kamekh, Nexus, Orion, Paradign, Stileto, Talon, Tarsus 和 Ulysses；</li><li>四个象限: Alizarin, Crimson, Mauve, 和 Viridian；</li><li>可下载的任务；</li><li>任务可用脚本编辑；</li><li>Ascii Sector 任务语言，在 Ascii Sector 宇宙中创造你自己的故事；</li><li>可以袭击或抢劫星球上的 NPC（非玩家控制角色）；</li><li>可以到处移动的持久性舰队、可以改变系统的控制、引来敌人的舰队、回基地修复或重建；</li><li>可以登录系统受损的飞船；</li><li><p>可下载高质量的音乐文件；</p></li><li><p>网站: <a href="http://www.asciisector.net/" target="_blank" rel="noopener">www.asciisector.net</a></p></li><li>开发者: Christian Knudsen</li><li>协议: 免费软件</li><li>版本号: 0.7.1.4</li></ul><hr><h3 id="Angband"><a href="#Angband" class="headerlink" title="Angband"></a>Angband</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183229e4fp5p4yuy0oaoqc.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Angband 是一个免费、单用户、使用 ASCII 字符图形化的地下城探险游戏，在其中你将以一个冒险者的角色探索一个深深的地下城，与怪兽战斗，获得你能取得的最好武器，准备着与黑暗之主 Morgoth 的最后决战。从上世纪九十年代开始，它一直在持续地开发着。</p><p>Angband 沿袭了 Rogue 和 NetHack 的风格路线。它由 Moria 和 Umoria 游戏衍生而来，基于 Rogue 回合制。它经常被描述为一个 “roguelike”游戏，因为它的外观和游戏体验与 Rogue 非常相似。很多游戏中的新生物、物品都来自 J. R. R Tolkien 的画作，尽管有些野兽直接来源于经典的神话、龙与地下城、Rolemaster，或 Angband 的原开发者的脑海中。</p><p>特点包括:</p><ul><li>100 层地下城；</li><li>随机产生的新关卡；</li><li>可以选择成为人类、半精灵、精灵、霍比特人、地精、矮人，半兽人，半巨魔， 登丹人 ，高等精灵，或者狗头人；</li><li>神器；</li><li>施法；</li><li>怪物；</li><li>怪物坑；</li><li><p>怪物巢穴；</p></li><li><p>网站: <a href="http://rephial.org/" target="_blank" rel="noopener">rephial.org</a></p></li><li>开发者: Angband 开发小组</li><li>协议: GNU GPL v2</li><li>版本号: 3.5.0</li></ul><hr><h3 id="UnNetHack"><a href="#UnNetHack" class="headerlink" title="UnNetHack"></a>UnNetHack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183231lfcue7f22idy7g5j.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>UnNetHack 是 NetHack 的一个分支版本。NetHack 最开始于 1987 年发行，并且许多游戏玩家认为它是计算机世界所能提供的最好游戏体验的游戏之一。</p><p>特点包括：</p><ul><li>增加了许多针对 NetHack 的增强，如额外的怪兽、更多的关卡、许多新的元素、更多的危险、更具挑战性的游戏，以及最重要的，相比普通的 NetHack，它更具娱乐性；</li><li><p>帮助新手开始的教程；</p></li><li><p>网站: <a href="http://sourceforge.net/apps/trac/unnethack/" target="_blank" rel="noopener">sourceforge.net/apps/trac/unnethack</a></p></li><li>作者: Patric Mueller</li><li>协议: Nethack General Public License</li><li>版本号: 5.1.0</li></ul><hr><h3 id="Hydra-Slayer"><a href="#Hydra-Slayer" class="headerlink" title="Hydra Slayer"></a>Hydra Slayer</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183238turvck9u5rnkzdac.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Hydra Slayer 是一个专注于杀死九头蛇的开源 Roguelike 游戏。它受到了希腊神话、地下城探险、MathRL seven day roguelike ，和一些关于勇者杀死多头野兽的数字谜题等启发。</p><p>特点如下:</p><ul><li>独特的游戏机制；</li><li>混合希腊神话和数字迷宫的主题；</li><li>传统的 roguelike ASCII 字符界面或贴片/3D 界面；</li><li>5 种人物角色，具有极为不同的战术、力量及弱点；</li><li>28 种敌人类型:<ul><li>10 种基本的九头蛇类型（每种类型都有两种变种）；</li><li>8 种特殊类型的敌人；</li><li>可用作战术工具的无害蘑菇；</li></ul></li><li>28 种装备（并包括材料和装备的大小/力量的变种）；</li><li>15 种武器材料；</li><li>18 种非装备物品；</li><li>3 种可供选择的地图；</li><li>8 种关卡拓扑结构（包括莫比乌斯带和克莱因瓶）；</li><li>11 个关卡生成器；</li><li><p>2 种结局；</p></li><li><p>网站: <a href="http://www.roguetemple.com/z/hydra/" target="_blank" rel="noopener">www.roguetemple.com/z/hydra</a></p></li><li>开发者: Zeno Rogue</li><li>协议: GNU GPL v2</li><li>版本号: 16.1</li></ul><hr><h3 id="Brogue"><a href="#Brogue" class="headerlink" title="Brogue"></a>Brogue</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183246gya2gf712y4y011i.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Brogue 是一个开源的 Roguelike 游戏，它可以运行在 Mac OS X, Windows, Linux, iOS 和 Android 等平台下。</p><p>Brogue 是 Rogue 的一个直系分支，后者是一个最早由 Michael Toy 和 Glenn Wichman 于 1980 年左右开发的地下城探险视频游戏。与其他受欢迎的现代 Roguelike 游戏不同， Brogue 追求简单而不是复杂性，同时尽力确保游戏的不同组成之间的联系是有趣且纷繁多彩。</p><p>这个游戏的目标是取得深藏于地下第 26 层的 “Amulet of Yendor”，再返回到地面逃出生天。对于那些技术娴熟且想进一步探险的人来说，位于 26 层之下的每层均包含 3 颗 lumenstone （流明石）(LCTT 译注：此处与我在<a href="http://brogue.wikia.com/wiki/Lumenstone" target="_blank" rel="noopener">这里</a>看到的有些出入），获得它们，将在胜利的基础上被授予额外的得分。</p><p>Brogue 是一个富有挑战性的游戏，但玩起来非常有趣。尽量不要因游戏的高难度而灰心；试玩一段时间之后，你会发现它变得非常吸引人。</p><p>特点如下:</p><ul><li>追求简单而非复杂；</li><li>对用户友好；</li><li>相比于 Rogue， Brogue 关卡生成更加复杂；</li><li>移除了 XP 和 水平系统 ；</li><li>陷阱，防护性物品；</li><li><p>额外的怪兽类型和魔法物品；</p></li><li><p>网站: <a href="lhttps://sites.google.com/site/broguegame/">sites.google.com/site/broguegame</a></p></li><li>作者: Brian Walker</li><li>协议: GNU Affero GPL</li><li>版本号: 1.7.3</li></ul><hr><p>via: <a href="http://www.linuxlinks.com/article/201412031524381/RoguelikeGames.html" target="_blank" rel="noopener">http://www.linuxlinks.com/article/201412031524381/RoguelikeGames.html</a><br>public: <a href="https://linux.cn/article-5200-1.html" target="_blank" rel="noopener">https://linux.cn/article-5200-1.html</a></p><p>作者：Frazer Kline<br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍 13 款 Roguelike 类游戏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Roguelike 是角色扮演游戏的一个子类。从字面上看，它的意思是 “像 Rogue 的游戏”。Rogue 是一个关于地下城冒险的视频游戏，于 1980 年第一次发行，以极其上瘾而著称。这个游戏的目标是取得深藏于第 26 层的 “Amulet of Yendor”，再返回到顶层逃出生天。&lt;/p&gt;
&lt;p&gt;Roguelike 的准确定义并不存在，但这类游戏通常具有下面的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇幻的叙事背景；&lt;/li&gt;
&lt;li&gt;用程序产生关卡。游戏中的绝大多数场景在开始新的游戏时由游戏自动创建。这样做是为了鼓励玩家不断重玩; &lt;/li&gt;
&lt;li&gt;回合制的地下城探险和战斗；&lt;/li&gt;
&lt;li&gt;随机生成的基于贴片的图形环境；&lt;/li&gt;
&lt;li&gt;随机发生战斗；&lt;/li&gt;
&lt;li&gt;永久死亡 ：在游戏中，死亡真的存在，一旦你的角色死了，那就真的结束了；&lt;/li&gt;
&lt;li&gt;高难度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="游戏" scheme="https://fsslc.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="Roguelike" scheme="https://fsslc.github.io/tags/Roguelike/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 怎样在 Linux 中限制网络带宽使用</title>
    <link href="https://fsslc.github.io/2015/03/27/Translate-How-to-limit-network-bandwidth-on-Linux/"/>
    <id>https://fsslc.github.io/2015/03/27/Translate-How-to-limit-network-bandwidth-on-Linux/</id>
    <published>2015-03-27T06:58:03.000Z</published>
    <updated>2020-03-02T13:55:03.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何在 Linux 中限制网络带宽使用</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/150146k8rfz0ocerade1re.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>假如你经常在 Linux 桌面上运行多个网络应用，或在家中让多台电脑共享带宽；那么你可能想更好地控制带宽的使用。否则，当你使用下载器下载一个大文件时，交互式 SSH 会话可能会变得缓慢以至不可用；或者当你通过 Dropbox 来同步一个大文件夹时，你的室友可能会抱怨在她的电脑上，视频流变得断断续续。</p><p>在本教程中，我将为你描述两种在 Linux 中限制网络流量速率的不同方法。</p><h3 id="在-Linux-中限制一个应用的速率"><a href="#在-Linux-中限制一个应用的速率" class="headerlink" title="在 Linux 中限制一个应用的速率"></a>在 Linux 中限制一个应用的速率</h3><p>限制网络流量速率的一种方法是通过一个名为<a href="http://monkey.org/~marius/trickle" target="_blank" rel="noopener">trickle</a>的命令行工具。通过在程序运行时，预先加载一个速率限制 socket 库 的方法，trickle 命令允许你改变任意一个特定程序的流量。 trickle 命令有一个很好的特性是它仅在用户空间中运行，这意味着，你不必需要 root 权限就可以限制一个程序的带宽使用。要能使用 trickle 程序控制程序的带宽，这个程序就必须使用非静态链接库的套接字接口。当你想对一个不具有内置带宽控制功能的程序进行速率限制时，trickle 可以帮得上忙。</p><p>在 Ubuntu，Debian 及其衍生发行版中安装 trickle ：</p><pre><code class="lang-bash">$ sudo apt-get install trickle</code></pre><p>在 Fdora 或 CentOS/RHEL (带有 <a href="http://linux.cn/article-2324-1.html" target="_blank" rel="noopener">EPEL 软件仓库</a>)：</p><pre><code class="lang-bash">$ sudo yum install trickle</code></pre><p>trickle 的基本使用方法如下。仅需简单地把 trickle 命令（及速率参数）放在你想运行的命令之前。</p><pre><code class="lang-bash">$ trickle -d &lt;download-rate&gt; -u &lt;upload-rate&gt;  &lt;command&gt;</code></pre><p>这就可以将 <code>&lt;command&gt;</code> 的下载和上传速率限定为特定值（单位 KBytes/s）。</p><p>例如，将你的 scp 会话的最大上传带宽设定为 100 KB/s：</p><pre><code class="lang-bash"> $ trickle -u 100 scp backup.tgz alice@remote_host.com:</code></pre><p>如若你想，你可以通过创建一个<a href="http://xmodulo.com/create-desktop-shortcut-launcher-linux.html" target="_blank" rel="noopener">自定义启动器</a>的方式，使用下面的命令为你的 Firefox 浏览器设定最大下载速率（例如， 300 KB/s）。</p><pre><code class="lang-bash">trickle -d 300 firefox %u</code></pre><p>最后， trickle 也可以以守护进程模式运行，在该模式下，它将会限制所有通过 trickle 启动且正在运行的程序的总带宽之和。 启动 trickle 使其作为一个守护进程（例如， trickled）：</p><pre><code class="lang-bash">$ sudo trickled -d 1000</code></pre><p>一旦 trickled 守护进程在后台运行，你便可以通过 trickle 命令来启动其他程序。假如你通过 trickle 启动一个程序，那么这个程序的最大下载速率将是 1000 KB/s， 假如你再通过 trickle 启动了另一个程序，则每个程序的(下载)速率极限将会被限制为 500 KB/s，等等。</p><h3 id="在-Linux-中限制一个网络接口的速率"><a href="#在-Linux-中限制一个网络接口的速率" class="headerlink" title="在 Linux 中限制一个网络接口的速率"></a>在 Linux 中限制一个网络接口的速率</h3><p>另一种控制你的带宽资源的方式是在每一个接口上限制带宽。这在你与其他人分享你的网络连接的上行带宽时尤为实用。同其他一样，Linux 有一个工具来为你做这件事。<a href="http://lartc.org/wondershaper/" target="_blank" rel="noopener">wondershaper</a>就是干这个的。</p><p>wondershaper 实际上是一个 shell 脚本，它使用 <a href="http://lartc.org/manpages/tc.txt" target="_blank" rel="noopener">tc</a> 来定义流量调整命令，使用 QoS 来处理特定的网络接口。外发流量通过放在不同优先级的队列中，达到限制传出流量速率的目的；而传入流量通过丢包的方式来达到速率限制的目的。</p><p>事实上， wondershaper 的既定目标不仅仅是对一个接口增加其带宽上限；当批量下载或上传正在进行时，wondershaper 还试图去保持互动性会话如 SSH 的低延迟。同样的，它还会控制批量上传(例如， Dropbox 的同步)不会使得下载“窒息”，反之亦然。</p><p>在 Ubuntu Debian 及其衍生发行版本 中安装 wondershaper：</p><pre><code class="lang-bash">$ sudo apt-get install wondershaper</code></pre><p>在 Fdora 或 CentOS/RHEL (带有 <a href="http://linux.cn/article-2324-1.html" target="_blank" rel="noopener">EPEL 软件仓库</a>) 中安装 wondershaper：</p><pre><code class="lang-bash">$ sudo yum install wondershaper</code></pre><p>wondershaper 的基本使用如下：</p><pre><code class="lang-bash"> $ sudo wondershaper &lt;interface&gt; &lt;download-rate&gt; &lt;upload-rate&gt;</code></pre><p>举个例子， 将 <code>eth0</code> 的最大下载/上传带宽分别设定为 1000Kbit/s 和 500Kbit/s:</p><pre><code class="lang-bash">$ sudo wondershaper eth0 1000 500</code></pre><p>你也可以通过运行下面的命令将速率限制进行消除：</p><pre><code class="lang-bash">$ sudo wondershaper clear eth0</code></pre><p>假如你对 wondershaper 的运行原理感兴趣，你可以阅读其 shell 脚本源文件(/sbin/wondershaper)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本教程中，我介绍了两种不同的方法，来达到如何在 Linux 桌面环境中，控制每个应用或每个接口的带宽使用的目的。 这些工具的使用都很简单，都为用户提供了一个快速且容易的方式来调整或限制流量。 对于那些想更多地了解如何在 Linux 中进行速率控制的读者，请参考 <a href="http://www.lartc.org/lartc.html" target="_blank" rel="noopener">the Linux bible</a>.</p><hr><p>via: <a href="http://xmodulo.com/limit-network-bandwidth-linux.html" target="_blank" rel="noopener">http://xmodulo.com/limit-network-bandwidth-linux.html</a><br>publish: <a href="https://linux.cn/article-5129-1.html" target="_blank" rel="noopener">https://linux.cn/article-5129-1.html</a></p><p>作者：<a href="http://xmodulo.com/author/nanni" target="_blank" rel="noopener">Dan Nanni</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何在 Linux 中限制网络带宽使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/26/150146k8rfz0ocerade1re.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="限制带宽" scheme="https://fsslc.github.io/tags/%E9%99%90%E5%88%B6%E5%B8%A6%E5%AE%BD/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] Linux 下最为人熟知的归档/压缩工具</title>
    <link href="https://fsslc.github.io/2015/03/27/Translate-Best-Known-Linux-Archive-or-Compress-Tools/"/>
    <id>https://fsslc.github.io/2015/03/27/Translate-Best-Known-Linux-Archive-or-Compress-Tools/</id>
    <published>2015-03-27T01:27:05.000Z</published>
    <updated>2020-03-02T13:54:19.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍 Linux 下常用的归档压缩工具</p></blockquote><p>很多时候，通过互联网发送或接收大文件和图片是一件令人头疼的事。压缩及解压缩工具正好可以应对这个问题。下面让我们快速浏览一些可以使得我们的工作更加轻松的开源工具。</p><a id="more"></a><h3 id="Tar"><a href="#Tar" class="headerlink" title="Tar"></a>Tar</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155328llggxaaxtllxrzhx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Tar 由 ‘Tape archiver（磁带归档器）’ 衍生而来，最初被用来在磁带上归档和存储文件。Tar 是一个 GNU 软件，它可以压缩一组文件（归档），或提取它们以及对已有的归档文件进行相关操作。在存储、备份以及传输文件方面，它是很有用的。在创建归档文件时，Tar 可以保持原有文件和目录结构不变。通过 Tar 归档的文件的后缀名为 ‘.tar’。</p><p><strong>基本用法如下：</strong></p><h4 id="a-创建归档-c-—create"><a href="#a-创建归档-c-—create" class="headerlink" title="a) 创建归档 (c / —create)"></a>a) 创建归档 (c / —create)</h4><pre><code class="lang-bash">tar --create --verbose --file=archive.tar file1 file2 file3</code></pre><p>或</p><pre><code class="lang-bash">tar cvf archive.tar file1 file2 file3</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155332fq00a601bqpb00yl.png" alt="创建一个归档" title="">                </div>                <div class="image-caption">创建一个归档</div>            </figure><h4 id="b-列出归档文件内容-t-—list"><a href="#b-列出归档文件内容-t-—list" class="headerlink" title="b) 列出归档文件内容 ( t / —list)"></a>b) 列出归档文件内容 ( t / —list)</h4><pre><code class="lang-bash">tar --list archive.tar</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155333gtcjtjkhhustzwm0.png" alt="列出归档中包含的文件" title="">                </div>                <div class="image-caption">列出归档中包含的文件</div>            </figure><h4 id="c-提取归档-x-—extract"><a href="#c-提取归档-x-—extract" class="headerlink" title="c) 提取归档 (x / —extract)"></a>c) 提取归档 (x / —extract)</h4><pre><code class="lang-bash">tar xvf archive.tartar xvf archive.tar --wildcards &#39;*.c&#39;  # 从归档中提取后缀名为 *.c 的文件。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155334j1p7s41e6s1z1ktg.png" alt="提取文件" title="">                </div>                <div class="image-caption">提取文件</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155335v8bz6zvdiraa7rra.png" alt="只提取需要的文件" title="">                </div>                <div class="image-caption">只提取需要的文件</div>            </figure><h4 id="d-对归档文件进行更新-u-—update"><a href="#d-对归档文件进行更新-u-—update" class="headerlink" title="d) 对归档文件进行更新 ( u / —update)"></a>d) 对归档文件进行更新 ( u / —update)</h4><pre><code class="lang-bash">tar uvf archive.tar newfile.c   # 假如归档的newfile.c  要比先前已经归档的新，则添加更新的 newfile.c 到归档里面.</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155337a0nxlxxbssobjzdr.png" alt="更新一个归档" title="">                </div>                <div class="image-caption">更新一个归档</div>            </figure><h4 id="e-从归档中删除文件-—delete"><a href="#e-从归档中删除文件-—delete" class="headerlink" title="e) 从归档中删除文件 (—delete)"></a>e) 从归档中删除文件 (—delete)</h4><pre><code class="lang-bash">tar --delete -f archive.tar file1.c   # 从压缩包&#39;archive.tar&#39; 中删除文件&#39;file1.c&#39;</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155338ph34ol4baaazqvpn.png" alt="删除文件" title="">                </div>                <div class="image-caption">删除文件</div>            </figure><p>更加具体的使用方法请参考<a href="http://www.gnu.org/software/tar/" target="_blank" rel="noopener">tar 主页</a>。</p><h3 id="Gzip-Gunzip"><a href="#Gzip-Gunzip" class="headerlink" title="Gzip / Gunzip"></a>Gzip / Gunzip</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155343r6le6osz6eglmvze.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Gzip 即 GNU zip，它是一个被广泛用于 Linux 操作系统中的压缩应用，被其压缩的文件的后缀名为’*.gz’ 。</p><p><strong>基本用法如下：</strong></p><h4 id="a-压缩文件"><a href="#a-压缩文件" class="headerlink" title="a) 压缩文件"></a>a) 压缩文件</h4><pre><code class="lang-bash">gzip file(s)</code></pre><p>每个文件将被<strong>单独压缩</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155343ckwgs2kcgsiciks2.png" alt="压缩文件" title="">                </div>                <div class="image-caption">压缩文件</div>            </figure><p>通常在压缩完成后，它会将原来的文件删除。我们可以使用 <code>-c</code> 选项来保留原来的文件。</p><pre><code class="lang-bash">gzip -c file &gt; file.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155344a1t1bll1r6ll1761.png" alt="压缩后保留原有文件" title="">                </div>                <div class="image-caption">压缩后保留原有文件</div>            </figure><p>我们也可以将一组文件压缩到一个单独的文件中</p><pre><code class="lang-bash">cat file1 file2 file3 | gzip &gt; archieve.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155345b92712nzi1rga299.png" alt="压缩一组文件" title="">                </div>                <div class="image-caption">压缩一组文件</div>            </figure><h4 id="b-检查压缩比"><a href="#b-检查压缩比" class="headerlink" title="b) 检查压缩比"></a>b) 检查压缩比</h4><p>被压缩文件的压缩比可以使用 ‘-l’ 选项来进行检验。</p><pre><code class="lang-bash">gzip -l archieve.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155346sjtsguj6tb4cebj8.png" alt="检查压缩率" title="">                </div>                <div class="image-caption">检查压缩率</div>            </figure><h4 id="c-解压文件"><a href="#c-解压文件" class="headerlink" title="c) 解压文件"></a>c) 解压文件</h4><p>Gunzip 用来解压文件，在这里，原有的（压缩）文件在被解压后同样会被删除。使用 <code>-c</code> 选项来保留原始文件。</p><pre><code class="lang-bash">gunzip -c archieve.gz</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155347r6gcqa4yeaocavgj.png" alt="解压文件" title="">                </div>                <div class="image-caption">解压文件</div>            </figure><p>gzip 加上’-d’选项 和 gunzip 对压缩文件有同样的效果。</p><p>更多细节可以从 <a href="http://www.gzip.org/" target="_blank" rel="noopener">gzip 主页</a> 得到。</p><h3 id="Bzip2-Bunzip2"><a href="#Bzip2-Bunzip2" class="headerlink" title="Bzip2 / Bunzip2"></a>Bzip2 / Bunzip2</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155347ivkih4zijh99k0la.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>同 gzip 一样，<a href="http://www.bzip.org/" target="_blank" rel="noopener">Bzip2</a> 也是一个压缩工具，与其他传统的工具相比，它可以将文件压缩到更小，但其缺点为：运行速度比 gzip 慢。</p><p><strong>基本用法如下：</strong></p><h4 id="a-压缩文件-1"><a href="#a-压缩文件-1" class="headerlink" title="a) 压缩文件"></a>a) 压缩文件</h4><p>一般情况下，针对压缩而言，Bzip2 不用什么选项，将被压缩的文件被传递为它的参数。每个文件被单独压缩，且压缩文件以 ‘bz2’ 为后缀名。</p><pre><code class="lang-bash">bzip2 file1 file2 file3</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155348zkgt66ztg74hj6gh.png" alt="文件压缩" title="">                </div>                <div class="image-caption">文件压缩</div>            </figure><p>使用 ‘-k’ 选项可以使得在压缩或解压缩之后保留原有的文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155349t7p3qhz0pzrrgep1.png" alt="在压缩后保留原有文件" title="">                </div>                <div class="image-caption">在压缩后保留原有文件</div>            </figure><h4 id="b-解压"><a href="#b-解压" class="headerlink" title="b) 解压"></a>b) 解压</h4><p>‘-d’ 选项被用来解压缩。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155349ge4aoz4cse77des8.png" alt="使用 -d 选项解压缩文件" title="">                </div>                <div class="image-caption">使用 -d 选项解压缩文件</div>            </figure><p>也可以使用 bunzip2 来解压缩。</p><pre><code class="lang-bash">bunzip2 filename</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155350nt9sguuy1hy9osfy.png" alt="解压文件" title="">                </div>                <div class="image-caption">解压文件</div>            </figure><p>bunzip2 可以解压后缀名为 bz2, bz, tbz2 和 tbz 的文件。带有 tbz2 和 tbz 的文件在压缩后，后缀名将变为’.tar’ 。</p><pre><code class="lang-bash">bzip2 -dc  # 执行解压文件到标准输出的功能。</code></pre><h3 id="7-zip"><a href="#7-zip" class="headerlink" title="7-zip"></a>7-zip</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155351hh7ic04vf323icvi.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><a href="http://www.7-zip.org/" target="_blank" rel="noopener">7-zip</a> 是另一个开源压缩软件。它使用 7z 这种新的压缩格式，并支持高压缩比。因此，它被认为是比先前提及的压缩工具更好的软件。在 Linux 下，可以通过 p7zip 软件包得到，该软件包里包含 3 个二进制文件： 7z, 7za 和 7zr，读者可以参考 <a href="https://wiki.archlinux.org/index.php/p7zip" target="_blank" rel="noopener">p7zip wiki</a> 来了解这三个二进制文件之间的不同。在本篇中，我们将使用 7zr 来解释 7-zip 的用法。归档文件以 ‘.7z’ 为后缀名。</p><p><strong>基本用法如下：</strong></p><h4 id="a-创建归档"><a href="#a-创建归档" class="headerlink" title="a) 创建归档"></a>a) 创建归档</h4><pre><code class="lang-bash">7zr a archive-name.7z file-name(s) / directory-name(s)</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155352hdguhaheeu47pef4.png" alt="创建一个归档文件" title="">                </div>                <div class="image-caption">创建一个归档文件</div>            </figure><h4 id="b-列出归档包含文件"><a href="#b-列出归档包含文件" class="headerlink" title="b) 列出归档包含文件"></a>b) 列出归档包含文件</h4><pre><code class="lang-bash">7zr l archive-name.7z</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="hhttps://img.linux.net.cn/data/attachment/album/201503/26/155353bvyrpg12c6jgb7j5.png" alt="列出归档中包含的文件" title="">                </div>                <div class="image-caption">列出归档中包含的文件</div>            </figure><h4 id="c-提取归档文件"><a href="#c-提取归档文件" class="headerlink" title="c) 提取归档文件"></a>c) 提取归档文件</h4><pre><code class="lang-bash">7zr e archive-name.7z</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155354xegkfugcb4yre4ge.png" alt="提取归档" title="">                </div>                <div class="image-caption">提取归档</div>            </figure><h4 id="d-更新归档文件"><a href="#d-更新归档文件" class="headerlink" title="d) 更新归档文件"></a>d) 更新归档文件</h4><pre><code class="lang-bash">7zr u archive-name.7z new-file</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155356td1viigihg9ijddi.png" alt="更新一个归档文件" title="">                </div>                <div class="image-caption">更新一个归档文件</div>            </figure><h4 id="e-从归档文件中删除文件"><a href="#e-从归档文件中删除文件" class="headerlink" title="e) 从归档文件中删除文件"></a>e) 从归档文件中删除文件</h4><pre><code class="lang-bash">7zr d archive-name.7z file-to-be-deleted</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155356tysrcjsu0zsraxjj.png" alt="删除文件" title="">                </div>                <div class="image-caption">删除文件</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/26/155358lck57zchhkbe5595.png" alt="确认文件删除" title="">                </div>                <div class="image-caption">确认文件删除</div>            </figure><hr><p>via: <a href="http://linoxide.com/tools/linux-compress-decompress-tools/" target="_blank" rel="noopener">http://linoxide.com/tools/linux-compress-decompress-tools/</a><br>publish: <a href="https://linux.cn/article-5131-1.html" target="_blank" rel="noopener">https://linux.cn/article-5131-1.html</a></p><p>作者：<a href="http://linoxide.com/author/bnpoornima/" target="_blank" rel="noopener">B N Poornima</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍 Linux 下常用的归档压缩工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多时候，通过互联网发送或接收大文件和图片是一件令人头疼的事。压缩及解压缩工具正好可以应对这个问题。下面让我们快速浏览一些可以使得我们的工作更加轻松的开源工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="压缩归档工具" scheme="https://fsslc.github.io/tags/%E5%8E%8B%E7%BC%A9%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 如何在 Linux 中使用类似智能手机外观的 Conky 天气插件</title>
    <link href="https://fsslc.github.io/2015/03/26/Translate-How-To-Use-Smartphones-Like-Weather-Conky-In-Linux/"/>
    <id>https://fsslc.github.io/2015/03/26/Translate-How-To-Use-Smartphones-Like-Weather-Conky-In-Linux/</id>
    <published>2015-03-26T00:02:20.000Z</published>
    <updated>2020-03-02T13:15:45.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 Conky 来显示天气预报</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/24/220418xlzzc64tlzr6oxc6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>智能手机都拥有一些平滑地融入手机外观的天气小插件，现在幸亏有了 Flair Weather Conky，你便可以<strong>在你的 Linux 桌面中拥有像智能手机一样的天气外观</strong>。我们将使用一个 GUI 工具<a href="http://www.linux.cn/article-3434-1.html" target="_blank" rel="noopener">Conky Manager 在 Linux 中轻松地管理 Conky</a>。那就先让我们看看如何在 Ubuntu 14.10，14.04、Linux Mint 17 及其他 Linux 发行版本中安装 Conky Manager 吧。</p><a id="more"></a><h3 id="安装-Conky-Manager"><a href="#安装-Conky-Manager" class="headerlink" title="安装 Conky Manager"></a>安装 Conky Manager</h3><p>打开一个终端并使用下面的命令：</p><pre><code class="lang-bash">sudo add-apt-repository ppa:teejee2008/ppasudo apt-get updatesudo apt-get install conky-manager</code></pre><p>你可以阅读这篇关于<a href="http://www.linux.cn/article-3434-1.html" target="_blank" rel="noopener">如何在 Linux 中使用 Conky Manager</a> 的文章。</p><h3 id="确保-curl-已被安装"><a href="#确保-curl-已被安装" class="headerlink" title="确保 curl 已被安装"></a>确保 <code>curl</code> 已被安装</h3><p>请确保 <a href="http://www.computerhope.com/unix/curl.htm" target="_blank" rel="noopener">curl</a> 已被安装。如果没有安装它，可以使用下面的命令来安装：</p><pre><code class="lang-bash">sudo apt-get install curl</code></pre><h3 id="下载-Flair-Weather-Conky"><a href="#下载-Flair-Weather-Conky" class="headerlink" title="下载 Flair Weather Conky"></a>下载 Flair Weather Conky</h3><p>从下面的链接下载 Flair Weather Conky  的脚本：</p><ul><li><a href="http://speedracker.deviantart.com/art/Flair-Weather-Conky-Made-for-Conky-Manager-510130311" target="_blank" rel="noopener">下载 Flair Weather Conky 的脚本</a></li></ul><h3 id="在-Conky-Manager-中使用-Flair-Weather-Conky-脚本"><a href="#在-Conky-Manager-中使用-Flair-Weather-Conky-脚本" class="headerlink" title="在 Conky Manager 中使用 Flair Weather Conky 脚本"></a>在 Conky Manager 中使用 Flair Weather Conky 脚本</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1:"></a>步骤 1:</h4><p>同你在 Ubuntu 14.04 中安装主题一样，在你的家目录中应该有一个 <code>.conky</code> 目录。假如你使用命令行，我想我不需要告诉你如何找到这个目录。对于新手，请用文件管理器切换到你的家目录下，并按 <code>Ctrl+H</code> 来 <a href="http://itsfoss.com/hide-folders-and-show-hidden-files-in-ubuntu-beginner-trick/" target="_blank" rel="noopener">在 Ubuntu 中显示隐藏文件</a>。在这里查找 <code>.conky</code> 文件夹，假如没有这个文件夹，则创建一个。</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2:"></a>步骤 2:</h4><p>在 <code>.conky</code> 目录中，解压下载到的 Flair Weather 文件。请注意在默认情况下它会自动解压到一个名为 <code>.conky</code> 目录下。所以请进入这个目录，将其中的 Flair Weather 文件夹从中取出，然后将它粘贴到真正的 <code>.conky</code> 目录下。</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3:"></a>步骤 3:</h4><p>Flair Weather 使用 Yahoo 的天气服务，但它不能自动地识别你的位置。你需要手动地编辑它。到<a href="https://weather.yahoo.com/" target="_blank" rel="noopener">Yahoo 天气</a> 网页，然后通过键入你的城市/Pin 码来得到你所在城市的位置 ID号。你可以从网页地址栏中取得位置 ID 号。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/24/220420n57uhf479nt55n0j.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4:"></a>步骤 4:</h4><p>打开 Conky Manager，它应该能够读取新安装的 Conky 脚本。这里有两款样式可用，黑色主题或亮丽主题。你可以选择你偏爱的那一款。当你选择后，你就可以在桌面上看到 conky 的显示了。</p><p>在 Flair Weather 中，默认位置被设定为 Melbourne。你必须手动编辑 conky 文件来修改。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/24/220423dkkwruunwddq5nzn.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5:"></a>步骤 5:</h4><p>在上面的截图中，你可以看到有一个编辑选定 conky 脚本的选项，在打开的编辑器中，查找 location 或 WOEID ，更换它为你在 <code>步骤 3</code> 中得到的位置 ID 号。然后重启 Conky。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/24/220426fqb9njdfjs43ybpn.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在上面查找的相同位置，假如你将<code>u=c</code> 替换为<code>u=f</code>，则温度的单位将从摄氏温标改为华氏温标 。不要忘了重启 Conky 来查看已经做出的修改。</p><h4 id="可能的故障排除"><a href="#可能的故障排除" class="headerlink" title="可能的故障排除"></a>可能的故障排除</h4><p>在 Ubuntu 14.04 和 Ubuntu 14.10 中，假如你发现 Conky 展示的时间有重叠现象，则请编辑 conky 脚本。查找下面的这些行：</p><pre><code class="lang-bash">## cairo-compmgrown_window_type overrideown_window_argb_visual no</code></pre><p>然后将内容更换为下面的这些行：</p><pre><code class="lang-bash">## cairo-compmgrown_window_type dockown_window_argb_visual no</code></pre><p>保存更改并重启 conky。这就应该解决了这个问题。感谢 Jesse(这个 Conky 脚本的开发者)给我们提供了这个解决方法和为其他相关问题给予的支持。</p><h3 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h3><p>在这篇文章中，我们实际上学到了不少东西。我们见证了如何轻松地使用任何 Conky 脚本，如何编辑脚本以及如何使用 Conky Manager 来达到不同的目的。我希望这些对你有用。</p><p>需要留心的是，Ubuntu 14.10 用户可能会看到重叠的时间数字。请在开发者 Jesse 绝妙的<a href="https://plus.google.com/communities/104794997718869399105" target="_blank" rel="noopener">Google + 主页</a> 中报告任何相关的问题。</p><p>我已经向你展示了在我的系统上 Flair Weather conky 外观的截图。现在是该你尝试它并炫耀你的桌面的时间了。</p><hr><p>via: <a href="http://itsfoss.com/weather-conky-linux/" target="_blank" rel="noopener">http://itsfoss.com/weather-conky-linux/</a><br>publish: <a href="https://linux.cn/article-5122-1.html" target="_blank" rel="noopener">https://linux.cn/article-5122-1.html</a></p><p>作者：<a href="http://itsfoss.com/author/Abhishek/" target="_blank" rel="noopener">Abhishek</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 Conky 来显示天气预报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/24/220418xlzzc64tlzr6oxc6.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;智能手机都拥有一些平滑地融入手机外观的天气小插件，现在幸亏有了 Flair Weather Conky，你便可以&lt;strong&gt;在你的 Linux 桌面中拥有像智能手机一样的天气外观&lt;/strong&gt;。我们将使用一个 GUI 工具&lt;a href=&quot;http://www.linux.cn/article-3434-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Conky Manager 在 Linux 中轻松地管理 Conky&lt;/a&gt;。那就先让我们看看如何在 Ubuntu 14.10，14.04、Linux Mint 17 及其他 Linux 发行版本中安装 Conky Manager 吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Conky" scheme="https://fsslc.github.io/tags/Conky/"/>
    
      <category term="天气" scheme="https://fsslc.github.io/tags/%E5%A4%A9%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 如何在 Linux 上使用 BackupPC 来架设跨平台的备份服务器</title>
    <link href="https://fsslc.github.io/2015/03/23/Translate-How-to-set-up-a-cross-platform-backup-server-on-Linux-with-BackupPC/"/>
    <id>https://fsslc.github.io/2015/03/23/Translate-How-to-set-up-a-cross-platform-backup-server-on-Linux-with-BackupPC/</id>
    <published>2015-03-23T01:46:00.000Z</published>
    <updated>2020-03-02T12:51:23.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何在 Linux 上使用 BackupPC 来架设跨平台的备份服务器</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235236goipii0u37jybbuo.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>也许你没有从我先前关于 <a href="http://linux.cn/article-5096-1.html" target="_blank" rel="noopener">backupninja</a> 和 <a href="http://linux.cn/article-4586-1.html" target="_blank" rel="noopener">backup-manager</a> 的两篇文章中发现，我是一个超级备“粉”。当提到备份，我宁愿备份的太多而不希望备份不足，因为如果我们有需要的话，你将会感激你为重要数据生成额外的拷贝所付出的时间和精力。</p><a id="more"></a><p>在这篇文章中，我将向你介绍 <a href="http://backuppc.sourceforge.net/" target="_blank" rel="noopener">BackupPC</a>，一个跨平台的备份服务器软件，它可以通过网络为 Linux，Windows 和 MacOS 等系统上的客户端主机拉取备份。BackupPC 添加了一系列的特点使得管理备份变为一件快乐的事。</p><h3 id="BackupPC-的特点"><a href="#BackupPC-的特点" class="headerlink" title="BackupPC 的特点"></a>BackupPC 的特点</h3><p>BackupPC 自带有一个健壮的 Web 界面，允许你以集中化的方式来收集和管理其他远程客户端主机上的备份。通过使用它的 Web 界面，你可以检查日志和配置文件、为其他远程主机启动/取消/安排备份任务以及可视化备份任务的当前状态。你也可以非常容易地浏览归档的文件以及从备份的归档中恢复单个文件或整个备份。要恢复单个文件，你可以直接通过 Web 界面来下载任何先前备份的文件。不仅如此，客户端主机并不需要安装特别的客户端软件。在 Windows 客户端上， 使用的是原生的 SMB 协议，而对于 *nix 客户端，你将使用 <code>rsync</code> 或 通过 SSH, RSH 或 NFS 来使用 <code>tar</code> 。</p><h3 id="安装-BackupPC"><a href="#安装-BackupPC" class="headerlink" title="安装 BackupPC"></a>安装 BackupPC</h3><p>在 Debian，Ubuntu 和它们的衍生版本上，运行下面的命令：</p><pre><code class="lang-bash"># aptitude install backuppc</code></pre><p>在 Fedora上， 使用 <code>yum</code> 命令。请注意软件包名字对大小写敏感。</p><p>在 CentOS/RHEL 6 上，首先要启用 <a href="http://linux.cn/article-2324-1.html" target="_blank" rel="noopener">EPEL 软件仓库</a>。在 CentOS/RHEL 7 上，请替代启用 <a href="http://linux.cn/article-3889-1.html" target="_blank" rel="noopener">Nux Dextop</a> 软件仓库。然后接着使用 <code>yum</code> 命令：</p><pre><code class="lang-bash"># yum install BackupPC</code></pre><p>同往常一样，这两种包管理系统都会自动解决依赖问题。另外，作为安装过程中的一部分，你可能需要新配置或修改配置用于图形用户界面的 Web 服务器。下面的截图来自于 Debian 系统：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235239b4atzr453axhrhfr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过空格键来确定你的选择，然后使用 tab 键移动到 Ok 选项并敲回车键。</p><p>接着类似于下面的截屏将会呈现在你眼前，通知你创建了一个用来管理 BackupPC 的名为 ‘backuppc’的管理员用户以及相应的密码（如果你需要，这个密码以后可以更改）。这里需要注意的是：这里创建了同样名为 ‘backuppc’的 HTTP 账户和常规的 Linux 账户，它们使用相同的密码。需要前者的目的是来访问受保护的 BackupPC 的 Web 界面，而后者则是为了通过 SSH 来使用 <code>rsync</code> 来执行备份任务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235241zl2i9ueazf8wweuz.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你可以使用下面的命令来更改 HTTP 账户 ‘backuppc’ 的默认密码：</p><pre><code class="lang-bash"># htpasswd /path/to/hash/file backuppc</code></pre><p>至于常规的 ‘backuppc’ <a href="http://xmodulo.com/recommend/linuxguide" target="_blank" rel="noopener">Linux</a>账户，可以使用 <code>passwd</code>命令来更改它的默认密码：</p><pre><code class="lang-bash"># passwd backuppc</code></pre><p>需要提及的是：安装过程中会自动创建 Web 和程序的配置文件。</p><h3 id="启动-BackupPC-并设置备份"><a href="#启动-BackupPC-并设置备份" class="headerlink" title="启动 BackupPC 并设置备份"></a>启动 BackupPC 并设置备份</h3><p>首先，打开一个浏览器窗口并指向 <code>http://\&lt;服务器名称或 IP 地址&gt;/backuppc/</code> 。当弹出提示框时，输入先前向你创建的默认 HTTP 用户凭据（注：即用户名 backuppc 和相应的默认密码）。假如认证成功，你就会被带入到 Web 界面的主页：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235245x9xlmwljccb6wtb9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你想做的第一件事最有可能是通过新增一个客户端主机来备份。进入任务窗格中的 “编辑主机”选项。我们将添加两个客户端主机：</p><ul><li>Host #1: CentOS 7 [IP 192.168.0.17]</li><li>Host #2: Windows 7 [IP 192.168.0.103]</li></ul><p>我们将通过 SSH 使用 <code>rsync</code>来备份 CentOS 主机，使用 SMB 来备份 Windows 主机。在执行备份之前，我们需要向我们的 CentOS 主机设置 <a href="http://xmodulo.com/how-to-enable-ssh-login-without.html" target="_blank" rel="noopener">基于密钥认证</a> 以及在我们的 Windows 主机中设置一个共享目录。</p><p>下面是关于如何为一个远程 CentOS 主机设置基于密钥认证的指导。我们创建 ‘backuppc’ 用户的 RSA 密钥对，并将其公钥传输给 CentOS 主机上的 root 账户。</p><pre><code class="lang-bash"># usermod -s /bin/bash backuppc# su - backuppc# ssh-keygen -t rsa# ssh-copy-id root@192.168.0.17</code></pre><p>当弹出提示框时，键入 yes 并为 192.168.0.17 键入 root 用户的密码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235302xjv7ddrgjdznjos3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你需要一个远程的 CentOS 主机的 root 权限，以获得在该主机中的文件系统中写权限，以防要恢复的备份文件或目录的所有者为 root 账户。</p><p>一旦 CentOS 和 Windows 主机都准备完毕，使用 Web 界面将它们添加到 BackupPC：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235304rdi5npvpnpvssz5o.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下一步更改每个主机的备份设置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235307fjtg4akgb7jee4bg.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来的图片展示了 Windows 主机的备份设置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235313xeb75klfze5223zv.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而接着的截图展示了 CentOS 主机的备份设置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235316uz36bpb9ufupubme.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="开始一个备份任务"><a href="#开始一个备份任务" class="headerlink" title="开始一个备份任务"></a>开始一个备份任务</h3><p>为了开始备份，到每个主机的设定选项，然后点击“开始全备份”：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235322dkzq5zj0pmzj8q6a.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在任何时候，你都可以通过点击如上图展示的每个主机的备份主页来查看备份任务的状态。假如因为某些原因备份失败，在主机菜单中将会出现一个指向包含错误信息的网页的链接。当一个备份任务成功完成后，在服务器的 /var/lib/backuppc/pc 目录下会创建一个命名为主机名或 IP 地址的目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235325h6eeuzwnewuxwq6n.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们也可以随意地在命令行中浏览这个目录中的文件，但存在一个更加简单的方式来查找和恢复这些文件。</p><h3 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h3><p>要浏览这些保存的文件，进入每个主机的主菜单下的 “浏览备份”选项，你可以一目了然地看到目录和文件，并选择那些你想恢复的文件。另外，你还可以通过点击文件来使用默认程序打开文件或右击文件并选择“另存为”来下载该文件到你当前的机器上：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235331nr66znzru5bbir6s.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如若你想，你可以下载一个包含所有你想备份的内容的 zip 或 tar 文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235343l7hihhqyxohmoz9q.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>或只是恢复文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/235350yz97wkg5hhkwqkhh.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有句俗话说，”越简单，越好”，而这正是 BackupPC 所提供的东西。在 BackupPC 中，你将不仅找到了一个备份工具，而且还找到了一个无需任何客户端应用来在几个不同的操作系统中管理你的备份的方法。我相信这就有足够的理由让你去尝试一下。</p><p>欢迎使用下面的评论框来留下你的评论和问题，假如你有的话。我总是乐于听取读者想说的话！</p><hr><p>via: <a href="http://xmodulo.com/backuppc-cross-platform-backup-server-linux.html" target="_blank" rel="noopener">http://xmodulo.com/backuppc-cross-platform-backup-server-linux.html</a><br>publish: <a href="https://linux.cn/article-5097-1.html" target="_blank" rel="noopener">https://linux.cn/article-5097-1.html</a></p><p>作者：<a href="http://xmodulo.com/author/gabriel" target="_blank" rel="noopener">Gabriel Cánepa</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何在 Linux 上使用 BackupPC 来架设跨平台的备份服务器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/20/235236goipii0u37jybbuo.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;也许你没有从我先前关于 &lt;a href=&quot;http://linux.cn/article-5096-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;backupninja&lt;/a&gt; 和 &lt;a href=&quot;http://linux.cn/article-4586-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;backup-manager&lt;/a&gt; 的两篇文章中发现，我是一个超级备“粉”。当提到备份，我宁愿备份的太多而不希望备份不足，因为如果我们有需要的话，你将会感激你为重要数据生成额外的拷贝所付出的时间和精力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="BackupPC" scheme="https://fsslc.github.io/tags/BackupPC/"/>
    
      <category term="备份服务器" scheme="https://fsslc.github.io/tags/%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 如何使用 backupninja 来备份 Debian 系统</title>
    <link href="https://fsslc.github.io/2015/03/21/Translate-How-to-back-up-a-Debian-system-using-backupninja/"/>
    <id>https://fsslc.github.io/2015/03/21/Translate-How-to-back-up-a-Debian-system-using-backupninja/</id>
    <published>2015-03-21T02:03:44.000Z</published>
    <updated>2020-03-02T13:38:40.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 backupninja 来备份 Debian 系统</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230658xqfzb2lx2k290xxb.jpg" alt="题图来自：blogspot.com" title="">                </div>                <div class="image-caption">题图来自：blogspot.com</div>            </figure><p>小心谨慎或灾难体验会让每一个系统管理都认识到频繁的系统备份的重要性。你可以通过编写管用的旧式 shell 脚本，或使用一个（或几个）适合这项工作的备份工具来完成备份任务。因此，当你要实施一个备份解决方案时，你了解的备份工具越多，你做出的决策就会越明智。</p><a id="more"></a><p>在这篇文章中，我们将为你介绍 <a href="https://labs.riseup.net/code/projects/backupninja" target="_blank" rel="noopener">backupninja</a> ，这是一个轻量且易于配置的系统备份工具。在诸如 <strong>rdiff-backup</strong>, <strong>duplicity</strong>, <strong>mysqlhotcopy</strong> 和 <strong>mysqldump</strong> 等程序的帮助下， Backupninja 可以提供常用的备份功能，如执行远程的、安全的和增量式的文件系统备份，加密备份以及 MySQL/MariaDB 数据库备份。你可以选择性地开启使用 Email 状态报告功能，也可以对一般的硬件和系统的信息进行备份。 backupninja 的一个关键功能是它拥有一个内建的基于控制台的向导程序（被称为 <strong>ninjahelper</strong>），而后者允许你为不同的备份情景轻松地创建配置文件。</p><p>如果非要说的话，backupninja 的缺点是：为了充分使用其所有的功能，它要求安装一些其他“助手”程序。尽管 backupninja 有针对基于 Red Hat（红帽）的发行版本的 RPM 安装包，但 backupninja 针对 Debian 及其衍生发行版本的依赖进行了优化。所以不建议在基于 Red Hat 的系统上尝试 backupninja 。</p><p>在这篇教程中，我们将介绍如何在基于 Debian 的发行版本上安装 backupninja 。</p><h3 id="安装-Backupninja"><a href="#安装-Backupninja" class="headerlink" title="安装 Backupninja"></a>安装 Backupninja</h3><p>以 root 账户来运行下面的命令：</p><pre><code class="lang-bash"># aptitude install backupninja</code></pre><p>在安装的过程中，有几个文件和目录将被创建：</p><ul><li><strong>/usr/sbin/backupninja</strong> 是个 bash shell 的主脚本；</li><li><strong>/etc/cron.d/backupninja</strong>， 默认情况下，设置 cron 任务来每隔一个小时运行上面的主脚本；</li><li><strong>/etc/logrotate.d/backupninja</strong> 截断由 backupninja 程序产生的日志；</li><li><strong>/etc/backup.d/</strong> 是备份操作的配置文件驻留的目录；</li><li><strong>/etc/backupninja.conf</strong> 是包含一般选项的主配置文件。这个文件带有良好的注释且详细解释了每个选项的含义；</li><li><strong>/usr/share/backupninja</strong> 是那些 backupninja 所使用的脚本所处的目录。这些脚本文件负责执行实际的工作。在这个目录中，你还可以找到 <code>.helper</code> 文件，它们可以被用来配置和设定 ninjahelper 的菜单；</li><li><strong>/usr/share/doc/backupninja/examples</strong> 含有操作配置文件（即通过 ninjahelper 产生的文件）的模板。</li></ul><h3 id="首次运行-Ninjahelper"><a href="#首次运行-Ninjahelper" class="headerlink" title="首次运行 Ninjahelper"></a>首次运行 Ninjahelper</h3><p>当我们尝试启动 ninjahelper 时，我们可以看到可能需要一个内部依赖程序。假如系统进行了提示，请输入 “yes” 并敲下回车键来安装 dialog（一个用于从 shell 脚本中显示友好对话框的工具）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230751omw0yr1j18t9a1y4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当你在键入 yes 后再敲回车键时，backupninja 将会安装 dialog，一旦安装完成，将呈现出下面的截屏：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230757hfyefp4ee5s44e4b.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="案例-1-备份硬件和系统信息"><a href="#案例-1-备份硬件和系统信息" class="headerlink" title="案例 1: 备份硬件和系统信息"></a>案例 1: 备份硬件和系统信息</h4><p>在启动了 ninjahelper 之后，我们将创建一个新的备份操作：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230804jtfqoq33lmtqt3mu.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果必要的助手程序没有被安装，下面的截屏将会呈现在我们眼前。假如这些软件包已经在你的系统上安装了，请跳过这一步。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230808jz541iix51w8ewd5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来的一步需要你选取相关条目来作为此次备份任务的一部分。前四个条目已经默认被选上了，但你可以通过在条目上按空格键来撤消选择。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230813do1yjakekfe3e93e.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一旦你完成了上面的步骤，按 OK 选项来继续。接着你将能够选择是愿意使用默认的配置文件(/etc/backup.d/10.sys)来完成这次备份操作，还是创建一个新的配置文件。若为后者，一个含有与默认配置文件内容相同的文件将会在相同的目录下被创建，但它被命名为 11.sys，后续的备份操作将会创建类似的文件（注：只不过命名的序号不同）。需要说明的是一旦这个新的配置文件被创建，你便可以使用你喜爱的文本编辑器来编辑该文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230814raukkmqtg2qpcham.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="案例-2-一个远程目录的增量式-Rsync-拉取备份"><a href="#案例-2-一个远程目录的增量式-Rsync-拉取备份" class="headerlink" title="案例 2: 一个远程目录的增量式 Rsync 拉取备份"></a>案例 2: 一个远程目录的增量式 Rsync 拉取备份</h4><p>正如你最有可能知道的那样， rsync 被广泛地用于通过网络同步文件或文件夹。在接下来的例子中，我们将讨论一个使用硬链接来为一个远程目录做增量式拉取备份的方法，它被用来保存历史数据以及在我们本地的文件服务器中恢复这些历史数据。这个方法将帮助我们节省空间并增强位于服务器端的安全性。</p><p><strong>步骤 1</strong>：编写一个带有如下内容的自定义脚本，放在 <code>/etc/backup.d</code>，并将它的权限设置为 600 。需要说明的是，除了一般的配置文件，这个目录可能还包含当 backupninja 执行时你想运行的一些脚本文件，它们可以发挥出位于主配置文件中的变量的优势。</p><pre><code class="lang-bash"># REMOTE USERuser=root# REMOTE HOSThost=dev1# REMOTE DIRECTORYremotedir=/home/gacanepa/# LOCAL DIRECTORYlocaldir=/home/gacanepa/backup.0# LOCAL DIRECTORY WHERE PREVIOUS BACKUP WAS STOREDlocaldirold=/home/gacanepa/backup.1mv $localdir $localdirold# RSYNCrsync -av --delete --recursive --link-dest=$localdirold $user@$host:$remotedir $localdir</code></pre><p>在上面的配置中， rsync 的 ‘—link-dest’ 选项的作用是为位于 $localdir-old 目录中那些没有改变的文件(包含所有属性) 硬链接到目标目录（$localdir）。</p><p><strong>步骤 2</strong>：在 backupninja 第一次运行之前，上层目录（这个例子中指的是 /home/gacanepa） 是空的。第一次我们执行下面的命令：</p><pre><code class="lang-bash"># backupninja -n</code></pre><p>backup.0 目录就被创建了，并在接下来的过程中，它的名称将会被更改为 backup.1。</p><p>当我们第二次运行 backupninja 时， backup.0 将会被重新创建，而 backup.1 保持不动。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230820w02yhv62pihlhhf7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>步骤 3</strong>： 确保 backup.1 里面的文件硬链接到 backup.0 里的文件，我们可以通过比较文件的 inode（i 节点）数和目录的大小来达到此目的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/20/230820sytt0ep1btbweei5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Backupninja 不仅是一个经典的备份工具，它也是一个易于配置的实用程序。你可以通过编写你自己的控制脚本，用放在 <code>/etc.backup.d</code> 中的不同的配置文件来运行 backupninja 。甚至你还可以为 ninjahelper 编写助手程序，并将其包括在 ninjahelper 的主界面上。</p><p>例如，假如你在 <code>/usr/share/backupninja</code>目录中创建了一个名为 xmodulo 的控制脚本，它将自动运行那些位于 <code>/etc/backup.d</code> 目录中以 .xmodulo 为后缀的每个文件。如果你决定添加你的 xmodulo 控制脚本到 ninjahelper 中， 你可以编写相应的助手程序，即 xmodulo.helper 。另外，假如你想 让 backupninja 运行其它的脚本，只需把它添加到 <code>/etc/backup.d</code> 目录中就可以了。</p><p>欢迎使用下面的评论框来留下你的评论、问题或建议。听到你的回应将会使我们很高兴。</p><hr><p>via: <a href="http://xmodulo.com/backup-debian-system-backupninja.html" target="_blank" rel="noopener">http://xmodulo.com/backup-debian-system-backupninja.html</a><br>publish: <a href="https://linux.cn/article-5096-1.html" target="_blank" rel="noopener">https://linux.cn/article-5096-1.html</a></p><p>作者：<a href="http://xmodulo.com/author/gabriel" target="_blank" rel="noopener">Gabriel Cánepa</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 backupninja 来备份 Debian 系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/20/230658xqfzb2lx2k290xxb.jpg&quot; alt=&quot;题图来自：blogspot.com&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;题图来自：blogspot.com&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;小心谨慎或灾难体验会让每一个系统管理都认识到频繁的系统备份的重要性。你可以通过编写管用的旧式 shell 脚本，或使用一个（或几个）适合这项工作的备份工具来完成备份任务。因此，当你要实施一个备份解决方案时，你了解的备份工具越多，你做出的决策就会越明智。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="backupninja" scheme="https://fsslc.github.io/tags/backupninja/"/>
    
      <category term="备份" scheme="https://fsslc.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 让你玩转 Ubuntu 桌面的十一件武器</title>
    <link href="https://fsslc.github.io/2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/"/>
    <id>https://fsslc.github.io/2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/</id>
    <published>2015-03-11T01:00:00.000Z</published>
    <updated>2020-03-01T16:28:56.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能</p></blockquote><p><strong>无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。</strong></p><p>从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你<strong>调整 Ubuntu ，随时满足你的需求</strong>。</p><a id="more"></a><p>注意： Ubuntu 总是配备了‘合理的默认设置’（即工作良好的选项），以达到开箱即用，这些默认设置适合大多数人，并且它们都是经过了测试、采用及推荐等过程的。</p><p>但一个尺码并不适合所有人。对于我们当中的能工巧匠和实验主义者来说，默认设置只是他们定制系统的起点。</p><p>所以，无需更多的唠叨， 这里有 11 个极好的实用工具可以帮助你增强 Ubuntu 使用体验。</p><h3 id="Unity-Tweak-Tool"><a href="#Unity-Tweak-Tool" class="headerlink" title="Unity Tweak Tool"></a>Unity Tweak Tool</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004329h9lncxutj7s98l66.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我将以这个列表中最重要的一个工具: <strong>Unity Tweak Tool</strong> 来开始这次的介绍。融汇了各种定制选项，Unity Tweak Tool 提供了一系列针对 Ubuntu 和 Unity 桌面的系统综合调整功能。</p><p>它被各种开关、切换和控制器塞得满满的，使得你可以任意设置从 Unity 桌面的外观到 Unity 的行为之类的任何东西。你可以使用它<strong>快速简便地改变 GTK 主题和图标集</strong>、设置热区、调整启动器图标尺寸、增加或移除工作区，以及 —-特别地—-开启 Unity 桌面中被巧妙隐藏的“通过点击最小化”的功能。</p><p>它是免费的，可直接从 Ubuntu 软件中心里找到， Unity Tweak Tool 是非常值得保留在你的口袋里的工具之一。</p><h3 id="Unity-隐私指示器"><a href="#Unity-隐私指示器" class="headerlink" title="Unity 隐私指示器"></a>Unity 隐私指示器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004331vjf9qq1vv3jq7913.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>隐私是一个非常、非常重要的事，事实也恰恰如此，但这个话题要比二进制还难以说明白。让一些数据或习惯，比如说你经常打开的应用，在本地被记录下来，这或许会让你感到高兴，但对于你在 Dash 中的搜索数据被发送到第三方服务机构(尽管这些数据或许是匿名的)这类事情，你就高兴不起来了。</p><p><a href="http://www.florian-diesch.de/software/indicator-privacy/index.html" target="_blank" rel="noopener">隐私指示器</a> 是一个帮助你时刻跟踪 Ubuntu桌面系统中有哪些文件、目录和服务正被获取、记录及搜索的实用工具。</p><p>通过快速的点击被添加到桌面面板上的‘眼睛’图标，你可以：</p><ul><li>开启或关闭在线搜索结果，使用 Zeitgeist 记录系统活动，存储 HUD 使用记录和启用 Ubuntu GeoIP 服务</li><li>快速清理 Zeitgeist 日志、 ALT-F2 历史、最近访问文件等等的记录数据</li><li>展示或隐藏桌面图标及面板上显示的用户名</li></ul><p>上述的最后一条的功能似乎不应该出现在这个应用程序中，但对于那些要分享截图或截屏的人来说，这将会泄露更少的隐私。</p><ul><li><a href="http://www.florian-diesch.de/software/indicator-privacy/dist/indicator-privacy_0.04-1_all.deb" target="_blank" rel="noopener">从这里下载隐私指示器 (.deb)</a></li></ul><h3 id="Unity-橱窗"><a href="#Unity-橱窗" class="headerlink" title="Unity 橱窗"></a>Unity 橱窗</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004337qh83z5gv3pwq7s8h.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>Android, iOS, OS X, Chrome OS, 和 GNOME Shell 都有应用橱窗, 借助一个极好的第三方应用，Unity 也可以实现类似功能。</strong></p><p>“Unity 橱窗” 允许你将 Unity 启动器中的应用分组到实用的橱窗中，—- 如游戏，办公，社交等。不必打开 Dash，你就可以快速启动你喜爱的应用，这非常适合你的工作流。</p><p>每一个 ‘橱窗’其实上是一个打开在图标附近的应用窗口，但总体效果看上去就像是一个 OS X 风格的“堆栈”或 Android 的分组框。</p><p>橱窗的图标可以自定义或根据橱窗内的应用来自动生成。已有的橱窗可以修改和重新组织、重命名以及如下的更多选择：</p><ul><li>根据你的喜好创建任意多的橱窗</li><li>选择自定义或自动生成橱窗图标</li><li>可选择 3 种橱窗样式</li><li>为添加到橱窗中的应用设定自定义图标</li><li>编辑现有橱窗</li></ul><p><a href="http://unity-folders.exceptionfound.com/" target="_blank" rel="noopener">Unity 橱窗的网址</a></p><h3 id="咖啡因（Caffeine）"><a href="#咖啡因（Caffeine）" class="headerlink" title="咖啡因（Caffeine）"></a>咖啡因（Caffeine）</h3><p>对于我们中的许多人来说，咖啡因是必需品，而不仅仅是饮料。而这里的“咖啡因”则提供了一个快速，温和的方式来避免屏保/锁屏占据屏幕。它的有用程度将取决于你的环境(即你系统的怪癖)，并且尽管它不像以前那样好用，它仍然值得你<a href="http://www.omgubuntu.co.uk/2014/05/stop-ubuntu-sleeping-caffeine" target="_blank" rel="noopener">尝试一下</a>。</p><p><a href="https://launchpad.net/~caffeine-developers/+archive/ppa/+files/caffeine_2.7_all.deb" target="_blank" rel="noopener">下载咖啡因（Caffeine） </a></p><h3 id="系统监控指示器"><a href="#系统监控指示器" class="headerlink" title="系统监控指示器"></a>系统监控指示器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004338tii8ix884b8tz81r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假如你是一个状态迷，即一个喜欢密切关注程序，进程和硬件的状态的人， Linux 很容易满足你的需求。从 Conky 的配置到终端命令，并不缺少监视你的 CPU 使用情况、网络流量或 GPU 温度的方法。</p><p>但至今为止，我最喜爱的应用是<strong>系统监控指示器</strong>（也被叫做多负载指示器），它可从 Ubuntu 软件中心获得。它也有着大量的配置选项。</p><ul><li><a href="apt://indicator-mulitload">点击这个链接，在 Ubuntu 中下载 ‘系统监控指示器’</a></li></ul><h3 id="针对-Linux-笔记本电脑的省电工具"><a href="#针对-Linux-笔记本电脑的省电工具" class="headerlink" title="针对 Linux 笔记本电脑的省电工具"></a>针对 Linux 笔记本电脑的省电工具</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004339r5tvyyli0enujnty.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h4><p>当提到便携式设备上的电池使用效率时，Linux 发行版的声誉并不算好。</p><p>如果你的 Linux 笔记本在重新充电前，电池只够让你从沙发走到厨房的话，那么这里有几个你可以试试的工具。</p><p>TLP 是最受欢迎的确保延长 Linux 笔记本的电池寿命的自动化后台工具之一，它是通过调整系统进程和硬件的设置及行为来达成省电的，例如 启动 Wi-Fi 省电模式， PCI 总线设备的实时电量管理和处理器的降频调整。</p><p>在 Ubuntu 14.04 LTS 以及后续发行版本中可以<a href="https://launchpad.net/~linrunner/+archive/ubuntu/tlp/+packages" target="_blank" rel="noopener">使用 TLP 专用的 PPA 来安装它</a>，通过它的‘一下搞定’的设置就能用起来。在我们之中的高级用户可以潜心研究并根据你自己的硬件来调整设置，一个<a href="http://linrunner.de/en/tlp/docs/tlp-configuration.html" target="_blank" rel="noopener">关于 TLP 的完整指导 wiki</a> 使得设置更加容易。</p><h4 id="Laptop-Mode-Tools"><a href="#Laptop-Mode-Tools" class="headerlink" title="Laptop Mode Tools"></a>Laptop Mode Tools</h4><p>假如 TLP 听起来有一点复杂，这也并没有什么可羞耻的，这里有一个更简单的替代品： <strong>Laptop Mode Tools</strong>。 这个软件包可从 Ubuntu 软件中心直接安装，且本身设置好了一系列合理的默认设置(Wi-Fi,蓝牙等等)。</p><p>切记，Laptop Mode Tools 不能和 TLP 同时被安装在电脑中。</p><ul><li><a href="https://apps.ubuntu.com/cat/applications/laptop-mode-tools/" target="_blank" rel="noopener">Ubuntu 软件中心里的 Laptop Mode Tools </a></li></ul><h3 id="Intel-显卡驱动安装工具"><a href="#Intel-显卡驱动安装工具" class="headerlink" title="Intel 显卡驱动安装工具"></a>Intel 显卡驱动安装工具</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004340x03qzr5r0cpo3ddb.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于那些运行 Intel 显卡硬件，并想使得这些硬件发挥出最佳性能的人来说，Intel 显卡安装工具是必须拥有的。 它使得查找并安装最新的 Intel GPU 驱动变得不再是一件痛苦和大费周折的事，因为这无需 PPA 或任何的终端使用知识。</p><ul><li><a href="https://01.org/linuxgraphics/downloads/2014/intelr-graphics-installer-linux-1.0.7" target="_blank" rel="noopener">下载针对 Linux平台的 Intel 显卡驱动安装器 0.7 版本</a></li></ul><h3 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004342ux0qm9a244szxjqx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假如你计划升级你的 PC 或想替换一个坏掉的零部件，你需要知道一些特定的硬件信息，例如 RAM 类型，CPU插座类型 或查看哪个 PCI 槽是可用的等信息。</p><p><strong>I-Nex</strong>可以使得找出这些以及其他的系统具体配置变得更加容易。使用它来查找你的主板型号、S.M.A.R.T.(注：为 Self-Monitoring, Analysis and Reporting Technology 的缩写，经常写为 SMART ) 状态，以及你想的出的很多东西！</p><ul><li><a href="https://launchpad.net/i-nex" target="_blank" rel="noopener">可从 Launchpad 了解到更多关于 I-Nex 的信息</a></li></ul><h3 id="磁盘空间可视化程序"><a href="#磁盘空间可视化程序" class="headerlink" title="磁盘空间可视化程序"></a>磁盘空间可视化程序</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004343whhai9rxqxh5hrah.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在这个硬盘以 TB 计数的时代，我们或许不必同以前一样对硬盘空间的使用三思而后行。但对于那些使用小容量的 SSD，分成多个分区或在一个拥有固定大小的虚拟磁盘的虚拟机上工作的人来说，总有“应该释放一些额外空间是必要的”这种想法的时候。</p><p>GNOME Disks，在 Ubuntu 中被默认安装，使得查找占用最大磁盘空间的罪魁祸首变得容易。对于定位隐藏的日志、缓存和视频文件，它是非常完美的工具。</p><h3 id="BleachBit-Cruft-Cleaner"><a href="#BleachBit-Cruft-Cleaner" class="headerlink" title="BleachBit (Cruft Cleaner)"></a>BleachBit (Cruft Cleaner)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004344vbyyaa4w8582lpn4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Windows 用户可能对像 CCleaner 之类的应用很熟悉，它可以扫描并清理垃圾文件、空白文件夹、臃肿的缓存以及陈旧的软件包。在 Ubuntu 上，一个相似的快速且毫不费力的一键式清理方法可以试试 <strong>BleachBit</strong> 。</p><p>它是一个强大的工具，所以一定要注意你正在清理什么。不要漫无目的地确认每个选项框；不是所有的东西它都可以清理。所以请合理地使用它，当你对某个选项有疑问时，就跳过它。</p><ul><li><a href="https://apps.ubuntu.com/cat/applications/bleachbit/" target="_blank" rel="noopener">从 Ubuntu 软件中心里安装 BleachBit</a></li></ul><p>你已经有了自己最喜欢的系统实用工具了吗？可以在下面的评论中让其他人知晓它。</p><hr><p>via: <a href="http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-them" target="_blank" rel="noopener">http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-them</a><br>publish: <a href="https://linux.cn/article-5025-1.html" target="_blank" rel="noopener">https://linux.cn/article-5025-1.html</a></p><p>作者：<a href="https://plus.google.com/117485690627814051450/?rel=author" target="_blank">Joey-Elijah Sneddon</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你&lt;strong&gt;调整 Ubuntu ，随时满足你的需求&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ubuntu" scheme="https://fsslc.github.io/tags/Ubuntu/"/>
    
      <category term="桌面" scheme="https://fsslc.github.io/tags/%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] dupeGuru - 直接从硬盘中查找并移除重复文件</title>
    <link href="https://fsslc.github.io/2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/"/>
    <id>https://fsslc.github.io/2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/</id>
    <published>2015-03-05T03:38:00.000Z</published>
    <updated>2020-03-01T16:43:44.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 dupeGuru 来查找并删除重复文件</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 <strong>dupeGuru</strong> 可能会帮助到你。</p><p>dupeGuru 团队也开发了名为 <strong>dupeGuru 音乐版</strong> 的应用来移除重复的音乐文件，和名为 <strong>dupeGuru 图片版</strong> 的应用来移除重复的图片文件。</p><a id="more"></a><h3 id="1-dupeGuru-标准版"><a href="#1-dupeGuru-标准版" class="headerlink" title="1. dupeGuru (标准版)"></a>1. dupeGuru (标准版)</h3><p>需要告诉那些不熟悉 <a href="http://www.hardcoded.net/dupeguru/" target="_blank" rel="noopener">dupeGuru</a> 的人，它是一个免费、开源、跨平台的应用，其用途是在系统中查找和移除重复文件。它可以在 Linux, Windows, 和 Mac OS X 等平台下使用。通过使用一个快速的模糊匹配算法，它可以在几分钟内找到重复文件。同时，你还可以调整 dupeGuru 使它去精确查找特定文件类型的重复文件，以及从你想删除的文件中，清除某种文件。它支持英语、 法语、 德语、 中文 （简体）、 捷克语、 意大利语、亚美尼亚语、俄语、乌克兰语、巴西语和越南语。</p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru</h4><p>dupeGuru 开发者已经构建了一个 Ubuntu PPA (Personal Package Archives)来简化安装过程。想要安装 dupeGuru，依次在终端中键入以下命令：</p><pre><code class="lang-bash">sudo apt-add-repository ppa:hsoft/ppasudo apt-get updatesudo apt-get install dupeguru-se</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用非常简单，可从 Unity 面板或菜单中启动 dupeGuru。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru_007.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点击位于底部的 <code>+</code> 按钮来添加你想扫描的文件目录。点击 <code>扫描</code> 按钮开始查找重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru_008.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一旦所选目录中含有重复文件，那么它将在窗口中展示重复文件。正如你所看到的，在下面的截图中，我的下载目录中有一个重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Results_009.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在，你可以决定下一步如何操作。你可以删除这个重复的文件，或者对它进行重命名，抑或是 复制/移动 到另一个位置。为此，选定该重复文件，或在菜单栏中选定写有“<strong>仅显示重复</strong>”选项 ，如果你选择了“<strong>仅显示重复</strong>”选项，则只有重复文件在窗口中可见，这样你便可以轻松选择并删除这些文件。点击“操作”下拉菜单，最后选择你将执行的操作。在这里，我只想删除重复文件，所以我选择了“移动标记文件到垃圾箱”这个选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/Menu_010.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接着，点击“继续”选项来移除重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/Deletion-Options_011.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-dupeGuru-音乐版"><a href="#2-dupeGuru-音乐版" class="headerlink" title="2. dupeGuru 音乐版"></a>2. dupeGuru 音乐版</h3><p><a href="http://www.hardcoded.net/dupeguru_me/" target="_blank" rel="noopener">dupeGuru 音乐版</a> 或简称 dupeGuru ME，它的功能与 dupeGuru 类似。它拥有 dupeGuru 的所有功能，但它包含更多的信息列 （如比特率，持续时间，标签等）和更多的扫描类型（如带有字段的文件名，标签以及音频内容）。和 dupeGuru 一样，dupeGuru ME 也运行在 Linux、Windows 和 Mac OS X 中。</p><p>它支持众多的格式，诸如 MP3、WMA、AAC (iTunes 格式)、OGG、FLAC，以及失真率较少的 AAC 和 WMA 格式等。</p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-ME"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-ME" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME</h4><p>现在，我们不必再添加任何 PPA，因为在前面的步骤中，我们已经进行了添加。所以在终端中键入以下命令来安装它：</p><pre><code class="lang-bash">sudo apt-get install dupeguru-me</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>你可以从 Unity 面板或菜单中启动它。dupeGuru ME 的使用方法、操作界面以及外观和正常的 dupeGuru 类似。添加你想扫描的目录并选择你想执行的操作。重复的音乐文件就会被删除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Music-Edition-Results_012.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="3-dupeGuru-图片版"><a href="#3-dupeGuru-图片版" class="headerlink" title="3. dupeGuru 图片版"></a>3. dupeGuru 图片版</h3><p><a href="http://www.hardcoded.net/dupeguru_pe/" target="_blank" rel="noopener">dupeGuru 图片版</a>,或简称为 duepGuru PE，是一个在你的电脑中查找重复图片的工具。它和 dupeGuru 类似，但独具匹配重复图片的功能。dupeGuru PE 可运行在 Linux、Windows 和 Mac OS X 中。</p><p>dupeGuru PE 支持 JPG、PNG、TIFF、GIF 和 BMP 等图片格式。所有的这些格式可以被同时比较。Mac OS X 版的 dupeGuru PE 还支持 PSD 和 RAW (CR2 和 NEF) 格式。  </p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-PE"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-PE" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE</h4><p>由于我们已经添加了 PPA，我们也不必为 dupeGuru PE 再次添加。只需运行如下命令来安装它。</p><pre><code class="lang-bash">sudo apt-get install dupeguru-pe</code></pre><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>就使用方法，操作界面和外观而言，它与 dupeGuru，dupeGuru ME 类似。我就纳闷为什么开发者为不同的类别开发了不同的版本。我想如果开发一个结合以上三个版本功能的应用，或许会更好。</p><p>启动它，添加你想扫描的目录，并选择你想执行的操作。就这样，你的重复文件将被清除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Picture-Edition-Results_014.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果因为任何的安全问题而不能移除某些重复文件，请记下这些文件的位置，通过终端或文件管理器来手动删除它们。</p><p>欢呼吧！</p><hr><p>via: <a href="http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/" target="_blank" rel="noopener">http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/</a><br>publish: <a href="https://linux.cn/article-4992-1.html" target="_blank" rel="noopener">https://linux.cn/article-4992-1.html</a></p><p>作者：<a href="http://www.unixmen.com/author/sk/" target="_blank" rel="noopener">SK</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/carolinewuyan" target="_blank" rel="noopener">Caroline</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 dupeGuru 来查找并删除重复文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 &lt;strong&gt;dupeGuru&lt;/strong&gt; 可能会帮助到你。&lt;/p&gt;
&lt;p&gt;dupeGuru 团队也开发了名为 &lt;strong&gt;dupeGuru 音乐版&lt;/strong&gt; 的应用来移除重复的音乐文件，和名为 &lt;strong&gt;dupeGuru 图片版&lt;/strong&gt; 的应用来移除重复的图片文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="重复文件" scheme="https://fsslc.github.io/tags/%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/"/>
    
      <category term="dupeGuru" scheme="https://fsslc.github.io/tags/dupeGuru/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号</title>
    <link href="https://fsslc.github.io/2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/"/>
    <id>https://fsslc.github.io/2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/</id>
    <published>2015-02-28T12:53:00.000Z</published>
    <updated>2020-03-01T16:28:21.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过 GitHub 将它们嵌入到网页和其他项目中</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205325gyj2l10yn2zxgm4y.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。</p><p>现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近<a href="https://blog.twitter.com/2014/open-sourcing-twitter-emoji-for-everyone" target="_blank" rel="noopener">开源了</a>他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。</p><a id="more"></a><p>但这需要一点体力活。 Unicode 已经识别甚至标准化了 emoji 字母表， 然而 emoji 仍然<a href="http://www.unicode.org/reports/tr51/full-emoji-list.html" target="_blank" rel="noopener">不能完全与所有的网络浏览器相兼容</a>，这意味着大多数情况下，它们将呈现为 “豆腐块”或“空白盒子”。当 Twitter 想使得 emoji 到处可用时，这家社交网络联合了一家名为<a href="https://twitter.com/iconfactory" target="_blank" rel="noopener">Icon Factory</a>的公司来渲染浏览器以模仿文本信息符号的效果。Twiter 认为人们对他们的 emoji 库有很大的需求。</p><p>现在， 你可以从 <a href="https://github.com/twitter/twemoji" target="_blank" rel="noopener">GitHub</a> 上克隆 Twitter 的整个库，从而在你的开发项目中使用它们。 下面将为你介绍如何达到上面的目的以及如何使得 emoji 更容易被使用。</p><h3 id="为-Emoji-得到-Unicode-支持"><a href="#为-Emoji-得到-Unicode-支持" class="headerlink" title="为 Emoji 得到 Unicode 支持"></a>为 Emoji 得到 Unicode 支持</h3><p>Unicode 是国际编码标准，它为任意的符号、字母或人们想在网络上使用的数字配置了一串编码。换句话说，它是你如何在计算机上阅读文本与计算机如何读取文本之间的缺失环节。例如，对于你正看到的位于这些句子中的<code>空格</code>（LCTT 译注：英文分词中间的空格），计算机读取为 “&amp;nbsp”。</p><p>Unicode 甚至拥有其自己的<a href="http://www.unicode.org/reports/tr51/full-emoji-list.html" target="_blank" rel="noopener">原始 emoji</a>，它们可以在没有你的任何努力的情况下在浏览器中被阅读。例如，当你看到了 一个 ❤ 符号，你的计算机正在解码字符串 “2665” 。</p><p>要在大多数情况下使用 Twitter 的 emoji 库，你只需在你的 HTML 网页中的 <code>&lt;head&gt;</code>块中添加如下脚本：</p><pre><code class="lang-html">&lt;script src=&quot;//twemoji.maxcdn.com/twemoji.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>这样就使得你的项目可以访问包含有已经在 Twitter 中可使用的数以百计的 Emoji 符号的 JavaScript 库。然而，创建一个仅仅包含这个脚本的文档并不能使得在你的网站中呈现出 emoji 符号，实际上，你仍需要嵌入这些 emoji 符号！</p><p>在 <code>&lt;body&gt;</code>块中，粘贴一些可以在 Twitter 的<a href="https://github.com/twitter/twemoji/blob/gh-pages/preview.html" target="_blank" rel="noopener">preview.html 文件源代码</a> 中找到的 emoji 字符串。我使用了 &#x1F3B9; 和 &amp;#x1F3C1，当然我并不知道在浏览器窗口中它们的样子。是的，你必须粘贴并猜测它们。你已经看出了问题，我们将在第二小节中予以解决。</p><p>无论如何，通过一些尝试，你可以将一个如下图的原始 HTML 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205332ff1vf82k13o18t92.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>显示为如下图的网页：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205334iei6li3wvl3vl6tr.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="将-Emoji-转换为可阅读的语言"><a href="#将-Emoji-转换为可阅读的语言" class="headerlink" title="将 Emoji 转换为可阅读的语言"></a>将 Emoji 转换为可阅读的语言</h3><p>对于一个网站或应用，Twitter 的解决方案是非常适用的。但如果你想通过 HTML 轻易地插入你喜爱的 emoji 符号，你需要一个更易实现的解决方案，而不是记住所有代表 emoji 的 Unicode 字符串。</p><p>那正是程序员 Elle Kasai 的 <a href="http://ellekasai.github.io/twemoji-awesome/" target="_blank" rel="noopener">Twemoji Awesome</a> 样式大展身手的地方。</p><p>通过向任意网页中添加 Elle 的开源样式表，你可以适用 英语单词来理解你正插入的 emoji 符号的意义。所以如若你想展示一个 心形 emoji 符号，你可以简单地输入：</p><pre><code class="lang-html">&lt;i class=&quot;twa twa-heart&quot;&gt;&lt;/i&gt;</code></pre><p>为了实现上面的目的，让我们下载 Elle 的项目，通过点击在 GitHub 上 “Download ZIP” 按钮。</p><p>接着，我们在桌面上新建一个文件夹，然后进入该文件夹，并将 emoji.html—-我先前向你展示的 HTML 源文件—- 和 Elle 的 <a href="https://github.com/ellekasai/twemoji-awesome/blob/gh-pages/twemoji-awesome.css" target="_blank" rel="noopener">twemoji-awesome.css</a> 一同放进去。</p><p>我们还需要 HTML 文件识别这个 CSS 文件，所以在 html 网页中的 <code>&lt;head&gt;</code> 块中，为 CSS 文件添加一个链接：</p><pre><code class="lang-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;twemoji-awesome.css&quot;&gt;</code></pre><p>一旦你将上面的代码添加了进去，你便可以删除先前添加的 Twitter 的脚本链接。</p><p>现在，找到 <code>body</code> 块部分的代码，然后添加一些 emoji 符号。我使用了 <code>&lt;i class=&quot;twa twa-sparkling-heart&quot;&gt;&lt;/i&gt;</code>, <code>&lt;i class=&quot;twa twa-exclamation&quot;&gt;&lt;/i&gt;</code>, <code>&lt;i class=&quot;twa twa-lg twa-sparkles&quot;&gt;&lt;/i&gt;</code> 和 <code>&lt;i class=&quot;twa twa-beer&quot;&gt;&lt;/i&gt;</code>。</p><p>最终，你将得到如下的代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205336rpl22xbdxl2ixljx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>保存并在浏览器中查看上面的文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205337gn1jaazgj47jnfcf.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Duang！这样你不仅得到了一个可以在浏览器中支持 emoji 符号的基本网页，而且还知道了如何简单地实现它。你可以随意的在<a href="https://github.com/laurenorsini/Emoji-Everywhere" target="_blank" rel="noopener">我的 GitHub</a> 中查看这个教程，并且可以克隆这些实际的文件而不只是看看这些截图。</p><p>题图来自于<a href="http://getemoji.com/" target="_blank" rel="noopener">得到 Emoji</a>； Lauren Orsini 截图。</p><hr><p>via: <a href="http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-window" target="_blank" rel="noopener">http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-window</a><br>publish: <a href="https://linux.cn/article-4961-1.html" target="_blank" rel="noopener">https://linux.cn/article-4961-1.html</a></p><p>作者：<a href="http://readwrite.com/author/lauren-orsini" target="_blank" rel="noopener">Lauren Orsini</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过 GitHub 将它们嵌入到网页和其他项目中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/01/205325gyj2l10yn2zxgm4y.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。&lt;/p&gt;
&lt;p&gt;现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近&lt;a href=&quot;https://blog.twitter.com/2014/open-sourcing-twitter-emoji-for-everyone&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开源了&lt;/a&gt;他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Emoji" scheme="https://fsslc.github.io/tags/Emoji/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 怎样在 Linux 系统中恢复已删除文件</title>
    <link href="https://fsslc.github.io/2015/02/25/Translate-Undelete-Files-on-Linux-Systems/"/>
    <id>https://fsslc.github.io/2015/02/25/Translate-Undelete-Files-on-Linux-Systems/</id>
    <published>2015-02-25T04:51:50.000Z</published>
    <updated>2020-03-02T06:03:41.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105434g7z0wrwdh76fdw3d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。</p><a id="more"></a><p>这里将解释它是如何工作的。在一个文件系统中，有一个叫做 <code>文件分配表</code> 的东西，这个表跟踪文件在存储单元（如硬盘， MicroSD 卡，闪存驱动器等等）中的位置。当一个文件被删除，文件系统将会在<code>文件分配表</code>中执行以下两个任务之一：这个文件在<code>文件分配表</code>上的条目被标记为 “自由空间” 或删除<code>文件分配表</code>里这个文件的条目，且将相应的空间被标记为自由空间 。现在，如果有一个新的文件需要被放置在一个存储单元上，操作系统将会把这个文件放置到标记为空位的地方。在新文件被写入到这个空位后，被删除的文件就彻底消失了。当需要恢复一个已经删除的文件时，用户绝对不能再对任何文件进行操作，因为假如该文件对应的“空位”被占用，这个文件就永远也不能恢复了。</p><h3 id="恢复软件是如何工作的？"><a href="#恢复软件是如何工作的？" class="headerlink" title="恢复软件是如何工作的？"></a>恢复软件是如何工作的？</h3><p>大多数的文件系统（在删除文件时）只是标记空间为空白。在这些文件系统下，恢复软件查看<code>文件分配表</code>这个文件，然后复制被删除的文件到另外的存储单元中。假如该文件被复制到其它需要恢复的被删除的存储单元中，那么用户将有可能会失去那个所需的删除文件。</p><p>文件系统很少会擦除<code>文件分配表</code>中的条目。假如文件系统真的这样做了， 这便是恢复软件在恢复文件了。恢复软件在存储单元中扫描文件头，所有文件都拥有一个特殊的编码字符串，它们位于文件的最前面，也被叫做 <code>魔法数字</code>。例如，一个编译的 JAVA 类文件的魔法数字在十六进制中是“CAFEBABE”。所以，假如要恢复该类型的文件，恢复软件会查找 “CAFEBABE” 然后复制文件到另一个存储单元。一些恢复软件可以查找某种特殊的文件类型。若用户想恢复一个 PDF 文件，则恢复软件将会查找十六进制的魔法数字 “25504446”，这恰恰是 ASCII 编码中的 “%PDF”。恢复软件将会查找所有的魔法数字，然后用户可以选择恢复哪个已删除的文件。</p><p>假如一个文件的部分被覆写了，则整个文件就会被损坏。通常这个文件可以被恢复，但是其中的内容可能已经没有什么用处。例如，恢复一个已损坏的 JPEG 文件将会是无意义的，因为图片查看器不能从这个损坏的文件产生一幅图片。因此，即使用户拥有了这个文件，该文件也将毫无用处。</p><h3 id="设备的位置："><a href="#设备的位置：" class="headerlink" title="设备的位置："></a>设备的位置：</h3><p>在我们继续之前，下面的一些信息将会对指引恢复软件找到正确的存储单元起到一定的帮助。所有的设备均挂载在 <code>/dev/</code> 目录下。操作系统赋予每个设备的名称（并不是管理员给予每个分区或设备的名称）遵循一定的命名规律。</p><p>第一个 SATA 硬盘的第二个分区的名称将会是 sda2。名称的第一个字母暗示了存储类型，在这里指的是 SATA，但字母 “s” 也可能指的是 SCSI、 FireWire（火线端口）或 USB。第二个字母 “d” 指的是 disk(硬盘)。第三个字母指的是设备序数，即字母 “a” 指的是第一个 SATA 而 “b” 指的是第二个。最后的数字代表分区。没有分区数字的设备名代表该设置的所有分区。对于上面的例子，对应的名称为 sda 。作为命名的第一个字母还可能是 “h” ，这对应 PATA 硬盘（IDE）。</p><p>以下为命名规律的一些例子。假如一个用户有一个 SATA 硬盘（sda），这个设备有 4 个分区- sda1、 sda2、 sda3 和 sda4 。该用户删除了第三个分区，但直到格式化第四个分区之前，第四个分区名 sda4 都将保留不变。然后该用户插入了一个带有一个分区 - 即sdb1- 的 usb 存储卡（sdb），又增加了一个带有一个分区 -hda1- 的 IDE 硬盘 ，接着该用户又增加了一个 SCSI 硬盘 - sdc1 。接着用户移除了 USB 存储卡（sdb）。现在，SCSI 硬盘的名称仍然为 sdc，但如果这个 SCSI 被移除接着再被插入，则它的名称将变为 sdb。虽然还有其他的存储设备存在， 那个 IDE 硬盘的名称仍会有一个 “a”， 因为它是第一个 IDE 硬盘，IDE 设备的命名与 SCSI、 SATA、 FireWire 和 USB 设备要分开计数。</p><h3 id="使用-TestDisk-进行恢复："><a href="#使用-TestDisk-进行恢复：" class="headerlink" title="使用 TestDisk 进行恢复："></a>使用 TestDisk 进行恢复：</h3><p>每个恢复软件有其不同的功能，特征及支持的不同文件系统。下面是一些关于 使用 TestDisk  在各种文件系统中恢复文件的指南。</p><h4 id="FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-3-4："><a href="#FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-3-4：" class="headerlink" title="FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4："></a>FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4：</h4><p>TestDisk 是一个运行在 Linux、 *BSD、 SunOS、 Mac OS X、 DOS 和 Windows 等操作系统下的开源的自由软件。 TestDisk 可以从下面的链接中找到 ：<a href="http://www.cgsecurity.org/wiki/TestDisk" target="_blank" rel="noopener">http://www.cgsecurity.org/wiki/TestDisk</a>。TestDisk 也可以通过键入 <code>sudo apt-get install testdisk</code> 来安装。TestDisk 有着许多的功能，但这篇文章将只关注恢复文件这个功能。</p><p>使用 root 权限从终端中打开 TestDisk 可以通过键入 <code>sudo testdisk</code> 命令。</p><p>现在， TestDisk 命令行应用将会被执行。终端的显示将会改变。TestDisk 询问用户它是否可以保留日志，这完全由用户决定。假如一个用户正从系统存储中恢复文件，则不必保留日志。可选择的选项有“生成”、 “追加” 和 “无日志”。假如用户想保留日志，则日志将会保留在该用户的主目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105436uwecycts99wwsy9c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在接着的屏幕中，存储设备以 <code>/dev/*</code>的方式被罗列出来。对于我的系统，系统的存储单元为 <code>/dev/sda</code>，这意味着我的存储单元为 一个 SATA硬盘（sd）且它是第一个硬盘（a）。每个存储单元的容量以 Gigabyte（千兆字节）为单位显示的。使用上下键来选择一个存储设备然后点击进入。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105439itbspn7drs6san5r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下一屏显示出一个列有分区表（也叫做分区映射表）的清单。正如文件有<code>文件配置表</code>，分区有着分区表。分区是存储设备上的分段。例如在几乎所有的 Linux 系统中，至少存在两种分区类型 - EXT3/4 和 Swap 。每一个分区表将会在下面被简要地描述。TestDisk 并不支持所有类型的分区表，所以这并不是完整的列表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105441pakd3jd7fihfdaxj.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>Intel</strong> - 这类分区表在 Windows 系统和许多的 Linux 系统中非常普遍，它也常常称作 MBR 分区表。</li><li><strong>EFI GPT</strong> - 这种类型的分区表通常用在 Linux 系统中。对于 Linux 系统，这种分区表是最为推荐的， 因为逻辑分区或扩展分区的概念并不适用于 GPT (GUID Partition Table) 分区表。 这意味着，如果每个分区中有一个 Linux 系统，一个 Linux 用户可以从多种类型的 Linux 系统中进行多重启动。当然使用 GPT 分区表还有其他的优势，但那些已超出了本文的讨论范围。</li><li><strong>Humax</strong> - Humax 分区映射表适用于韩国公司 Humax 生产的设备。</li><li><strong>Mac</strong> -  Apple 分区映射表 (APM) 适用于 Apple 的设备。</li><li><strong>None</strong> - 某些设备并没有分区表。例如，许多 Subor 游戏控制台不使用分区映射表。如果一个用户试图以其它分区表类型从这类设备中恢复文件，用户就会困扰 TestDisk 为何找卟到任何的文件系统或者文件。</li><li><strong>Sun</strong> - Sun 分区表适用于 Sun 系统。</li><li><strong>Xbox</strong> -Xbox 适用于使用 Xbox 分区映射表的存储设备。</li></ul><p>假如用户选择了 “Xbox” ，尽管他的系统使用了 GPT 分区表， 那么 TestDisk 将不能找到任何分区或文件系统。假如 TestDisk 按照用户的选择执行，则它可能猜测错误。（下面的图片显示的是当分区表类型错误时的输出）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105443izh5h604yhqe6e5d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当用户为他们的设备选择了正确的选项，则在下一屏中，选择 “高级” 选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105445a6ld97gdq99sz5g7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在，用户将看到一个列有用户存储设备中所有的文件系统或分区的列表。假如用户选择了错误的分区映射表，则在这一步中用户就将会知道他们做出了错误的选择。假如没有错误，通过移动文字光标来高亮选择含有被删除文件的分区。使用 左右键来高亮位于终端底部的 “列表”。接着，按下回车确认。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105447ovkm1kvmzp2mx5cg.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>新的一屏便会呈现出列有文件和目录的列表。那些白色的文件名就是未被删除的文件，而红色的文件名是那些已被删除的文件。最右边的一列是文件的名称，从右到左方向的接着一列是文件的创建日期，再往左的一列是文件的大小（以 byte/ 比特为单位），最左边带有“-”，“d” ,“r”, “w” 和”x”的一列则代表的是文件的权限情况。“d” 表示该文件为一个目录，其他的权限术语与本文关系不大。在列表的最顶端以“.”代表的一项表示当前目录，第二行以”..”代表的一项表示当前目录的上级目录，所以用户可以通过选择目录所在行到达该目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105454tz8xhlx1hh10plhx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>举个例子，我想进入”Xaiml_Dataset” 目录，该目录基本上由被删除的文件组成。通过按键盘上的 “c”键，我将恢复文件 “computers.xaiml”，接着我被询问选择一个目标目录，当然，我应该放置该文件到另一个分区中。现在，当我在我的家目录时，按下了“c”键。（选择目标目录时）哪个目录被高亮并没有什么影响，当前目录就是目标目录，在屏幕的上方，将会显示“复制完成”的消息。在我的家目录中便会有一个名为”Xaiml_Dataset”的目录，里面里有一个 Xaiml 文件。 假如我在更多的已删除文件上按“c” 键，则这些文件将会被放置到新的文件夹中而无需再向我询问目标目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105458r4d1dt34tq6h264j.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105502w2eaueg8bgoa828t.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当这些步骤完成后，重复按“q”键直到看到正常的终端模样。目录”Xaiml_Dataset” 只能被 root 用户访问。为了解决这个问题，使用 root 权限改变该目录及其子目录的权限。做完这些后，文件便被恢复了且用户可以访问它们。</p><h3 id="特别的-ReiserFS："><a href="#特别的-ReiserFS：" class="headerlink" title="特别的 ReiserFS："></a>特别的 ReiserFS：</h3><p>为了从 ReiserFS 文件系统中恢复一个文件，首先需将分区中的所有文件做一个备份。因为如果发生某些错误， 这个方法可能会引起文件丢失。接着执行下面的命令，其中 <code>DEVICE</code>指的是那些以 sda2 形式命名的设备。一些文件将被放入 lost+found 目录而其他则会保存到原先被删除的位置。 </p><pre><code class="lang-bash">reiserfsck --rebuild-tree --scan-whole-partition /dev/DEVICE</code></pre><h3 id="恢复被某个程序打开的删除文件："><a href="#恢复被某个程序打开的删除文件：" class="headerlink" title="恢复被某个程序打开的删除文件："></a>恢复被某个程序打开的删除文件：</h3><p>假设用户意外地删除了一个文件，且该文件被某个程序打开。虽然在硬盘中该文件被删除了，但这个程序正使用着位于 RAM 中的该文件的副本。幸好，我们有两种简单的解决方法来恢复该文件。</p><p>假如这个软件有保存功能，如文本编辑器，则用户可以重新保存该文件，这样，文本编辑器可以将该文件写入硬盘中。</p><p>假设在音乐播放器中有一个 MP3 文件，而该音乐播放器并不能保存该 MP3 文件，则这种情形下需要比先前花更多的时间来恢复文件。不幸的是，这种方法并不能保证在所有的系统和应用中有效。首先，键入下面的命令。</p><pre><code class="lang-bash">lsof -c smplayer | grep mp3</code></pre><p>上面的命令会列出所有由 smplayer 使用的文件，这个列表由 <code>grep</code> 命令通过管道搜索 mp3 。命令的输入类似于下面：</p><pre><code class="lang-bash">smplayer  10037 collier  mp3    169r      8,1  676376  1704294 /usr/bin/smplayer</code></pre><p>现在，键入下面的命令来直接从 RAM（在 Linux 系统中，<code>/proc/</code>映射到 RAM）中恢复文件，并复制该文件到选定的文件夹中。其中 <code>cp</code> 指的是复制命令，输出中的数字 10037 来自于进程数，输出中的数字 169 指的是文件描述符，”~/Music/“为目标目录，最后的 “music.mp3” 为用户想恢复的文件的名称。</p><pre><code class="lang-bash">cp /proc/10037/fd/169 ~/Music/music.mp3</code></pre><h3 id="真正的删除："><a href="#真正的删除：" class="headerlink" title="真正的删除："></a>真正的删除：</h3><p>为确保一个文件不能被恢复，可以使用一个命令来 “擦除” 硬盘。擦除硬盘实际上是向硬盘中写入无意义的数据。例如，许多擦除程序向硬盘中写入零，随机字母或随机数据。不会有空间被占用或丢失，擦除程序只是对空位进行重写覆盖。假如存储单元被文件占满而没有空余空间，则所有先前被删除的文件将会消失而不能恢复。</p><p>擦除硬盘的目的是确保隐私数据不被他人看见。举个例子，一个公司可能预订了一些新的电脑，总经理决定将旧的电脑卖掉，然而，新的电脑拥有者可能会看到公司的一些机密或诸如信用卡号码，地址等顾客信息。幸好，公司的电脑技术人员可以在卖掉这些旧电脑之前，擦除这些硬盘。</p><p>为了安装擦除程序 secure-delete，键入 <code>sudo apt-get install secure-delete</code>,这个命令将会安装一个包含 4 个程序的程序集，用以确保被删除的文件不能被恢复。</p><ul><li>srm - 永久删除一个文件。使用方法： <code>srm -f ./secret_file.txt</code></li><li>sfill - 擦除空白空间。使用方法: <code>sfill -f /mount/point/of/partition</code></li><li>sswap - 擦除 swap 空间。使用方法: <code>sswap -f /dev/SWAP_DEVICE</code></li></ul><p>假如电脑实际去清除那些删除的文件，那么就需要花费更长的时间去执行删除任务。将某些空间标记为空位是快速且容易的，但使得文件永远消失需要花费一定的时间。例如，擦除一个存储单元，可能需要花费几个小时的时间（根据磁盘容量大小）。总之，现在的系统工作的就挺好，因为即便用户清空了垃圾箱，他们仍然有另一次机会来改变他们当初的想法（或错误）。</p><hr><p>via: <a href="http://www.linux.org/threads/undelete-files-on-linux-systems.4316/" target="_blank" rel="noopener">http://www.linux.org/threads/undelete-files-on-linux-systems.4316/</a><br>public: <a href="https://linux.cn/article-4938-1.html" target="_blank" rel="noopener">https://linux.cn/article-4938-1.html</a></p><p>作者：<a href="http://www.linux.org/members/devyncjohnson.4843/" target="_blank" rel="noopener">DevynCJohnson</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201502/25/105434g7z0wrwdh76fdw3d.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="文件恢复" scheme="https://fsslc.github.io/tags/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/"/>
    
      <category term="TestDisk" scheme="https://fsslc.github.io/tags/TestDisk/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 使用 APT-mirror 四步配置 Ubuntu 本地软件仓库</title>
    <link href="https://fsslc.github.io/2015/02/23/Translate-4-Steps-to-Setup-Local-Repository-in-Ubuntu-using-APT-mirror/"/>
    <id>https://fsslc.github.io/2015/02/23/Translate-4-Steps-to-Setup-Local-Repository-in-Ubuntu-using-APT-mirror/</id>
    <published>2015-02-23T03:17:07.000Z</published>
    <updated>2020-03-02T06:17:56.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 APT-Mirror 来制作本地源</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222342ybiibj1mj1jdrbam.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>今天，我们将向你展示如何在你的 Ubuntu 个人电脑或 Ubuntu 服务器中，直接通过 Ubuntu 官方软件仓库来配置本地软件仓库。在你的电脑中创建一个本地软件仓库有着许多的好处。假如你有许多电脑需要安装软件 、安全升级和修复补丁，那么配置一个本地软件仓库是一个做这些事情的高效方法。因为，所有需要安装的软件包都可以通过快速的局域网连接从你的本地服务器中下载，这样可以节省你的网络带宽，降低互联网接入的年度开支 …</p><p>你可以使用多种工具在你的本地个人电脑或服务器中配置一个 Ubuntu 的本地软件仓库，但在本教程中，我们将为你介绍 APT-Mirror。这里，我们将把默认的镜像包镜像到我们本地的服务器或个人电脑中，并且在你的本地或外置硬盘中，我们至少需要 <strong>120 GB</strong> 或更多的可用空间才行。 我们可以通过配置一个 <strong>HTTP</strong> 或 <strong>FTP</strong> 服务器来与本地系统客户端共享这个软件仓库。</p><p>我们需要安装 Apache 网络服务器和 APT-Mirror 来使得我们的工作得以开始。下面是配置一个可工作的本地软件仓库的步骤：</p><h3 id="1-安装需要的软件包"><a href="#1-安装需要的软件包" class="headerlink" title="1. 安装需要的软件包"></a>1. 安装需要的软件包</h3><p>我们需要从 Ubuntu 的公共软件包仓库中取得所有的软件包，然后在我们本地的 Ubuntu 服务器硬盘中保存它们。</p><p>首先我们安装一个Web 服务器来承载我们的本地软件仓库。这里我们将安装 Apache Web 服务器，但你可以安装任何你中意的 Web 服务器。对于 http 协议，Web 服务器是必须的。假如你需要配置 ftp 协议 及 rsync 协议，你还可以再分别额外安装 FTP 服务器，如  proftpd, vsftpd 等等 和 Rsync 。</p><pre><code class="lang-bash">$ sudo apt-get install apache2</code></pre><p>然后我们需要安装 apt-mirror:</p><pre><code class="lang-bash">$ sudo apt-get install apt-mirror</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222345kfzfsdrdyrq0dbbr.png" alt="apt-mirror-installation" title="">                </div>                <div class="image-caption">apt-mirror-installation</div>            </figure><p><strong>注: 正如我先前提到的，我们需要至少 120 GB 的可用空间来使得所有的软件包被镜像或下载。</strong></p><h3 id="2-配置-APT-Mirror"><a href="#2-配置-APT-Mirror" class="headerlink" title="2. 配置 APT-Mirror"></a>2. 配置 APT-Mirror</h3><p>现在，在你的硬盘上创建一个目录来保存所有的软件包。例如，我们创建一个名为 <code>/linoxide</code>的目录，我们将在这个目录中保存所有的软件包：</p><pre><code class="lang-bash">$ sudo mkdir /linoxide</code></pre><p>现在，打开文件 <strong>/etc/apt/mirror.list</strong> :</p><pre><code class="lang-bash">$ sudo nano /etc/apt/mirror.list</code></pre><p>复制下面的命令行配置到 <code>mirror.list</code>文件中并按照你的需求进行修改：</p><pre><code class="lang-bash">############# config ###################set base_path    /linoxide## set mirror_path  $base_path/mirror# set skel_path    $base_path/skel# set var_path     $base_path/var# set cleanscript $var_path/clean.sh# set defaultarch  &lt;running host architecture&gt;# set postmirror_script $var_path/postmirror.sh# set run_postmirror 0set nthreads     20set _tilde 0############## end config ##############deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse#deb http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse#deb http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse#deb-src http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse#deb-src http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverseclean http://archive.ubuntu.com/ubuntu</code></pre><p><strong>注: 你可以将上面的官方镜像服务器网址更改为离你最近的服务器的网址，可以通过访问 <a href="https://launchpad.net/ubuntu/+archivemirrors" target="_blank" rel="noopener">Ubuntu Mirror Server</a>来找到这些服务器地址。假如你并不太在意镜像完成的时间，你可以沿用默认的官方镜像服务器网址。</strong></p><p>这里，我们将要镜像最新和最大的 Ubuntu LTS 发行版 —- 即 Ubuntu 14.04 LTS (Trusty Tahr) —- 的软件包仓库，所以在上面的配置中发行版本号为 trusty 。假如我们需要镜像 Saucy 或其他的 Ubuntu 发行版本，请修改上面的 trusy 为相应的代号。</p><p>现在，我们必须运行 apt-mirror 来下载或镜像官方仓库中的所有软件包。</p><pre><code class="lang-bash">sudo apt-mirror</code></pre><p>从 Ubuntu 服务器中下载所有的软件包所花费的时间取决于你和镜像服务器之间的网络连接速率和性能。这里我中断了下载，因为我已经下载好了 …</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222346n1bcve3ytotgjct5.png" alt="downloading-packages" title="">                </div>                <div class="image-caption">downloading-packages</div>            </figure><h3 id="3-配置网络服务器"><a href="#3-配置网络服务器" class="headerlink" title="3.配置网络服务器"></a>3.配置网络服务器</h3><p>为了使得其他的电脑能够访问这个软件仓库，你需要一个Web服务器。你也可以通过 ftp 来完成这件事，但我选择使用一个Web服务器因为在上面的步骤 1 中我提及到使用Web服务器。因此，我们现在要对 Apache 服务器进行配置:</p><p>我们将为我们本地的软件仓库目录 建立一个到 Apache 托管目录 —- 即 <code>/var/www/ubuntu</code> —- 的符号链接。</p><pre><code class="lang-bash">$ sudo ln -s /linoxide /var/www/ubuntu$ sudo service apache2 start</code></pre><p>上面的命令将允许我们从本地主机(localhost) —- 即 <a href="http://127.0.0.1(默认情况下" target="_blank" rel="noopener">http://127.0.0.1(默认情况下</a>) —-  浏览我们的镜像软件仓库。</p><h3 id="4-配置客户端"><a href="#4-配置客户端" class="headerlink" title="4. 配置客户端"></a>4. 配置客户端</h3><p>最后，我们需要在其他的电脑中添加软件源，来使得它们可以从我们的电脑中取得软件包或软件仓库。为达到此目的，我们需要编辑 <code>/etc/apt/sources.list</code> 文件并添加下面的命令：</p><pre><code class="lang-bash">$ sudo nano /etc/apt/sources.list</code></pre><p>添加下面的一行到<code>/etc/apt/sources.list</code>中并保存。</p><pre><code class="lang-bash">deb http://192.168.0.100/ubuntu/ trusty main restricted universe</code></pre><p><strong>注: 这里的 192.168.0.100 是我们的服务器电脑的局域网 IP 地址，你需要替换为你的服务器电脑的局域网 IP 地址</strong></p><pre><code class="lang-bash">$ sudo apt-get update</code></pre><p>最终，我们完成了任务。现在，你可以使用<code>sudo apt-get install packagename</code> 命令来从你的本地 Ubuntu 软件仓库中安装所需的软件包，这将会是高速的且消耗很少的带宽。</p><hr><p>via: <a href="http://linoxide.com/ubuntu-how-to/setup-local-repository-ubuntu/" target="_blank" rel="noopener">http://linoxide.com/ubuntu-how-to/setup-local-repository-ubuntu/</a><br>public: <a href="https://linux.cn/article-4926-1.html" target="_blank" rel="noopener">https://linux.cn/article-4926-1.html</a></p><p>作者：<a href="http://linoxide.com/author/arunp/" target="_blank" rel="noopener">Arun Pyasi</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 APT-Mirror 来制作本地源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201502/22/222342ybiibj1mj1jdrbam.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ubuntu" scheme="https://fsslc.github.io/tags/Ubuntu/"/>
    
      <category term="APT-mirror" scheme="https://fsslc.github.io/tags/APT-mirror/"/>
    
  </entry>
  
</feed>

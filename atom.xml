<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FLC</title>
  
  <subtitle>Wir müssen wissen, wir werden wissen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fsslc.github.io/"/>
  <updated>2020-03-01T14:44:35.305Z</updated>
  <id>https://fsslc.github.io/</id>
  
  <author>
    <name>FSSlc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Python 软件包来处理较为复杂的 JSON 文件</title>
    <link href="https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/"/>
    <id>https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/</id>
    <published>2019-12-16T08:04:26.000Z</published>
    <updated>2020-03-01T14:44:35.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Python 软件包来处理较为复杂的 JSON 文件</p></blockquote><p>最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的<br>JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。</p><a id="more"></a><h2 id="复杂-json-示例"><a href="#复杂-json-示例" class="headerlink" title="复杂 json 示例"></a>复杂 json 示例</h2><p>下面展示的是一个较为复杂的 JSON 数据，这里列出只是展示一个较为复杂的 JSON 数据会怎么复杂。</p><pre><code class="lang-json">[    // 一个 data group 根数据库的示例    {        // 首先是激活条件        &quot;active&quot;: {            &quot;ref-library&quot;: &quot;&quot;,            &quot;ref-library_name&quot;: &quot;&quot;,            &quot;ref-value&quot;: &quot;&quot;,            &quot;ref_path&quot;: &quot;&quot;,            &quot;type&quot;: &quot;Condition_Default&quot;        },        // 接着是它包含的键值对，可包含多个，这里只显示一个        &quot;items&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;enum_list&quot;: null,                &quot;max&quot;: null,                &quot;min&quot;: null,                &quot;name&quot;: &quot;periodic_dimension&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;int_array&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/periodic_dimension&quot;,                &quot;value&quot;: &quot;0,0,0&quot;            }        ],        // 然后是它包含的子数据库，可能会嵌套        &quot;librarys&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;items&quot;: [                    {                        &quot;active&quot;: {                            &quot;ref-library&quot;: &quot;&quot;,                            &quot;ref-library_name&quot;: &quot;&quot;,                            &quot;ref-value&quot;: &quot;&quot;,                            &quot;ref_path&quot;: &quot;&quot;,                            &quot;type&quot;: &quot;Condition_Default&quot;                        },                        &quot;enum_list&quot;: null,                        &quot;max&quot;: null,                        &quot;min&quot;: null,                        &quot;name&quot;: &quot;SAT_MODEL&quot;,                        &quot;show&quot;: {                            &quot;show_on_interface&quot;: false                        },                        &quot;type&quot;: &quot;string&quot;,                        &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel/SAT_MODEL&quot;,                        &quot;value&quot;: &quot;model.sat&quot;                    }                ],                &quot;librarys&quot;: [],                &quot;name&quot;: &quot;CADModel&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;Library_Fixed&quot;,                &quot;uid&quot;: &quot;{b717c641-4145-44ac-8468-efb7afa451f1}&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel&quot;            }        ],        // 最后是 data group 的额外属性        &quot;name&quot;: &quot;CartesianGeometry&quot;,        &quot;show&quot;: {            &quot;show_name&quot;: &quot;CartesianGeometry&quot;,            &quot;show_on_interface&quot;: true        },        &quot;type&quot;: &quot;Library_Fixed&quot;,        &quot;uid&quot;: &quot;{909515c3-d978-4021-943b-0d6e7fc3136d}&quot;,        &quot;unique_name&quot;: &quot;/CartesianGeometry&quot;    },    // 后面再添加类似的其他 data group]</code></pre><h2 id="Python-标准库中对-json-数据的处理"><a href="#Python-标准库中对-json-数据的处理" class="headerlink" title="Python 标准库中对 json 数据的处理"></a>Python 标准库中对 json 数据的处理</h2><p>在 Python 标准库中，自带 json 模块，可以使用 <code>import json</code> 来使用它。</p><p>主要的函数有如下几个：</p><ul><li><code>json.dumps</code>：将 Python 对象序列化为 json 字符串</li><li><code>json.dump</code>：将 Python 对象序列化为 json 对象</li><li><code>json.loads</code>：将 json 字符串导入为 Python 对象</li><li><code>json.load</code>：将 json 对象导入为 Python 对象</li></ul><p>另外，<code>json</code> 模块还提供一个命令行接口 <code>json.tool</code>，可以在终端中使用，常用的例子如下：</p><pre><code class="lang-bash">$ echo &#39;{&quot;json&quot;: &quot;obj&quot;}&#39; | python -m json.tool{    &quot;json&quot;: &quot;obj&quot;}</code></pre><p>另外最为常见的使用场景是读入 json 文件的数据，然后经过修改，再将 json 数据写回 json 文件中。</p><p>下面的代码就展示这两个常用的使用场景：</p><pre><code class="lang-python"># 打开文件将 json 数据读入 data_json 对象中with open(modelFile) as f:    data_json = json.load(f)# 打开新文件，将 data_json 数据写入新的 json 文件中with open(modModleFile, &#39;w&#39;) as f:    f.write(json.dumps(data_json, indent=2))</code></pre><h2 id="常见处理-JSON-的-Python-软件包"><a href="#常见处理-JSON-的-Python-软件包" class="headerlink" title="常见处理 JSON 的 Python 软件包"></a>常见处理 JSON 的 Python 软件包</h2><p>针对上面我们的需求，需要对复杂 JSON 数据做处理，所以就在网上进行了相关的搜索。<br>针对 JSON 数据的筛选，搜索后知道有个 <code>JSONPath</code> 的提议，仿照<br>XPath 的语法来查询 JSON 数据。</p><p>然后就根据 JSONPath 这个关键字在 PyPI 中搜索都了一些软件包，下面简单罗列一下：</p><h3 id="dpath"><a href="#dpath" class="headerlink" title="dpath"></a>dpath</h3><p>主页：<a href="https://www.github.com/akesterson/dpath-python" target="_blank" rel="noopener">https://www.github.com/akesterson/dpath-python</a><br>特点：使用类型 XPath 的语法来对复杂 json 数据做查询<br>优点：如果熟悉 XPath 的话，可以快速上手<br>缺点：无法做复杂的模糊查询，需要知道大致路径来获取数据</p><h3 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h3><p>主页：www.ultimate.com/phil/python/#jsonpath<br>特点：是对上面 jsonPath 提议的一个实现，经过测试发现，相比于后面提及的这些软件，它的查询效率最高<br>优点：查询效率高，单文件的实现<br>缺点：缺乏文档，开发久远；但还在持续更新</p><h3 id="jsonpath2"><a href="#jsonpath2" class="headerlink" title="jsonpath2"></a>jsonpath2</h3><p>主页：<a href="https://pypi.org/project/jsonpath2/" target="_blank" rel="noopener">https://pypi.org/project/jsonpath2/</a><br>特点：是对上面 jsonPath 提议的一个实现，有  ANTLR v4 的语法支持，可以生成 antlr 语法解析<br>优点：支持 antlr 语法<br>缺点：文档太少，只是 jsonPath 的又一个实现，特点不突出</p><h3 id="jsonpath-rw"><a href="#jsonpath-rw" class="headerlink" title="jsonpath-rw"></a>jsonpath-rw</h3><p>主页：<a href="https://github.com/kennknowles/python-jsonpath-rw" target="_blank" rel="noopener">https://github.com/kennknowles/python-jsonpath-rw</a><br>特点：提供健壮的实现，在 Python 2.7, 3.4, 3.5, 3.6, 3.7, pypy 和 pypy3 上都测试过； 实现早，开发者多（15），GitHub 上的星多（434）；<br>优点：开发者多，将 jsonPath 表达式当做第一类对象<br>缺点：无法对数据做复杂的筛选</p><h3 id="jsonpath-rw-ext"><a href="#jsonpath-rw-ext" class="headerlink" title="jsonpath-rw-ext"></a>jsonpath-rw-ext</h3><p>主页：<a href="https://github.com/sileht/python-jsonpath-rw-ext" target="_blank" rel="noopener">https://github.com/sileht/python-jsonpath-rw-ext</a><br>特点：对上面的 jsonpath-rw 做了一些扩展，尤其是对筛选的支持<br>优点：支持筛选<br>缺点：文档不是太详细，<a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">筛选似乎只支持 list</a></p><h3 id="jsonpath-ng"><a href="#jsonpath-ng" class="headerlink" title="jsonpath-ng"></a>jsonpath-ng</h3><p>主页：<a href="https://github.com/h2non/jsonpath-ng" target="_blank" rel="noopener">https://github.com/h2non/jsonpath-ng</a><br>特点：结合了上面 jsonpath-rw 和 jsonpath-rw-ext 的能力，是  jsonpath-rw 的一个 fork<br>优点：具有上面两个包的功能，才能使用；文档详细<br>缺点：扩展的使用有点不太方便</p><p>在查找到了这些软件包后，我针对它们都进行了一些测试，最后测试后发现，在查询方面， jsonpath 这个包的解析速度最快。</p><blockquote><p>注：同时引入 jsonpath 和  jsonpath-rw-ext 会引起冲突，我的解决办法是只安装  jsonpath-rw-ext ，将 jsonpath 的单文件实现直接放入代码中，要使用时再引入。</p></blockquote><p>下面回到整体，介绍如何对复杂 JSON 数据进行查询、筛选和修改。</p><h2 id="如何查询复杂-json-数据"><a href="#如何查询复杂-json-数据" class="headerlink" title="如何查询复杂 json 数据"></a>如何查询复杂 json 数据</h2><p>经过了上面的搜索，简单来说可以直接使用上面的多个软件包，然后按照 JsonPath 的语法来对复杂数据进行查询。</p><p>下面是 JsonPath 的提议，摘自上面提及的<a href="https://goessner.net/articles/JsonPath/" target="_blank" rel="noopener">网址</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">JSONPath</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">代表根对象</td></tr><tr><td style="text-align:center"><code>@</code></td><td style="text-align:center">代表当前对象</td></tr><tr><td style="text-align:center"><code>.</code> 或 <code>[]</code></td><td style="text-align:center">取孩子操作</td></tr><tr><td style="text-align:center"><code>..</code></td><td style="text-align:center">递归搜索后代</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">通配符，代表所有对象</td></tr><tr><td style="text-align:center"><code>[]</code></td><td style="text-align:center">取下标操作，在 JSON 中，它是自带的数组操作</td></tr><tr><td style="text-align:center"><code>[,]</code></td><td style="text-align:center">表示去其中的任意一个</td></tr><tr><td style="text-align:center"><code>[start:end:step]</code></td><td style="text-align:center">数组切片操作</td></tr><tr><td style="text-align:center"><code>?()</code></td><td style="text-align:center">执行筛选操作</td></tr><tr><td style="text-align:center"><code>()</code></td><td style="text-align:center">脚本表达式，不常用</td></tr></tbody></table></div><h2 id="如何筛选复杂-json-数据"><a href="#如何筛选复杂-json-数据" class="headerlink" title="如何筛选复杂 json 数据"></a>如何筛选复杂 json 数据</h2><p>基于前面的搜索，如果要实现对复杂 json 数据的筛选功能，当前就只能使用上面的 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> ，其中 <code>jsonpath-ng</code> 的筛选功能来自于 <code>jsonpath-rw-ext</code>，所以在最后的解决方案中，我直接使用了 <code>jsonpath-rw-ext</code> 来做复杂筛选。</p><p>在使用时，为了支持变量值的替换，可能还需要使用转义符。</p><p>另外，在做筛选时，可以利用 jsonPath 中 <code>..</code> <code>@</code> 等运算符来做模糊筛选。</p><p>具体的使用方法可以参考上面两个软件包的主页。这里就不再介绍。</p><p>下面重点介绍如何修改 json 数据。</p><h2 id="如何修改复杂-json-数据"><a href="#如何修改复杂-json-数据" class="headerlink" title="如何修改复杂 json 数据"></a>如何修改复杂 json 数据</h2><p>基于上面的说明，我们知道可以使用上面的这些软件包来查询复杂 json ，但是对于如何修改数据，这些软件的文档中都没有太多的涉及。</p><p>另外根据我做的这个任务的需求，可能还需要在对 json 数据做了筛选后，再对筛选到的数据做修改。</p><p><code>python-jsonpath-rw</code> GitHub 主页上的 <a href="https://github.com/kennknowles/python-jsonpath-rw/issues/21" target="_blank" rel="noopener">issue 21</a> 上有类似的说明，但自己根据上的说明去实现时，感觉无法满足上面的需求，故作罢。</p><p>另外 <code>python-jsonpath-rw</code> 在代码仓库中似乎更新了一个 <code>update</code> 方法，但没有更新到 PyPI 中，所以必须下载 GitHub 的代码才能使用该功能。在最后的实现时便没有使用该功能。</p><p>最终，我在 stack overflow 上找到了一个参考的<a href="https://stackoverflow.com/questions/37646631/modify-an-element-in-a-nested-dict-given-a-path-to-it" target="_blank" rel="noopener">例子</a>：</p><pre><code class="lang-python">from jsonpath_rw import jsonpath, parsedata = {&quot;dogs&quot;:[{&quot;tail&quot;: True, &quot;properties&quot;:{&quot;test&quot;:1}}]}jsonpath_expr = parse(&quot;dogs.[0].properties&quot;)jsonpath_expr.find(data)[0].value[&#39;test&#39;] = 2print(data)# {&#39;dogs&#39;: [{&#39;tail&#39;: True, &#39;properties&#39;: {&#39;test&#39;: 2}}]}</code></pre><p>通过上面的例子我得到启发，可以使用 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> 包的筛选功能，再使用上面例子中类型的做法来达到筛选并修改特定键值的目的，这样我的需求就可以解决了。</p><p>在经过测试后，最终用来修改 input 模板文件中给定键值对的代码如下：</p><pre><code class="lang-python">import jsonimport jsonpath_rw_extdef Modify_model(refVar, refValue, modelFile, modModleFile=&#39;run.json&#39;):    &quot;&quot;&quot;利用 jsonpath_rw_ext 库搜索 json 格式的模板文件，并修改相应的值        refVar: 需要修改的参数的名称        refValue: 修改过后参数的值        modelFile: json 格式的模板文件        modModleFile: 修改过后的 json 模板文件    &quot;&quot;&quot;    with open(modelFile) as f:        data_json = json.load(f)    parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;    jsonpath_rw_ext.parser.ExtentedJsonPathParser().parse(parse_str).find(data_json)[0].value[&#39;value&#39;] = f&#39;{refValue}&#39;    if not os.path.exists(modModleFile):        # 如果不存在文件，则直接创建空文件        # ref: https://stackoverflow.com/questions/12654772/create-empty-file-using-python        open(modModleFile, &#39;a&#39;).close()    with open(modModleFile, &#39;w&#39;) as f:        f.write(json.dumps(data_json, indent=2))</code></pre><p>上面的代码中有几点需要说明：</p><ol><li><p><code>parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;</code> 这句使用了 Python 的新语法，直接将 refVar 的值替换到字符串中，这需要 Python 3.6 才能支持。另外还转义了括号，使得这个函数更加通用；</p></li><li><p><code>jsonpath_rw_ext.parser.ExtentedJsonPathParser()</code> 这句是为了使用扩展功能才这样写的，具体的使用方法可以参考其主页章的文档；</p></li><li>根据 <a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">GitHub 上的 issue</a>，似乎筛选功能只对 list 生效，相关代码在<a href="https://github.com/h2non/jsonpath-ng/blob/master/jsonpath_ng/ext/filter.py#L42" target="_blank" rel="noopener">这里</a>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 Python 软件包来处理较为复杂的 JSON 文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的&lt;br&gt;JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="Python" scheme="https://fsslc.github.io/tags/Python/"/>
    
      <category term="JSON" scheme="https://fsslc.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>linux 下使用 matlab 的几个小提示</title>
    <link href="https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/"/>
    <id>https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/</id>
    <published>2018-07-31T09:39:30.000Z</published>
    <updated>2020-03-01T14:47:43.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux 下使用 matlab 的几个小提示</p></blockquote><p><a href="https://www.mathworks.com/help/examples/matlab/win64/MatlabLogoExample_08.png" target="_blank" rel="noopener">MATLAB LOGO</a></p><p>嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。</p><p>在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>大部分都是直接使用桌面版本来安装 matlab 的。所以先说说这种方法。</p><p>安装无外乎以下几步：</p><ol><li>下载到 iso 镜像：这个不用多说，自己找资源。</li><li>挂载或者解压：挂载使用 <code>mount</code> 命令即可。</li><li>使用命令行安装：运行目录里面的 <code>install</code> 脚本后就会出来图形界面，接下来的安装过程与 windows 下的安装过程没有什么区别了。</li><li>激活：参考资源内的说明文档。</li></ol><p>如果需要在没有桌面的 linux 中安装 matlab，则需要编辑压缩包里面的 <code>installer_input.txt</code> 和 <code>activate.ini</code> 这两个文件，具体的安装过程请参考<a href="https://blog.csdn.net/smartzmz/article/details/41823187" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="终端使用-matlab"><a href="#终端使用-matlab" class="headerlink" title="终端使用 matlab"></a>终端使用 matlab</h2><p>一般启动 MATLAB 使用如下命令：</p><pre><code class="lang-bash">matlab -nodesktop -nodisplay</code></pre><p>跟启动相关的命令主要有如下几个：</p><ol><li><p><strong>-nodesktop</strong>: 启动 jvm (Jave Virtual Machine)，不启动 desktop， 但 help 界面，preferences 界面等仍可通过 cmdline 调出，即 jvm 启动但不启动 desktop，可以启动其他显示； 但是 matlab 不会在 cmd history 记录本次执行的命令。</p></li><li><p><strong>-nodisplay</strong>: 启动 jvm，不启动 desktop，不启动任何显示相关，忽略任何 DISPLAY 环境变量； 即 jvm 启动但不能显示。</p></li><li><p><strong>-nojvm</strong>: 不启动 jvm，则与之相关的一切活动将无法进行，包括图形界面显示，help 界面，preferences界面等，即 jvm 不启动故不能显示。</p></li><li><p><strong>-nosplash</strong>: 只是不显示启动时的log画面，jvm，desktop等正常启动</p></li></ol><p>如果想在让在终端中实现画图，一般需要做以下两步：</p><ol><li>使用 <code>matlab -nodesktop</code> 来启动 matlab；</li><li>在脚本中添加 <code>figure(&#39;Visible&#39;,&#39;off&#39;);</code> 这样的句子来抑制画图窗口的弹出。</li><li>可以使用 print 来保存图片。例如如下的命令：<pre><code class="lang-matlab">print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-dpng&#39;);print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-depsc&#39;);</code></pre>记得要提前使用 <code>mkdir</code> 创建好在上级目录，图片名称的次级目录如果不存在，matlab 会自动创建。</li></ol><h2 id="matlab-使用-gpu"><a href="#matlab-使用-gpu" class="headerlink" title="matlab 使用 gpu"></a>matlab 使用 gpu</h2><p>matlab 里面对 gpu 的使用做了封装，如果需要使用 NVIDIA 的 gpu ， 一般需要安装 Bumblebee， 然后使用 <code>optirun</code> 来运行。具体可以参考如下几个链接：</p><ol><li><a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/NVIDIA_Optimus</a></li><li><a href="https://wiki.archlinux.org/index.php/Bumblebee" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Bumblebee</a></li></ol><p>matlab 里面可以通过 <code>opengl info</code> 来查看使用了什么 gpu。</p><h2 id="几个常见问题"><a href="#几个常见问题" class="headerlink" title="几个常见问题"></a>几个常见问题</h2><p>下面的几个问题常常与 matlab 自带的几个动态链接库有关。一般把这些库备份后，将系统中安装的对应包链接到 matlab 里面就可以了。具体的问题见下面的详细解释</p><h3 id="帮助系统没有-CSS-渲染效果"><a href="#帮助系统没有-CSS-渲染效果" class="headerlink" title="帮助系统没有 CSS 渲染效果"></a>帮助系统没有 CSS 渲染效果</h3><p>字体问题常常与 <code>libfreetype.so</code> 这个动态链接库有关。所以解决办法无非以下几步：</p><pre><code class="lang-bash">sudo mv /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6.BAK # 备份sudo ln -sf /usr/lib64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 # 链接</code></pre><h3 id="libGL-error-for-MATLAB"><a href="#libGL-error-for-MATLAB" class="headerlink" title="libGL error for MATLAB"></a><a href="https://askubuntu.com/questions/841785/libgl-error-for-matlab" target="_blank" rel="noopener">libGL error for MATLAB</a></h3><p>解决办法：</p><pre><code class="lang-bash">ln -sf /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /opt/MATLAB/XXXXX(R2014b)/sys/os/glnxa64/libstdc++.so.6 # 或者执行cd MATLAB_ROOT/sys/os/glnxa64/sudo mv libstdc++.so.6 libstdc++.so.6.old</code></pre><h3 id="无法使用并行工具箱"><a href="#无法使用并行工具箱" class="headerlink" title="无法使用并行工具箱"></a>无法使用并行工具箱</h3><p>解决办法同上，链接系统的 <code>libstdc++.so.6</code> 这个动态库。</p><h3 id="matlab-无法使用系统中文字体"><a href="#matlab-无法使用系统中文字体" class="headerlink" title="matlab 无法使用系统中文字体"></a>matlab 无法使用系统中文字体</h3><p>参考： <a href="https://bbs.archlinux.org/viewtopic.php?id=231299" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=231299</a></p><pre><code class="lang-bash">cd  /usr/local/MATLAB/R2017b # Matlab directorycd bin/glnxa64mkdir excludemv libfreetype* excludecd ../../sys/os/glnxa64mkdir excludemv libstdc++.so.6* exclude</code></pre><p>或者跟上面的解决方法类似，备份文件后做链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;linux 下使用 matlab 的几个小提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mathworks.com/help/examples/matlab/win64/MatlabLogoExample_08.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MATLAB LOGO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。&lt;/p&gt;
&lt;p&gt;在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="matlab" scheme="https://fsslc.github.io/tags/matlab/"/>
    
      <category term="linux" scheme="https://fsslc.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>减小 VBoX 虚拟磁盘大小</title>
    <link href="https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/"/>
    <id>https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/</id>
    <published>2016-12-18T08:28:48.000Z</published>
    <updated>2020-03-01T14:40:28.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何使用 VBOX 自带工具减小虚拟磁盘大小</p></blockquote><p>由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ,WPS,MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。</p><p>虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。</p><a id="more"></a><p>问题来了，便开始上网搜索方法。在<a href="http://my.oschina.net/tsl0922/blog/188276" target="_blank" rel="noopener">开源中国的一个博客</a>里面找到了方法，下面进行简单的记录。</p><p>根据博主的文章，要达到减小 VBox 虚拟磁盘的大小，主要有两个步骤：</p><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>首先需要在虚拟机里面的系统下做碎片整理。</p><p>对于 Linux 系统，可以使用：</p><pre><code class="lang-bash">sudo dd if=/dev/zero of=/EMPTY bs=1Msudo rm -f /EMPTY</code></pre><p>对于 Windows 系统，则需要使用 <a href="http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx" target="_blank" rel="noopener">Sysinternals Suite</a>，点击上面的链接可以到微软的页面下进行下载。下载解压后，通过 CMD ，运行：</p><pre><code class="lang-bash">sdelete -z c:</code></pre><p>等待进度完成即可。然后关闭虚拟机。</p><h2 id="压缩磁盘"><a href="#压缩磁盘" class="headerlink" title="压缩磁盘"></a>压缩磁盘</h2><p>如果虚拟磁盘是 <code>Virtual Box</code> 自家的 <code>VDI</code> 格式，则只需要先通过终端到达含有后缀为 <code>.vdi</code> 的文件所在的那个目录，再执行：</p><pre><code class="lang-bash">VBoxManage modifyhd win7.vdi --compact</code></pre><p>这样就可以达到压缩磁盘的目的。</p><p>如果虚拟磁盘是 <code>VMDK</code> 的格式，则可以使用 vmware 自带的 <code>vmware-vdiskmanager</code> 工具，具体命令如下：</p><pre><code class="lang-bash">vmware-vdiskmanager -k disk.vmdk</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如何使用 VBOX 自带工具减小虚拟磁盘大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ,WPS,MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。&lt;/p&gt;
&lt;p&gt;虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="VBox" scheme="https://fsslc.github.io/tags/VBox/"/>
    
  </entry>
  
  <entry>
    <title>在 Archlinux 中安装 Opendx</title>
    <link href="https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/"/>
    <id>https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/</id>
    <published>2016-12-15T08:02:31.000Z</published>
    <updated>2020-03-01T14:42:08.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Archlinux 中安装 Opendx</p></blockquote><p><a href="http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/">前面</a> 我说过， opendx 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 <code>sudo apt install dx dxsamples</code> 安装这个可视化软件。</p><p>现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。</p><a id="more"></a><p><strong>UPDATE</strong><br>现在下面那个久未更新的镜像网站已经不存在了，而我也没有保存那个安装包，所以只好自己想办法了。还好 Debian 还在维护这两个包，所以我就借鉴它的编译脚本来写成适合 Archlinux 编译的脚本。目前通过我自己编写的编译脚本编译这两个软件包基本可以使用，但还是有点小问题：</p><ol><li>Debian 维护者里面的那个仓库中，包含很多与 Debian 系统相关的补丁，我只清理了一点，有些可能没有清理干净；</li><li>有时会占用 100% 的 CPU，到时直接杀掉那个进程即可(PS: <code>htop</code>这个工具非常好用，推荐大家使用)；</li><li>在 dx 的窗口中仍然不能直接达到 samples 目录。</li></ol><hr><p>自己编译又不想安装那么多的依赖，最后在<a href="http://mirror.lzjtu.edu.cn/archlinux/community/os/x86_64/" target="_blank" rel="noopener">国内某个久未更新的镜像网站</a> 中找到了别人打包好的二进制文件，下载那个名为 opendx-4.4.4-2.pkg.tar.gz 的安装包后，可以直接使用命令 sudo pacman -U opendx-4.4.4-2.pkg.tar.gz 进行安装。</p><p>这样安装后，可能会有些依赖问题，例如我的系统里面会报 netcdf 和 tiff 的动态链接库找不到，而我已经安装了它们，所以只需要创建一些软链接就可以了。</p><pre><code class="lang-bash">sudo ln -s /usr/lib/libnetcdf.so.12.0.0 /usr/lib/libnetcdf.so.4sudo ln -s /usr/lib/libtiff.so.5.2.4 /usr/lib/libtiff.so.3</code></pre><hr><p>最后附上我改写的编译脚本和相关的源文件：</p><pre><code class="lang-bash">链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxt</code></pre><p>如果只需要编译这两个包，只需要下载 <code>Opendx_AUR_build_scripts.zip</code> 这个压缩包就行了。另外的东西是用来编译 AFEPack 的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Archlinux 中安装 Opendx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/&quot;&gt;前面&lt;/a&gt; 我说过， opendx 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 &lt;code&gt;sudo apt install dx dxsamples&lt;/code&gt; 安装这个可视化软件。&lt;/p&gt;
&lt;p&gt;现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="Opendx" scheme="https://fsslc.github.io/tags/Opendx/"/>
    
      <category term="Archlinux" scheme="https://fsslc.github.io/tags/Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 构建 AFEPack 镜像</title>
    <link href="https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/"/>
    <id>https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/</id>
    <published>2016-12-15T07:24:09.000Z</published>
    <updated>2020-03-01T14:41:25.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦</p></blockquote><p>先前写了一篇<a href="http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/">如何在 Ubuntu 安装 AFEPack 的教程</a>，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在<a href="https://hub.docker.com/r/xywei/afebackpack/" target="_blank" rel="noopener">这里</a>。先前也知道 docker 掀起的热潮，但一直没有学习它。</p><a id="more"></a><p>关于 docker 的学习，网上一搜一大堆。我自己买了本 杨保华、戴王剑、曹亚仑 编著的《Docker 技术入门与实践》，利用一个下午学会了基本操作，后面的有些功能自己用不到就没有再深究下去。闲话少说，下面进入正题。</p><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p>首先，要构建 docker 镜像，你需要安装 <code>docker</code>，具体安装过程见官网或者 Google 、Baidu 一下。</p><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><p>要想实现自动构建 Docker 镜像，就需要编写 Dockerfile。只要知道 Dockerfile 编写时需要用的一些指令和编译安装的命令就可以了。</p><p>下面是我最后写好的 Dockerfile 。我在下面用中文添加注释，原文件参考我 GitHub 上的项目<a href="https://github.com/FSSlc/AFEPackDocker" target="_blank" rel="noopener">AFEPackDocker</a>。</p><pre><code class="lang-bash">FROM ubuntu:16.04                                   # 以 ubuntu 16.04 作为镜像的基础系统MAINTAINER FSSlc, liuchang011235 AT gmail DOT com   # 维护者的相关信息# install essential packagesRUN \                                               # RUN 后面跟上要运行的命令即可  mkdir -p /root/Pkg &amp;&amp; \  # use aliyun&#39;s mirror for better download speed  sed -i &#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&#39; /etc/apt/sources.list &amp;&amp; \  apt-get update &amp;&amp; \  apt-get install -y make automake autoconf wget build-essential \  libdeal.ii-dev mpi-default-dev nano # libhypre-dev trilinos-all-dev petsc-dev --no-install-recommends## set some env varibles                            # 设置与 AFEPack 相关的环境变量COPY env.txt /root/Pkg/env.txt ## prepare AFEPack easymeshRUN \cd /root/Pkg &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/AFEPack-snapshot.tar.gz &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/source_code/easymesh.c.gz &amp;&amp; \tar -xzf ./AFEPack-snapshot.tar.gz -C /root/Pkg/  &amp;&amp; \gunzip easymesh.c.gz &amp;&amp; \## compile and install AFEPackcat /root/Pkg/env.txt &gt;&gt; /root/.bashrc &amp;&amp; . /root/.bashrc &amp;&amp; \cd /root/Pkg/AFEPack &amp;&amp; \                           # 将 ubuntu 中安装的 deal.ii 库文件改名ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.g.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.g.so &amp;&amp; \ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.so.8.1.0  /usr/lib/x86_64-linux-gnu/libdeal_II.so &amp;&amp; \aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; \env EXTRA_INCDIR=&quot;-I/usr/include/deal.II/&quot; EXTRA_LIBDIR=&quot;-L/usr/lib/x86_64-linux-gnu/&quot; ./configure &amp;&amp; \# make -j8 &amp;&amp; make install                      # 下面分开编译 AFEPack，直接编译会报错，镜像就编译不下去了cd ./template/ &amp;&amp; make -j8 &amp;&amp; cd ../library/ &amp;&amp; make -j8 &amp;&amp; make install &amp;&amp; \cd ../example/ &amp;&amp; make -j8 &amp;&amp; \## compile and install easymeshcd /root/Pkg/ &amp;&amp; \gcc -o easymesh easymesh.c -lm &amp;&amp; \mv ./easymesh /usr/local/bin/ &amp;&amp; \## do some clean work                           # 清理一些不需要的文件，减小镜像大小rm easymesh.c AFEPack-snapshot.tar.gz env.txt &amp;&amp; \rm -rf /var/lib/apt/lists/*CMD [&quot;/bin/bash&quot;]</code></pre><p><strong>UPDATE</strong><br>为了能够本地编译安装 AFEPack 的镜像，我编写了两个 Dockerfile，一个是直接使用<br>Ubuntu 16.04 里面 8.1 版本的 deal.II，另一个是在 Ubuntu 14.04 里使用源码编译的 deal.II 6.3.1，请自行选择。</p><p><strong>UPDATE 20181103</strong><br>好久没有更新了，最近在做 docker 相关的事。了解到 docker 可以进行所谓的多阶段构建了。这个功能可以进一步地减小镜像的大小，所以我今天就尝试了一下，效果还是很明显的。从原来的 <code>1.07GB</code> 减少到现在的 <code>573MB</code>。 </p><p>另外 AFEPack 的包做了一些更新，居然默认 <code>std=c++14</code> 了！所以原来的 Dockerfile 可能不能使用了，所以我顺便做了更新。从构建的结果看，<code>step-7</code> 这个例子跑不通，这次更新后的 Dockerfile 都有这个问题，它们获取的<br>AFEPack 源码都是今天我从官网下载的。但是我放在 docker Hub 的镜像可以运行。。。</p><h2 id="使用-docker-build-命令构建镜像"><a href="#使用-docker-build-命令构建镜像" class="headerlink" title="使用 docker build 命令构建镜像"></a>使用 <code>docker build</code> 命令构建镜像</h2><p>编写完 Dockerfile 后，便可以构建镜像了。使用的命令是：</p><pre><code class="lang-bash">sudo docker build  -t afepack:v0 .</code></pre><p>其中 <code>-t</code> 选项是指定编译后镜像的名称，即所谓的 <code>tag</code> 。</p><p>具体使用时，一般运行：</p><pre><code class="lang-bash">docker run -ti -v $HOME/Pkg:/opt afepack:v0 bash</code></pre><p>上面的命令将启动一个容器，其中的 <code>-v</code> 选项将把主机中的 <code>$HOME/Pkg</code> 目录挂载到容器中的 <code>/opt</code> 目录，这样我们便可以在 <code>$HOME/Pkg</code> 中让主机和容器之间进行数据交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先前写了一篇&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/&quot;&gt;如何在 Ubuntu 安装 AFEPack 的教程&lt;/a&gt;，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在&lt;a href=&quot;https://hub.docker.com/r/xywei/afebackpack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。先前也知道 docker 掀起的热潮，但一直没有学习它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="Docker" scheme="https://fsslc.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 AFEPack</title>
    <link href="https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/</id>
    <published>2015-11-03T06:02:55.000Z</published>
    <updated>2020-03-01T14:40:53.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 AFEPack</p></blockquote><p><strong>Update</strong><br>相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考<a href="https://hub.docker.com/r/fsslc/afepack/" target="_blank" rel="noopener">我的说明</a>进行安装。</p><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）</p><a id="more"></a><h2 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h2><p>首先，下载好 deal. II、AFEPack、mpich（非必须） 这几个软件的安装包。</p><p>其中的 deal. II 和 AFEPack 可以到我的百度网盘去下载，这个是我从我大学同学的未来的师兄那里获得的，而那位师兄的老师正是这个软件包的作者 李若 老师。由于高版本的 deal. II 版本经过了许多的修改，且鉴于 AFEPack 几乎停滞的开发状态，我们采用的是 deal. II 的 6.3.1 版本。而 mpich 则可以到官网去下载最新的稳定版本。</p><p>相关软件的下载地址为：</p><p>deal.II 和 AFEPack : 链接: <a href="https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g</a> 密码: utxt<br>mpich : <a href="http://www.mpich.org/downloads/" target="_blank" rel="noopener">http://www.mpich.org/downloads/</a></p><p>下载好这些包后，将他们进行解压备用。</p><h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>接下来，安装一些必要的软件。</p><p>首先安装 boost 库。这个可以用命令行，也可以使用 synaptic (新得立) 这个图形化的包管理软件来安装。命令行需要使用的命令为：</p><pre><code class="lang-bash">sudo apt-get install libboost-dbg  libboost-all-dev</code></pre><p>接着安装自动化产生 <code>makefile</code> 的相关工具。其中 <code>aclocal</code> 已经被包括在 <code>autoconf</code> 里了。</p><pre><code class="lang-bash">sudo apt-get install autoconf automake</code></pre><p>接着安装编译器，由于某些原因，编译 AFEPack 时，用高版本(如 4.8)的 gcc 和 g++ 会出错，所以需要安装对应的低版本的包。这里安装 4.6 版本。</p><pre><code class="lang-bash">sudo apt-get install gcc-4.6 g++-4.6 gfortran#  降低 gcc，g++ 的版本，可以在后面改回来cd /usr/binsudo ln -s gcc-4.6 gccsudo ln -s g++-4.6 g++</code></pre><h2 id="安装-deal-II"><a href="#安装-deal-II" class="headerlink" title="安装 deal. II"></a>安装 deal. II</h2><p>根据李若老师的解释，他选用这个包的原因是看上了这个包里面 <code>lac</code> 、 <code>base</code> 中的代码，即关于基础线性代数相关的代码写得很好，所以才采用了 deal. II 。所以我们可以只编译里面的部分文件，当然如果你不在乎占用一点额外的磁盘空间，也可以选择完整安装。</p><p>关于安装路径，下面以我的安装位置 <code>/home/lc/Pkg/deal.II</code> 来举例，其中 <code>/home/lc</code> 为我的家目录，可以对应地修改，也可以安装到其他路径，如 <code>/usr/local/deal.II</code> 等。</p><p>首先，进入解压后的 deal. II 目录，我的在 <code>/home/lc/Pkg/deal.II</code> 。 然后在终端中依次输入下面的命令，其中 # 后的内容为注释，可以忽略。</p><pre><code class="lang-bash">cd /home/lc/Pkg/deal.II # 进入解压后的 deal.II 目录./configuremake -j4 lac base contrib # -j 选项是启用多线程，以此来加快编译的速度，后面的数字最好与你机子的 CPU 的线程数相同或更少# 或者使用 make all 来完整安装</code></pre><p>经过一段时间后(根据你的机器配置而定)，就把需要的文件编译好了。下面需要做一些软链接。在以前安装时，我尝试过直接把 deal. II 编译后产生的相应目录加在系统变量中，然后再安装 AFEPack，结果 AFEPack 不能找到 deal. II 的头文件，所以还是做个链接。具体的原因我也不清楚，可能需要问作者本人。</p><p>下面是我做链接时使用的命令，请相应做些修改：</p><pre><code class="lang-bash">cd /usr/local/includesudo ln -s ~/Pkg/deal.II/deal.II/include/ .sudo ln -s ~/Pkg/deal.II/lac/include/lac/ .sudo ln -s ~/Pkg/deal.II/base/include/base/ .sudo ln -s ~/Pkg/deal.II/contrib/tbb/tbb22_20090809oss/include/tbb/ .# 这里的 tbb22_20090809oss 可能会有所不同，但一般这个目录都是以 tbb 开头的，可用 Tab 键来自动补全；# 最后的 `.` 代指当前目录 ，以下类型cd /usr/local/libsudo ln -s ~/Pkg/deal.II/lib/lib* .</code></pre><h2 id="安装-mpich"><a href="#安装-mpich" class="headerlink" title="安装 mpich"></a>安装 mpich</h2><p><strong>这个不是必须的，除了 mpich，也可以直接安装<br>OpenMPI</strong>。</p><p>这个的安装可以根据解压后文件夹中的指示来操作，一般都是如下几个命令：</p><pre><code class="lang-bash">cd /home/lc/Pkg/mpich2/ # 进入 mpich2 解压后的目录，根据你自己的情况调整./configuremake -j4sudo make install</code></pre><p>这样就安装好了 mpich。</p><p>当然，我们也可以直接使用软件源里面的 mpich，这样或许更省事些。</p><h2 id="安装-AFEPack"><a href="#安装-AFEPack" class="headerlink" title="安装 AFEPack"></a>安装 AFEPack</h2><p>现在进行 AFEPack 的安装。首先利用 autotools 套件中的软件(即 aclocal，autoconf，automake 等)来自动生成 configure 文件。使用的命令如下：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPackaclocalautoconfautomake --add-missing</code></pre><p>然后把</p><pre><code class="lang-bash"># AFEPack templeteexport AFEPACK_TEMPLATE_PATH=&quot;/home/lc/Pkg/AFEPack/template/triangle:/home/lc/Pkg/AFEPack/template/rectangle:/home/lc/Pkg/AFEPack/template/interval:/home/lc/Pkg/AFEPack/template/twin_triangle:/home/lc/Pkg/AFEPack/template/tetrahedron:/home/lc/Pkg/AFEPack/template/twin_tetrahedron:/home/lc/Pkg/AFEPack/template/four_tetrahedron&quot;</code></pre><p>加到 <code>～/.bashrc</code> 文件中，然后使用 <code>source ~/.bashrc</code> 来使更改生效。</p><p>接着对 AFEPack 进行配置和编译。</p><pre><code class="lang-bash">./configuremake -j4</code></pre><p>编译期间会报错停掉，报 mpi.h 找不到。这时仍然继续，输入：</p><pre><code class="lang-bash">make install</code></pre><p>然后进入 AFEPack 目录下的 template 目录，来编译模板。我使用的命令为：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPack/templatemake</code></pre><p>现在来编译关于 mpi 的静态文件。这里需要 MPI 的相关库，这里我们使用的是 mpich。</p><pre><code class="lang-bash">~/Pkg/AFEPack/library/mpimake -j4</code></pre><p>example 子目录下有一些实用的工具，我们现在来编译它们。</p><pre><code class="lang-bash">cd ~/Pkg/AFEPack/examplemake -j4</code></pre><p>最后执行下面的命令来使得 <code>ld</code> 能够找到 <code>AFEPack.so</code> 等静态库。</p><pre><code class="lang-bash">cd ～/Pkg/AFEPacksudo ldconfig</code></pre><p>至此， AFEPack 的安装就结束了。</p><p>如果你在安装期间有什么问题，可以来询问我，我尽量帮忙。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 AFEPack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;br&gt;相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考&lt;a href=&quot;https://hub.docker.com/r/fsslc/afepack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的说明&lt;/a&gt;进行安装。&lt;/p&gt;
&lt;h2 id=&quot;系统准备&quot;&gt;&lt;a href=&quot;#系统准备&quot; class=&quot;headerlink&quot; title=&quot;系统准备&quot;&gt;&lt;/a&gt;系统准备&lt;/h2&gt;&lt;p&gt;我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="Deal. II" scheme="https://fsslc.github.io/tags/Deal-II/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下 Opendx Data Explorer 的字体问题</title>
    <link href="https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/"/>
    <id>https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/</id>
    <published>2015-11-03T05:51:25.000Z</published>
    <updated>2020-03-01T14:33:04.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解决在 Ubuntu 下 Opendx Data Explorer 的字体问题</p></blockquote><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近一直在学习使用李若老师的 AFEPack 软件包，其中这个包输出的图形格式一般为 Opendx，但据网上的一些评论，它基本上处于类似渡渡鸟的境地了。但自己能力有限，还不能更改它输出为 Vtk 等现在主流的图像格式，所以还是先用着吧。</p><p>现在读取 opendx 格式的软件好像就只有 <code>Opendx Data Explorer</code> 了。自从 IBM 开源了 opendx 后，就没有多少官方的支持，现在它的开发主要由一个名为 <code>Visualization and Imagery Solutions, Inc.</code> 的公司负责。在 Ubuntu 中，可以直接通过软件源安装编译好的 dx 软件。</p><p>安装后，可以在终端中使用 dx 命令来启动 Opendx Data Explorer。但终端始终会出现类似如下的警告：</p><pre><code class="lang-bash">Cannot convert string &quot;-*-helvetica-bold-r-*-*-16-*&quot; to type FontStruct</code></pre><p>于是乎，便利用网络来搜索答案。下面是解决办法。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>搜索的过程就不说了，反正还是 Google 强。</p><p>最开始说的是先确认下有没有安装这些字体。一般是先建议你安装两个字体包，使用的命令是：</p><pre><code class="lang-bash">sudo apt-get install xfonts-75dpi xfonts-100dpi</code></pre><p>它们默认是安装在 <code>/usr/share/fonts/X11/</code> 目录中。</p><p>然后可以使用下面的命令来查看是否安装了上面警告中的字体：</p><pre><code class="lang-bash">xlsfonts -fn &quot;-*-helvetica-bold-r-*-*-10-*-*-*-*-*-*-*&quot;</code></pre><p>其中的 <code>*</code> 都是一些匹配。可以类似地修改匹配格式。</p><p>但是安装完后还是没有解决问题。于是又搜。</p><p>最后在<a href="http://www.linuxquestions.org/questions/linux-software-2/error-message-regarding-fonts-in-grace-943919/" target="_blank" rel="noopener">这个网页</a>里面找到了解决办法。</p><p>原来，在安装完这些字体后，我们还需要一些设置，具体的命令是：</p><pre><code class="lang-bash">xset +fp /usr/share/fonts/X11/75dpi/xset +fp /usr/share/fonts/X11/100dpi/</code></pre><p>至于上面的命令具体执行了什么步骤，可以 <code>man xset</code> 。随后问题便解决了。遇到类似的问题（例如某个软件中文乱码，呈现出方框），似乎都可以这样解决。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>最后说说我对 OpenDX 的看法吧。</p><p>刚开始入门的时候，总感觉资料很少，这个软件不太好使用。相比于 ViSit 或 ParaView 等软件，dx 太难用了，什么都要自己定义，而且找到的资料也不是很多；所以对它的印象不好。</p><p>现在由于导师分配的任务，我需要使用 AFEPack 来求解方程，最后需要用 dx 来展示结果。通过这几天的摸索，感觉了它的强大。现在基本明白了为什么李若老师喜欢这种数据格式和这个软件的原因了。说到底，还是需要折腾。</p><p>至于学习资料。安装好 dx 后，一般可以在 <code>/usr/share/dx/samples</code> 找到示例代码；文档说明的话，可以看 <code>/usr/share/dx/html</code> 里面的东西，这些 html 文件里面包含的内容其实很多的。一步一步的看下去还是有很多收获的。</p><p>至于 <code>Visualization and Imagery Solutions, Inc.</code> 公司出的那本名为 <code>OpenDX---Paths to Visualization</code> 的书，我觉得自带的 html 文件内容或许更多一些，当然看看还是不错的。</p><p>以前我在<a href="http://web.engr.oregonstate.edu/~mjb/opendx/" target="_blank" rel="noopener">这个网站</a>找到了很多关于 Opendx 的资料，现在仍然推荐去看看那里的东西。</p><p>TODO： 通过 Ubuntu 仓库安装 dx 软件有一个问题：</p><p>在经过一段时间的使用后， dx 会吃掉 100% 的 CPU。根据我的搜索，现在还没有找到解决办法，自编译的 dx 就好像没有这个问题。后面再搜索一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在 Ubuntu 下 Opendx Data Explorer 的字体问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="Font" scheme="https://fsslc.github.io/tags/Font/"/>
    
      <category term="Opendx" scheme="https://fsslc.github.io/tags/Opendx/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 FEniCS</title>
    <link href="https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/</id>
    <published>2015-10-12T04:32:13.000Z</published>
    <updated>2020-03-01T14:41:48.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 FEniCS</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://fenicsproject.org/pub/tutorial/sphinx1/_static/fenics_banner.png" alt="FEniCS Logo" title="">                </div>                <div class="image-caption">FEniCS Logo</div>            </figure><p><strong>Update 20161212</strong><br>现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看<a href="https://fenics-containers.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">官网的说明</a>。这样就可以少折腾了。</p><a id="more"></a><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近导师去开了个会议，从其他人那里打听到有很多人都在 FEniCS 的基础上写代码了。导师她最开始认为，它是用来写 Fortran 代码的一个平台，加之她主要使用的编程语言为 Fortran，所以希望我们能够去学习一下。</p><p>第一次看到 FEniCS 这个词，应该可以追溯到我大四做毕业论文的时候。那时想找个软件来书写有限元程序，因为自己从底层开始写起太费事了。通过搜索，找到了许多软件，具体可以看看这个链接。通过试用，左右权衡，最后决定使用 deal. II 来做毕业论文。</p><p>当时对于 FEniCS 的认识是：</p><pre><code>它是用 Python 写的，自己对 Python 不熟悉，查找到的资料不是很齐全；当时自己尝试从 PPA 安装了 FEniCS， 但程序运行地不是很顺利；</code></pre><p>现在，通过这一两天的使用，觉得这货实在是太简单了，用 Python 根据它自定义的 UFL 语言来自动生成可执行代码，最后使用 OpenGL 和 VTK 来生成图形和 vtu 文件。当然，方便的代价就是编译过程的时间有点长；毕竟鱼和熊掌是不能兼得的。</p><p>PS：FEnics 还可以与 C, C++, Fortran, 或 MATLAB 交互，具体可以看<a href="https://hplgit.github.io/fenics-mixed/doc/web/index.html" target="_blank" rel="noopener">这里的文档</a>。</p><h2 id="FEniCS-的安装过程"><a href="#FEniCS-的安装过程" class="headerlink" title="FEniCS 的安装过程"></a>FEniCS 的安装过程</h2><h3 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h3><p>首先我的安装平台为 ubuntu 14.04, 64 位，但从自己安装的过程来看，其他系统应该也可以安装，大体步骤是一致的，具体可以看官网的说明。</p><p>特别说明：对于使用 Windows 系统的同学，你就别指望能够完美安装和运行 FEniCS 了，官网上说了， Windows 平台的安装包没有更新了。所以还是尽快学习一些 Linux 或 Unix 这类系统的使用方法吧。命令行真的非常好用，包管理器的使用也非常方便。</p><p>下面我是通过 Anaconda 这个 Python 集成环境来安装 FEniCS 的，所以你需要安装好 Anaconda。可以到官网的下载页面 去下载相应版本的安装包，这里我们使用的是 Anaconda-2.3.0-Linux-x86_64.sh，至于安装，该页面里有提示，这里不赘述了。</p><p>另外，在运行 FEniCS 的程序之前，需要安装好 gcc g++ gfortran 等编译器，不然会出现意想不到的错误。可以使用如下的命令来安装这些软件：</p><pre><code class="lang-bash">sudo apt-get install build-essential gfortran</code></pre><h3 id="具体的安装过程"><a href="#具体的安装过程" class="headerlink" title="具体的安装过程"></a>具体的安装过程</h3><p>根据官网的解释，有如下几种方法可以来进行安装：</p><ol><li>直接添加 PPA 来进行下载。</li></ol><p>但安装尝试后，会引入许多不必要的安装依赖如 texlive 等，为了不污染系统，所以没有采取这种方法。当然，如果你订阅了他们的 PPA，这种方式能够使你获取到最新的更新。如果你没有‘洁癖’，可以尝试这种方法。</p><p>(注： 最近(2015-12) 找到了如何在安装有 Texlive 发型包的情况下，不再引起上面需要安装 texlive 依赖的方法，具体请参考<a href="http://www.latexstudio.net/archives/4017.html" target="_blank" rel="noopener">这篇文章</a>的最后一段，但请自己制作 dummy package，因为在安装时，可能会出现一点问题，请根据问题的描述更改相应的配置文件。 )</p><ol><li>通过下载脚本编译。</li></ol><p>通过下面的这个脚本来从源文件编译安装 FEniCS。</p><pre><code class="lang-bash">curl -s http://fenicsproject.org/fenics-install.sh | bash</code></pre><p>但在尝试的过程中，总是提示 SSL 认证失败。无果，所以放弃了这种方法。</p><ol><li>直接下载虚拟机镜像来运行。</li></ol><p>将镜像导入 Vbox 后，大概用了 7G 的空间，镜像里的系统使用的是 Lubuntu，感觉很精简，但没有自己安装的 Ubuntu 体验好。又考虑到空间占用的原因，亦弃之。</p><ol><li>通过 Anaconda 来安装 FEniCS。</li></ol><p>可以根据<a href="https://github.com/juanlu001/fenics-recipes" target="_blank" rel="noopener">这个网页</a>的指导安装。</p><p>这个 github 仓库里面用的命令是：</p><pre><code class="lang-bash">conda install fenics mkl --channel juanlu001</code></pre><p>而官网里面使用的命令是：</p><pre><code class="lang-bash">conda create --name fenics27 python=2.7source activate fenics27conda install fenics --channel juanlu001</code></pre><p>我最开始是根据 Github 上的命令来安装的。而再给其他人安装的时候，我特别使用了官网了给出的命令，现在大致知道了它们之间的区别：前者是直接将 FEniCS 安装到 Anaconda 的目录里面，而后者是创建了一个新的环境，单独进行了安装。考虑到简洁性，我推荐第二个命令。</p><p>在终端中依次输入上面的命令后，会大概下载 300M 左右的安装包，最后安装完毕会有 4G 左右(加上 Anaconda 原来安装后的文件)。经过一段漫长的等待后，FEniCS 就安装好了。</p><h2 id="安装后需要做的事"><a href="#安装后需要做的事" class="headerlink" title="安装后需要做的事"></a>安装后需要做的事</h2><p>安装完成后，自然需要运行一下 FEniCS 自带的示例程序，它们一般在 <code>~/anaconda/envs/fenics27/share/dolfin/</code> 目录下。随便进入某个示例目录，可以有名为 <code>cpp</code> 和 <code>python</code> 的两个目录。先进入 python 这个目录试试效果。</p><p>在终端运行：</p><pre><code class="lang-bash">python filename.py # 注意请将这句中的 filename 换为具体的程序名称</code></pre><p>然后终端会报错，大致意思是没有找到 <code>dolfin</code> 这个 module。这应该是环境变量的问题，最后通过搜索，参考<a href="https://answers.launchpad.net/dolfin/+question/166153" target="_blank" rel="noopener">这里的说明</a>，我们需要将 dolfin.conf 这个文件加到 PYTHONPATH 环境变量中。命令为：</p><pre><code class="lang-bash">source &lt;PATH_TO_YOUR_DOLFIN_INSTALLATION&gt;/share/dolfin/dolfin.conf</code></pre><p>对于使用 Anaconda 安装 FEniCS 的情况，dolfin.conf 一般在 <code>~/anaconda/envs/fenics27/share/dolfin</code> 目录里。</p><p>最好是将这个上面这个命令写入你本地的 <code>.bashrc</code> 文件里面，然后用 <code>source ~/.bashrc</code> 更新环境变量。</p><p>这个做完后，总该可以运行程序了吧。可惜，还不行。你会看终端里报错，提示说某些 VTK 的动态链接库找不到，根据 Github 里的 <a href="https://github.com/Juanlu001/fenics-recipes/issues/33" target="_blank" rel="noopener">issue</a>，需要使用下面的命令将 VTK 的版本降低：</p><pre><code class="lang-bash">conda list vtkconda install &quot;vtk=5.10&quot;</code></pre><p>这样就可以运行程序了。在程序执行的开始，你可能会看到有些提示，说 MKL 库有 30 天的试用期限，要你购买。对于这种情况，Anaconda 给学校和科研机构提供有学术版的许可，只要你使用 edu 的邮箱就可以申请到, <a href="https://store.continuum.io/cshop/academicanaconda" target="_blank" rel="noopener">申请地址</a> 。</p><p>申请后，会得到一个 license 文件，将其放在 <code>~/.continuum</code> 目录下即可。</p><p>另外，我发现我自己申请的 license 同样也可以用在别人的机器上，不知这是不是一个 bug。</p><h3 id="安装后软件的学习"><a href="#安装后软件的学习" class="headerlink" title="安装后软件的学习"></a>安装后软件的学习</h3><p>关于入门，可以直接看官网的文档，例如 tutorial，The FEniCS Book, Manual。</p><p>PS： 可以到<a href="https://launchpadlibrarian.net/83776282/fenics-book-2011-10-27-final.pdf" target="_blank" rel="noopener">这里</a>下载到 The FEniCS Book。</p><p>关于这两天学习的感受：我是从 tutorial 入门的，看了过后感觉这货居然这么简单，相比于我用 deal. II 写代码，这不知要轻松多少倍。另外，tutorial 里面的例子有些代码不能运行了，应该是 dolfin(或其他组件) 更新的缘故，而文档还没有被更新。下一步继续看文档来学习。</p><p>以后深入后，再写点东西来分享。</p><p><strong>UPDATE 2018.07.31</strong><br>有几点需要更新的：</p><ol><li><p>偶然发现了这个 <a href="http://www.fenics-hpc.org" target="_blank" rel="noopener">网站</a>， 似乎是将 fenics 应用到 HPC 领域中，并且在 edx 中开了<a href="https://www.edx.org/course/high-performance-finite-element-modeling-kthx-hpfem01-1x#" target="_blank" rel="noopener">一门 MOOC</a></p></li><li><p>关于学习资源，可以看看 <a href="http://people.cs.uchicago.edu/~ridg/" target="_blank" rel="noopener">这个老师的主页</a>，里面课程中有一些 notes。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 FEniCS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://fenicsproject.org/pub/tutorial/sphinx1/_static/fenics_banner.png&quot; alt=&quot;FEniCS Logo&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;FEniCS Logo&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Update 20161212&lt;/strong&gt;&lt;br&gt;现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看&lt;a href=&quot;https://fenics-containers.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网的说明&lt;/a&gt;。这样就可以少折腾了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="FEniCS" scheme="https://fsslc.github.io/tags/FEniCS/"/>
    
      <category term="Anaconda" scheme="https://fsslc.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView</title>
    <link href="https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/</id>
    <published>2015-10-10T04:07:08.000Z</published>
    <updated>2020-03-01T14:45:05.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView</p></blockquote><h2 id="Deal-II-的安装与配置"><a href="#Deal-II-的安装与配置" class="headerlink" title="Deal. II 的安装与配置"></a>Deal. II 的安装与配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://dealii.org/developer/doxygen/deal.II/logo200.png" alt="Deal. II Logo" title="">                </div>                <div class="image-caption">Deal. II Logo</div>            </figure><a id="more"></a><h3 id="Deal-II-的安装"><a href="#Deal-II-的安装" class="headerlink" title="Deal. II 的安装"></a>Deal. II 的安装</h3><p>关于安装，有如下几种方式：</p><ol><li><p>到 dealii 的下载页面去下载打包好的文件：</p><p> 对于 Ubuntu、Mac、Debain 都已经有编译好的二进制文件，Arch、Gentoo 可以分别通过 AUR 和 Gentoo Science Overlay 来得到；</p></li><li><p>利用 docker 来生成相关的镜像，具体可以参考<a href="https://hub.docker.com/r/dealii/dealii/" target="_blank" rel="noopener">这里</a>；</p></li><li><p>基于源码安装：</p><p> 官网上推荐 <a href="https://github.com/dealii/candi" target="_blank" rel="noopener">candi</a>，也可以通过 <a href="https://spack.io/" target="_blank" rel="noopener">spack</a>来安装。</p></li></ol><p>下面是我自己的安装过程，算是一个记录吧。</p><p>下载好源文件后，进行解压，然后进入解压的目录，具体安装方法可以通过 README.md 这个文件知晓。需要注意的是 deal. II 是一套有限元 C++ 库，所以在 Linux 上面需要进行编译安装。编译时，需要使用 cmake 和 make，所以先将这两个软件安装好。<br>然后依次执行下面的命令来进行编译安装：</p><pre><code class="lang-bash">cmake -DCMAKE_INSTALL_PREFIX=/path/where/deal.II/should/be/intalled/to ..make install  # (alternatively $ make -j&lt;N&gt; install)</code></pre><p>这里需要注意的是：</p><ol><li>如果 dealii 的安装为一般用户不可写的目录，需要 <code>sudo</code> 命令；</li><li>为了加快编译的速度，在第二句中，在 make 后加上 <code>-jN</code> 参数，其中 N 最好不要超过电脑的最大 CPU 数目；</li></ol><p>执行完上面的命令后，接着就是漫长的等待了。在我的机子上 (Ubuntu 14.04, x86_64, Intel® Core™ i5-2430M CPU @ 2.40GHz × 4，SSD) 编译安装总共花了将近 40 min；一般的机子大概需要 1 个小时左右。</p><h3 id="Deal-II-的配置"><a href="#Deal-II-的配置" class="headerlink" title="Deal. II 的配置"></a>Deal. II 的配置</h3><p>首先是 将 dealii 的目录加入系统环境变量之中，只需要在 <code>~/.bashrc</code> 中加入如下几行代码即可：</p><pre><code class="lang-bash"># dealii 环境变量export PATH=/opt/deal.II:$PATHDEAL_II_DIR=/opt/deal.II</code></pre><p>在具体使用时，主要使用这三个命令：</p><pre><code class="lang-bash">cmake .make # 也可以直接使用 make release, 这样编译出来的出现运行快些make run</code></pre><p>关于 deal. II 的学习，开发者为自学者提供了详尽的文档，可以在 dealii 的下载页面里找到离线的文档，并且在 dealii 的安装目录下有文档中的示例代码；</p><p>另外，dealii 的主要开发者 Wolfgan Bangerth 还在他的教学网址上提供了讲义和授课的<a href="http://www.math.colostate.edu/~bangerth/videos.html" target="_blank" rel="noopener">视频链接</a>(不过视频在 YouTube 上)。</p><p><strong>Update 20161210</strong><br>这里只是介绍了最简单的安装，要安装额外的软件库还需要自己去安装。可以参考 <a href="https://github.com/dealii/docker-files" target="_blank" rel="noopener">这里</a> 中的命令来进行安装。当然，在 Ubuntu 、Debian 、Gento 中有官方支持的版本，如果嫌麻烦，可以直接用包管理器安装。</p><h2 id="VisIt-的安装和配置"><a href="#VisIt-的安装和配置" class="headerlink" title="VisIt 的安装和配置"></a>VisIt 的安装和配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://wci.llnl.gov/content/assets/images/simulation/computer-codes/visit/visit-home.jpg" alt="VisIt Logo" title="">                </div>                <div class="image-caption">VisIt Logo</div>            </figure><h3 id="VisIt-的安装"><a href="#VisIt-的安装" class="headerlink" title="VisIt 的安装"></a>VisIt 的安装</h3><p>安装方面，首先到<a href="https://wci.llnl.gov/simulation/computer-codes/visit/" target="_blank" rel="noopener">官网</a>的下载页面里下载相关的包，并在同一页面下载 <code>Visit install script</code> 文件，具体安装过程，可以参考同一页面的 <code>Visit install notes</code> 。</p><h3 id="VisIt-的配置"><a href="#VisIt-的配置" class="headerlink" title="VisIt 的配置"></a>VisIt 的配置</h3><p>关于配置，在 <code>~/.bashrc</code> 中加入如下几行代码来添加环境变量：</p><pre><code class="lang-bash"># visit 环境变量export PATH=/opt/visit:$PATH</code></pre><p>当然，如果你想和我一样，想为 <code>VisIt</code> 添加一个快捷方式，来达到 在系统的应用里面直接点击图标就启动软件的目的，可以按照下面方法来进行。</p><p>首先创建一个名为 <code>visit.desktop</code> 的文件，然后进行编辑，将如下的内容复制到该文件中(当然你可以进行自定义)：</p><pre><code class="lang-bash">[Desktop Entry]Version=2.8.1Type=ApplicationName=VisItGenericName=image viewerComment=VisIt is an Open Source, interactive, scalable, visualization, animation and analysis tool.Exec=/opt/visit/bin/visitTerminal=falseMimeType=image/vtk;Icon=/opt/visit/visit.jpgCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><p>注意: 上面的 Icon 后面的图片是我从 visit 官网里下载的，当然可以使用其他图片。</p><p>最后保持修改的文件，然后将该文件移动到 <code>/usr/share/applications/</code> 目录中。当然，你也可以直接在这个目录中创建这个文件。这样，你就可以在系统的应用中找到 visit 了，通过点击图标就可以启动 visit。</p><h2 id="Paraview-的安装和配置"><a href="#Paraview-的安装和配置" class="headerlink" title="Paraview 的安装和配置"></a>Paraview 的安装和配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.paraview.org/wp-content/uploads/2018/02/ParaView_Logo.svg" alt="paraview Logo" title="">                </div>                <div class="image-caption">paraview Logo</div>            </figure><h3 id="Paraview-的安装"><a href="#Paraview-的安装" class="headerlink" title="Paraview 的安装"></a>Paraview 的安装</h3><p>当然，对于各种发行版本，对应的软件仓库里面可能已经有 paraview 的二进制包了，可以直接用相应的包管理器下载安装。</p><p>下面介绍的是自己手动安装 paraview 的过程。</p><p>首先到<a href="https://www.paraview.org/" target="_blank" rel="noopener">官网</a>的下载页面上选择适合自己机子的相应压缩包并下载。然后解压，将解压的文件夹复制到需要安装的位置即可。</p><h3 id="Paraview-的配置"><a href="#Paraview-的配置" class="headerlink" title="Paraview 的配置"></a>Paraview 的配置</h3><p>关于配置，和 visit 基本相似。</p><p>首先添加环境变量：</p><pre><code class="lang-bash"># paraview 环境变量export PATH=/opt/paraview:$PATH</code></pre><p>然后制作图标；方法与上面一致，这里只列出 <code>paraview.desktop</code> 文件的内容：</p><pre><code class="lang-bash">[Desktop Entry]Version=4.2Type=ApplicationName=ParaviewGenericName=image viewerComment=ParaView is an open-source, multi-platform data analysis and visualization applicationExec=/opt/paraview/bin/paraviewTerminal=falseMimeType=image/vtk;Icon=/opt/paraview/share/icons/hicolor/96x96/apps/paraview.pngCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写这个文档的目的主要是为了进行一些纪录，好在遗忘的时候可以查看，也当做是备份。<br>有限元软件当然不止这几个，还有如 gmesh、freefem++、getfem++ 等等，这里就不介绍了。总之学习之路漫漫，吾将上下而求索。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Deal-II-的安装与配置&quot;&gt;&lt;a href=&quot;#Deal-II-的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Deal. II 的安装与配置&quot;&gt;&lt;/a&gt;Deal. II 的安装与配置&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://dealii.org/developer/doxygen/deal.II/logo200.png&quot; alt=&quot;Deal. II Logo&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;Deal. II Logo&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="Software" scheme="https://fsslc.github.io/categories/Software/"/>
    
    
      <category term="Deal. II" scheme="https://fsslc.github.io/tags/Deal-II/"/>
    
      <category term="Paraview" scheme="https://fsslc.github.io/tags/Paraview/"/>
    
      <category term="VisIt" scheme="https://fsslc.github.io/tags/VisIt/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FLC</title>
  
  <subtitle>Wir müssen wissen, wir werden wissen</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fsslc.github.io/"/>
  <updated>2020-03-01T15:42:43.027Z</updated>
  <id>https://fsslc.github.io/</id>
  
  <author>
    <name>FSSlc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Python 软件包来处理较为复杂的 JSON 文件</title>
    <link href="https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/"/>
    <id>https://fsslc.github.io/2019/12/16/Python-Deals-large-json-file-md/</id>
    <published>2019-12-16T08:04:26.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Python 软件包来处理较为复杂的 JSON 文件</p></blockquote><p>最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的<br>JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。</p><a id="more"></a><h2 id="复杂-json-示例"><a href="#复杂-json-示例" class="headerlink" title="复杂 json 示例"></a>复杂 json 示例</h2><p>下面展示的是一个较为复杂的 JSON 数据，这里列出只是展示一个较为复杂的 JSON 数据会怎么复杂。</p><pre><code class="lang-json">[    // 一个 data group 根数据库的示例    {        // 首先是激活条件        &quot;active&quot;: {            &quot;ref-library&quot;: &quot;&quot;,            &quot;ref-library_name&quot;: &quot;&quot;,            &quot;ref-value&quot;: &quot;&quot;,            &quot;ref_path&quot;: &quot;&quot;,            &quot;type&quot;: &quot;Condition_Default&quot;        },        // 接着是它包含的键值对，可包含多个，这里只显示一个        &quot;items&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;enum_list&quot;: null,                &quot;max&quot;: null,                &quot;min&quot;: null,                &quot;name&quot;: &quot;periodic_dimension&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;int_array&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/periodic_dimension&quot;,                &quot;value&quot;: &quot;0,0,0&quot;            }        ],        // 然后是它包含的子数据库，可能会嵌套        &quot;librarys&quot;: [            {                &quot;active&quot;: {                    &quot;ref-library&quot;: &quot;&quot;,                    &quot;ref-library_name&quot;: &quot;&quot;,                    &quot;ref-value&quot;: &quot;&quot;,                    &quot;ref_path&quot;: &quot;&quot;,                    &quot;type&quot;: &quot;Condition_Default&quot;                },                &quot;items&quot;: [                    {                        &quot;active&quot;: {                            &quot;ref-library&quot;: &quot;&quot;,                            &quot;ref-library_name&quot;: &quot;&quot;,                            &quot;ref-value&quot;: &quot;&quot;,                            &quot;ref_path&quot;: &quot;&quot;,                            &quot;type&quot;: &quot;Condition_Default&quot;                        },                        &quot;enum_list&quot;: null,                        &quot;max&quot;: null,                        &quot;min&quot;: null,                        &quot;name&quot;: &quot;SAT_MODEL&quot;,                        &quot;show&quot;: {                            &quot;show_on_interface&quot;: false                        },                        &quot;type&quot;: &quot;string&quot;,                        &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel/SAT_MODEL&quot;,                        &quot;value&quot;: &quot;model.sat&quot;                    }                ],                &quot;librarys&quot;: [],                &quot;name&quot;: &quot;CADModel&quot;,                &quot;show&quot;: {                    &quot;show_on_interface&quot;: false                },                &quot;type&quot;: &quot;Library_Fixed&quot;,                &quot;uid&quot;: &quot;{b717c641-4145-44ac-8468-efb7afa451f1}&quot;,                &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel&quot;            }        ],        // 最后是 data group 的额外属性        &quot;name&quot;: &quot;CartesianGeometry&quot;,        &quot;show&quot;: {            &quot;show_name&quot;: &quot;CartesianGeometry&quot;,            &quot;show_on_interface&quot;: true        },        &quot;type&quot;: &quot;Library_Fixed&quot;,        &quot;uid&quot;: &quot;{909515c3-d978-4021-943b-0d6e7fc3136d}&quot;,        &quot;unique_name&quot;: &quot;/CartesianGeometry&quot;    },    // 后面再添加类似的其他 data group]</code></pre><h2 id="Python-标准库中对-json-数据的处理"><a href="#Python-标准库中对-json-数据的处理" class="headerlink" title="Python 标准库中对 json 数据的处理"></a>Python 标准库中对 json 数据的处理</h2><p>在 Python 标准库中，自带 json 模块，可以使用 <code>import json</code> 来使用它。</p><p>主要的函数有如下几个：</p><ul><li><code>json.dumps</code>：将 Python 对象序列化为 json 字符串</li><li><code>json.dump</code>：将 Python 对象序列化为 json 对象</li><li><code>json.loads</code>：将 json 字符串导入为 Python 对象</li><li><code>json.load</code>：将 json 对象导入为 Python 对象</li></ul><p>另外，<code>json</code> 模块还提供一个命令行接口 <code>json.tool</code>，可以在终端中使用，常用的例子如下：</p><pre><code class="lang-bash">$ echo &#39;{&quot;json&quot;: &quot;obj&quot;}&#39; | python -m json.tool{    &quot;json&quot;: &quot;obj&quot;}</code></pre><p>另外最为常见的使用场景是读入 json 文件的数据，然后经过修改，再将 json 数据写回 json 文件中。</p><p>下面的代码就展示这两个常用的使用场景：</p><pre><code class="lang-python"># 打开文件将 json 数据读入 data_json 对象中with open(modelFile) as f:    data_json = json.load(f)# 打开新文件，将 data_json 数据写入新的 json 文件中with open(modModleFile, &#39;w&#39;) as f:    f.write(json.dumps(data_json, indent=2))</code></pre><h2 id="常见处理-JSON-的-Python-软件包"><a href="#常见处理-JSON-的-Python-软件包" class="headerlink" title="常见处理 JSON 的 Python 软件包"></a>常见处理 JSON 的 Python 软件包</h2><p>针对上面我们的需求，需要对复杂 JSON 数据做处理，所以就在网上进行了相关的搜索。<br>针对 JSON 数据的筛选，搜索后知道有个 <code>JSONPath</code> 的提议，仿照<br>XPath 的语法来查询 JSON 数据。</p><p>然后就根据 JSONPath 这个关键字在 PyPI 中搜索都了一些软件包，下面简单罗列一下：</p><h3 id="dpath"><a href="#dpath" class="headerlink" title="dpath"></a>dpath</h3><p>主页：<a href="https://www.github.com/akesterson/dpath-python" target="_blank" rel="noopener">https://www.github.com/akesterson/dpath-python</a><br>特点：使用类型 XPath 的语法来对复杂 json 数据做查询<br>优点：如果熟悉 XPath 的话，可以快速上手<br>缺点：无法做复杂的模糊查询，需要知道大致路径来获取数据</p><h3 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h3><p>主页：www.ultimate.com/phil/python/#jsonpath<br>特点：是对上面 jsonPath 提议的一个实现，经过测试发现，相比于后面提及的这些软件，它的查询效率最高<br>优点：查询效率高，单文件的实现<br>缺点：缺乏文档，开发久远；但还在持续更新</p><h3 id="jsonpath2"><a href="#jsonpath2" class="headerlink" title="jsonpath2"></a>jsonpath2</h3><p>主页：<a href="https://pypi.org/project/jsonpath2/" target="_blank" rel="noopener">https://pypi.org/project/jsonpath2/</a><br>特点：是对上面 jsonPath 提议的一个实现，有  ANTLR v4 的语法支持，可以生成 antlr 语法解析<br>优点：支持 antlr 语法<br>缺点：文档太少，只是 jsonPath 的又一个实现，特点不突出</p><h3 id="jsonpath-rw"><a href="#jsonpath-rw" class="headerlink" title="jsonpath-rw"></a>jsonpath-rw</h3><p>主页：<a href="https://github.com/kennknowles/python-jsonpath-rw" target="_blank" rel="noopener">https://github.com/kennknowles/python-jsonpath-rw</a><br>特点：提供健壮的实现，在 Python 2.7, 3.4, 3.5, 3.6, 3.7, pypy 和 pypy3 上都测试过； 实现早，开发者多（15），GitHub 上的星多（434）；<br>优点：开发者多，将 jsonPath 表达式当做第一类对象<br>缺点：无法对数据做复杂的筛选</p><h3 id="jsonpath-rw-ext"><a href="#jsonpath-rw-ext" class="headerlink" title="jsonpath-rw-ext"></a>jsonpath-rw-ext</h3><p>主页：<a href="https://github.com/sileht/python-jsonpath-rw-ext" target="_blank" rel="noopener">https://github.com/sileht/python-jsonpath-rw-ext</a><br>特点：对上面的 jsonpath-rw 做了一些扩展，尤其是对筛选的支持<br>优点：支持筛选<br>缺点：文档不是太详细，<a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">筛选似乎只支持 list</a></p><h3 id="jsonpath-ng"><a href="#jsonpath-ng" class="headerlink" title="jsonpath-ng"></a>jsonpath-ng</h3><p>主页：<a href="https://github.com/h2non/jsonpath-ng" target="_blank" rel="noopener">https://github.com/h2non/jsonpath-ng</a><br>特点：结合了上面 jsonpath-rw 和 jsonpath-rw-ext 的能力，是  jsonpath-rw 的一个 fork<br>优点：具有上面两个包的功能，才能使用；文档详细<br>缺点：扩展的使用有点不太方便</p><p>在查找到了这些软件包后，我针对它们都进行了一些测试，最后测试后发现，在查询方面， jsonpath 这个包的解析速度最快。</p><blockquote><p>注：同时引入 jsonpath 和  jsonpath-rw-ext 会引起冲突，我的解决办法是只安装  jsonpath-rw-ext ，将 jsonpath 的单文件实现直接放入代码中，要使用时再引入。</p></blockquote><p>下面回到整体，介绍如何对复杂 JSON 数据进行查询、筛选和修改。</p><h2 id="如何查询复杂-json-数据"><a href="#如何查询复杂-json-数据" class="headerlink" title="如何查询复杂 json 数据"></a>如何查询复杂 json 数据</h2><p>经过了上面的搜索，简单来说可以直接使用上面的多个软件包，然后按照 JsonPath 的语法来对复杂数据进行查询。</p><p>下面是 JsonPath 的提议，摘自上面提及的<a href="https://goessner.net/articles/JsonPath/" target="_blank" rel="noopener">网址</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">JSONPath</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">代表根对象</td></tr><tr><td style="text-align:center"><code>@</code></td><td style="text-align:center">代表当前对象</td></tr><tr><td style="text-align:center"><code>.</code> 或 <code>[]</code></td><td style="text-align:center">取孩子操作</td></tr><tr><td style="text-align:center"><code>..</code></td><td style="text-align:center">递归搜索后代</td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">通配符，代表所有对象</td></tr><tr><td style="text-align:center"><code>[]</code></td><td style="text-align:center">取下标操作，在 JSON 中，它是自带的数组操作</td></tr><tr><td style="text-align:center"><code>[,]</code></td><td style="text-align:center">表示去其中的任意一个</td></tr><tr><td style="text-align:center"><code>[start:end:step]</code></td><td style="text-align:center">数组切片操作</td></tr><tr><td style="text-align:center"><code>?()</code></td><td style="text-align:center">执行筛选操作</td></tr><tr><td style="text-align:center"><code>()</code></td><td style="text-align:center">脚本表达式，不常用</td></tr></tbody></table></div><h2 id="如何筛选复杂-json-数据"><a href="#如何筛选复杂-json-数据" class="headerlink" title="如何筛选复杂 json 数据"></a>如何筛选复杂 json 数据</h2><p>基于前面的搜索，如果要实现对复杂 json 数据的筛选功能，当前就只能使用上面的 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> ，其中 <code>jsonpath-ng</code> 的筛选功能来自于 <code>jsonpath-rw-ext</code>，所以在最后的解决方案中，我直接使用了 <code>jsonpath-rw-ext</code> 来做复杂筛选。</p><p>在使用时，为了支持变量值的替换，可能还需要使用转义符。</p><p>另外，在做筛选时，可以利用 jsonPath 中 <code>..</code> <code>@</code> 等运算符来做模糊筛选。</p><p>具体的使用方法可以参考上面两个软件包的主页。这里就不再介绍。</p><p>下面重点介绍如何修改 json 数据。</p><h2 id="如何修改复杂-json-数据"><a href="#如何修改复杂-json-数据" class="headerlink" title="如何修改复杂 json 数据"></a>如何修改复杂 json 数据</h2><p>基于上面的说明，我们知道可以使用上面的这些软件包来查询复杂 json ，但是对于如何修改数据，这些软件的文档中都没有太多的涉及。</p><p>另外根据我做的这个任务的需求，可能还需要在对 json 数据做了筛选后，再对筛选到的数据做修改。</p><p><code>python-jsonpath-rw</code> GitHub 主页上的 <a href="https://github.com/kennknowles/python-jsonpath-rw/issues/21" target="_blank" rel="noopener">issue 21</a> 上有类似的说明，但自己根据上的说明去实现时，感觉无法满足上面的需求，故作罢。</p><p>另外 <code>python-jsonpath-rw</code> 在代码仓库中似乎更新了一个 <code>update</code> 方法，但没有更新到 PyPI 中，所以必须下载 GitHub 的代码才能使用该功能。在最后的实现时便没有使用该功能。</p><p>最终，我在 stack overflow 上找到了一个参考的<a href="https://stackoverflow.com/questions/37646631/modify-an-element-in-a-nested-dict-given-a-path-to-it" target="_blank" rel="noopener">例子</a>：</p><pre><code class="lang-python">from jsonpath_rw import jsonpath, parsedata = {&quot;dogs&quot;:[{&quot;tail&quot;: True, &quot;properties&quot;:{&quot;test&quot;:1}}]}jsonpath_expr = parse(&quot;dogs.[0].properties&quot;)jsonpath_expr.find(data)[0].value[&#39;test&#39;] = 2print(data)# {&#39;dogs&#39;: [{&#39;tail&#39;: True, &#39;properties&#39;: {&#39;test&#39;: 2}}]}</code></pre><p>通过上面的例子我得到启发，可以使用 <code>jsonpath-rw-ext</code> 或者 <code>jsonpath-ng</code> 包的筛选功能，再使用上面例子中类型的做法来达到筛选并修改特定键值的目的，这样我的需求就可以解决了。</p><p>在经过测试后，最终用来修改 input 模板文件中给定键值对的代码如下：</p><pre><code class="lang-python">import jsonimport jsonpath_rw_extdef Modify_model(refVar, refValue, modelFile, modModleFile=&#39;run.json&#39;):    &quot;&quot;&quot;利用 jsonpath_rw_ext 库搜索 json 格式的模板文件，并修改相应的值        refVar: 需要修改的参数的名称        refValue: 修改过后参数的值        modelFile: json 格式的模板文件        modModleFile: 修改过后的 json 模板文件    &quot;&quot;&quot;    with open(modelFile) as f:        data_json = json.load(f)    parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;    jsonpath_rw_ext.parser.ExtentedJsonPathParser().parse(parse_str).find(data_json)[0].value[&#39;value&#39;] = f&#39;{refValue}&#39;    if not os.path.exists(modModleFile):        # 如果不存在文件，则直接创建空文件        # ref: https://stackoverflow.com/questions/12654772/create-empty-file-using-python        open(modModleFile, &#39;a&#39;).close()    with open(modModleFile, &#39;w&#39;) as f:        f.write(json.dumps(data_json, indent=2))</code></pre><p>上面的代码中有几点需要说明：</p><ol><li><p><code>parse_str = f&#39;$..items[?(@.unique_name=\&quot;{refVar}\&quot;)]&#39;</code> 这句使用了 Python 的新语法，直接将 refVar 的值替换到字符串中，这需要 Python 3.6 才能支持。另外还转义了括号，使得这个函数更加通用；</p></li><li><p><code>jsonpath_rw_ext.parser.ExtentedJsonPathParser()</code> 这句是为了使用扩展功能才这样写的，具体的使用方法可以参考其主页章的文档；</p></li><li>根据 <a href="https://github.com/sileht/python-jsonpath-rw-ext/issues/27" target="_blank" rel="noopener">GitHub 上的 issue</a>，似乎筛选功能只对 list 生效，相关代码在<a href="https://github.com/h2non/jsonpath-ng/blob/master/jsonpath_ng/ext/filter.py#L42" target="_blank" rel="noopener">这里</a>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 Python 软件包来处理较为复杂的 JSON 文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的&lt;br&gt;JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Python" scheme="https://fsslc.github.io/tags/Python/"/>
    
      <category term="JSON" scheme="https://fsslc.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>linux 下使用 matlab 的几个小提示</title>
    <link href="https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/"/>
    <id>https://fsslc.github.io/2018/07/31/Tips-for-using-matlab-in-linux/</id>
    <published>2018-07-31T09:39:30.000Z</published>
    <updated>2020-03-01T17:01:35.650Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>linux 下使用 matlab 的几个小提示</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.mathworks.com/help/examples/matlab/win64/MatlabLogoExample_08.png" alt="MATLAB LOGO" title="">                </div>                <div class="image-caption">MATLAB LOGO</div>            </figure><p>嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。</p><p>在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>大部分都是直接使用桌面版本来安装 matlab 的。所以先说说这种方法。</p><p>安装无外乎以下几步：</p><ol><li>下载到 iso 镜像：这个不用多说，自己找资源。</li><li>挂载或者解压：挂载使用 <code>mount</code> 命令即可。</li><li>使用命令行安装：运行目录里面的 <code>install</code> 脚本后就会出来图形界面，接下来的安装过程与 windows 下的安装过程没有什么区别了。</li><li>激活：参考资源内的说明文档。</li></ol><p>如果需要在没有桌面的 linux 中安装 matlab，则需要编辑压缩包里面的 <code>installer_input.txt</code> 和 <code>activate.ini</code> 这两个文件，具体的安装过程请参考<a href="https://blog.csdn.net/smartzmz/article/details/41823187" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="终端使用-matlab"><a href="#终端使用-matlab" class="headerlink" title="终端使用 matlab"></a>终端使用 matlab</h2><p>一般启动 MATLAB 使用如下命令：</p><pre><code class="lang-bash">matlab -nodesktop -nodisplay</code></pre><p>跟启动相关的命令主要有如下几个：</p><ol><li><p><strong>-nodesktop</strong>: 启动 jvm (Jave Virtual Machine)，不启动 desktop， 但 help 界面，preferences 界面等仍可通过 cmdline 调出，即 jvm 启动但不启动 desktop，可以启动其他显示； 但是 matlab 不会在 cmd history 记录本次执行的命令。</p></li><li><p><strong>-nodisplay</strong>: 启动 jvm，不启动 desktop，不启动任何显示相关，忽略任何 DISPLAY 环境变量； 即 jvm 启动但不能显示。</p></li><li><p><strong>-nojvm</strong>: 不启动 jvm，则与之相关的一切活动将无法进行，包括图形界面显示，help 界面，preferences界面等，即 jvm 不启动故不能显示。</p></li><li><p><strong>-nosplash</strong>: 只是不显示启动时的log画面，jvm，desktop等正常启动</p></li></ol><p>如果想在让在终端中实现画图，一般需要做以下两步：</p><ol><li>使用 <code>matlab -nodesktop</code> 来启动 matlab；</li><li>在脚本中添加 <code>figure(&#39;Visible&#39;,&#39;off&#39;);</code> 这样的句子来抑制画图窗口的弹出。</li><li>可以使用 print 来保存图片。例如如下的命令：<pre><code class="lang-matlab">print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-dpng&#39;);print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-depsc&#39;);</code></pre>记得要提前使用 <code>mkdir</code> 创建好在上级目录，图片名称的次级目录如果不存在，matlab 会自动创建。</li></ol><h2 id="matlab-使用-gpu"><a href="#matlab-使用-gpu" class="headerlink" title="matlab 使用 gpu"></a>matlab 使用 gpu</h2><p>matlab 里面对 gpu 的使用做了封装，如果需要使用 NVIDIA 的 gpu ， 一般需要安装 Bumblebee， 然后使用 <code>optirun</code> 来运行。具体可以参考如下几个链接：</p><ol><li><a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/NVIDIA_Optimus</a></li><li><a href="https://wiki.archlinux.org/index.php/Bumblebee" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Bumblebee</a></li></ol><p>matlab 里面可以通过 <code>opengl info</code> 来查看使用了什么 gpu。</p><h2 id="几个常见问题"><a href="#几个常见问题" class="headerlink" title="几个常见问题"></a>几个常见问题</h2><p>下面的几个问题常常与 matlab 自带的几个动态链接库有关。一般把这些库备份后，将系统中安装的对应包链接到 matlab 里面就可以了。具体的问题见下面的详细解释</p><h3 id="帮助系统没有-CSS-渲染效果"><a href="#帮助系统没有-CSS-渲染效果" class="headerlink" title="帮助系统没有 CSS 渲染效果"></a>帮助系统没有 CSS 渲染效果</h3><p>字体问题常常与 <code>libfreetype.so</code> 这个动态链接库有关。所以解决办法无非以下几步：</p><pre><code class="lang-bash">sudo mv /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6.BAK # 备份sudo ln -sf /usr/lib64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 # 链接</code></pre><h3 id="libGL-error-for-MATLAB"><a href="#libGL-error-for-MATLAB" class="headerlink" title="libGL error for MATLAB"></a><a href="https://askubuntu.com/questions/841785/libgl-error-for-matlab" target="_blank" rel="noopener">libGL error for MATLAB</a></h3><p>解决办法：</p><pre><code class="lang-bash">ln -sf /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /opt/MATLAB/XXXXX(R2014b)/sys/os/glnxa64/libstdc++.so.6 # 或者执行cd MATLAB_ROOT/sys/os/glnxa64/sudo mv libstdc++.so.6 libstdc++.so.6.old</code></pre><h3 id="无法使用并行工具箱"><a href="#无法使用并行工具箱" class="headerlink" title="无法使用并行工具箱"></a>无法使用并行工具箱</h3><p>解决办法同上，链接系统的 <code>libstdc++.so.6</code> 这个动态库。</p><h3 id="matlab-无法使用系统中文字体"><a href="#matlab-无法使用系统中文字体" class="headerlink" title="matlab 无法使用系统中文字体"></a>matlab 无法使用系统中文字体</h3><p>参考： <a href="https://bbs.archlinux.org/viewtopic.php?id=231299" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=231299</a></p><pre><code class="lang-bash">cd  /usr/local/MATLAB/R2017b # Matlab directorycd bin/glnxa64mkdir excludemv libfreetype* excludecd ../../sys/os/glnxa64mkdir excludemv libstdc++.so.6* exclude</code></pre><p>或者跟上面的解决方法类似，备份文件后做链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;linux 下使用 matlab 的几个小提示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://www.mathworks.com/help/examples/matlab/win64/MatlabLogoExample_08.png&quot; alt=&quot;MATLAB LOGO&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;MATLAB LOGO&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。&lt;/p&gt;
&lt;p&gt;在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="matlab" scheme="https://fsslc.github.io/tags/matlab/"/>
    
      <category term="linux" scheme="https://fsslc.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 递归：梦中梦</title>
    <link href="https://fsslc.github.io/2018/05/06/Translate-Recursion--dream-within-a-dream/"/>
    <id>https://fsslc.github.io/2018/05/06/Translate-Recursion--dream-within-a-dream/</id>
    <published>2018-05-06T15:24:21.000Z</published>
    <updated>2020-03-01T16:01:33.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》</p></blockquote><img src="https://img.linux.net.cn/data/attachment/album/201805/06/111413hoaqz33ez2jdtrmz.jpg" class=""><p><strong>递归</strong>是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。</p><a id="more"></a><p>我们来看一下这个经典的递归阶乘：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;int factorial(int n){    int previous = 0xdeadbeef;    if (n == 0 || n == 1) {        return 1;    }    previous = factorial(n-1);    return n * previous;}int main(int argc){    int answer = factorial(5);    printf(&quot;%d\n&quot;, answer);}</code></pre><p><em>递归阶乘 - factorial.c</em></p><p>函数调用自身的这个观点在一开始是让人很难理解的。为了让这个过程更形象具体，下图展示的是当调用 <code>factorial(5)</code> 并且达到 <code>n == 1</code>这行代码 时，<a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/factorial-gdb-output.txt" target="_blank" rel="noopener">栈上</a> 端点的情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/factorial.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次调用 <code>factorial</code> 都生成一个新的 <a href="https://manybutfinite.com/post/journey-to-the-stack" target="_blank" rel="noopener">栈帧</a>。这些栈帧的创建和 <a href="https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/" target="_blank" rel="noopener">销毁</a> 是使得递归版本的阶乘慢于其相应的迭代版本的原因。在调用返回之前，累积的这些栈帧可能会耗尽栈空间，进而使你的程序崩溃。</p><p>而这些担心经常是存在于理论上的。例如，对于每个 <code>factorial</code> 的栈帧占用 16 字节（这可能取决于栈排列以及其它因素）。如果在你的电脑上运行着现代的 x86 的 Linux 内核，一般情况下你拥有 8 GB 的栈空间，因此，<code>factorial</code> 程序中的 <code>n</code> 最多可以达到  512,000  左右。这是一个 <a href="https://gist.github.com/gduarte/9944878" target="_blank" rel="noopener">巨大无比的结果</a>，它将花费 8,971,833 比特来表示这个结果，因此，栈空间根本就不是什么问题：一个极小的整数 —— 甚至是一个 64 位的整数 —— 在我们的栈空间被耗尽之前就早已经溢出了成千上万次了。</p><p>过一会儿我们再去看 CPU 的使用，现在，我们先从比特和字节回退一步，把递归看作一种通用技术。我们的阶乘算法可归结为：将整数 N、N-1、 … 1 推入到一个栈，然后将它们按相反的顺序相乘。实际上我们使用了程序调用栈来实现这一点，这是它的细节：我们在堆上分配一个栈并使用它。虽然调用栈具有特殊的特性，但是它也只是又一种数据结构而已，你可以随意使用。我希望这个示意图可以让你明白这一点。</p><p>当你将栈调用视为一种数据结构，有些事情将变得更加清晰明了：将那些整数堆积起来，然后再将它们相乘，这并不是一个好的想法。那是一种有缺陷的实现：就像你拿螺丝刀去钉钉子一样。相对更合理的是使用一个迭代过程去计算阶乘。</p><p>但是，螺丝钉太多了，我们只能挑一个。有一个经典的面试题，在迷宫里有一只老鼠，你必须帮助这只老鼠找到一个奶酪。假设老鼠能够在迷宫中向左或者向右转弯。你该怎么去建模来解决这个问题？</p><p>就像现实生活中的很多问题一样，你可以将这个老鼠找奶酪的问题简化为一个图，一个二叉树的每个结点代表在迷宫中的一个位置。然后你可以让老鼠在任何可能的地方都左转，而当它进入一个死胡同时，再回溯回去，再右转。这是一个老鼠行走的 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze.h" target="_blank" rel="noopener">迷宫示例</a>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/mazeGraph.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每到边缘（线）都让老鼠左转或者右转来到达一个新的位置。如果向哪边转都被拦住，说明相关的边缘不存在。现在，我们来讨论一下！这个过程无论你是调用栈还是其它数据结构，它都离不开一个递归的过程。而使用调用栈是非常容易的：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &quot;maze.h&quot;int explore(maze_t *node){    int found = 0;    if (node == NULL)    {        return 0;    }    if (node-&gt;hasCheese){        return 1;// found cheese        }    found = explore(node-&gt;left) || explore(node-&gt;right);    return found;    }    int main(int argc)    {        int found = explore(&amp;maze);    }</code></pre><p><em>递归迷宫求解 <a href="https://manybutfinite.com/code/x86-stack/maze.c" target="_blank" rel="noopener">下载</a></em></p><p>当我们在 <code>maze.c:13</code> 中找到奶酪时，栈的情况如下图所示。你也可以在 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze-gdb-output.txt" target="_blank" rel="noopener">GDB 输出</a> 中看到更详细的数据，它是使用 <a href="https://github.com/gduarte/blog/blob/master/code/x86-stack/maze-gdb-commands.txt" target="_blank" rel="noopener">命令</a> 采集的数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/mazeCallStack.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>它展示了递归的良好表现，因为这是一个适合使用递归的问题。而且这并不奇怪：当涉及到算法时，<em>递归是规则，而不是例外</em>。它出现在如下情景中——进行搜索时、进行遍历树和其它数据结构时、进行解析时、需要排序时——它无处不在。正如众所周知的 pi 或者 e，它们在数学中像“神”一样的存在，因为它们是宇宙万物的基础，而递归也和它们一样：只是它存在于计算结构中。</p><p>Steven Skienna 的优秀著作 <a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/" target="_blank" rel="noopener">算法设计指南</a> 的精彩之处在于，他通过 “战争故事” 作为手段来诠释工作，以此来展示解决现实世界中的问题背后的算法。这是我所知道的拓展你的算法知识的最佳资源。另一个读物是 McCarthy 的 <a href="https://github.com/papers-we-love/papers-we-love/blob/master/comp_sci_fundamentals_and_history/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-parti.pdf" target="_blank" rel="noopener">关于 LISP 实现的的原创论文</a>。递归在语言中既是它的名字也是它的基本原理。这篇论文既可读又有趣，在工作中能看到大师的作品是件让人兴奋的事情。</p><p>回到迷宫问题上。虽然它在这里很难离开递归，但是并不意味着必须通过调用栈的方式来实现。你可以使用像 <code>RRLL</code> 这样的字符串去跟踪转向，然后，依据这个字符串去决定老鼠下一步的动作。或者你可以分配一些其它的东西来记录追寻奶酪的整个状态。你仍然是实现了一个递归的过程，只是需要你实现一个自己的数据结构。</p><p>那样似乎更复杂一些，因为栈调用更合适。每个栈帧记录的不仅是当前节点，也记录那个节点上的计算状态（在这个案例中，我们是否只让它走左边，或者已经尝试向右）。因此，代码已经变得不重要了。然而，有时候我们因为害怕溢出和期望中的性能而放弃这种优秀的算法。那是很愚蠢的！</p><p>正如我们所见，栈空间是非常大的，在耗尽栈空间之前往往会遇到其它的限制。一方面可以通过检查问题大小来确保它能够被安全地处理。而对 CPU 的担心是由两个广为流传的有问题的示例所导致的：<ruby>哑阶乘<rt>dumb factorial</rt></ruby>和可怕的无记忆的 O( 2^n ) <a href="http://stackoverflow.com/questions/360748/computational-complexity-of-fibonacci-sequence" target="_blank" rel="noopener">Fibonacci 递归</a>。它们并不是栈递归算法的正确代表。</p><p>事实上栈操作是非常快的。通常，栈对数据的偏移是非常准确的，它在 <a href="https://manybutfinite.com/post/intel-cpu-caches/" target="_blank" rel="noopener">缓存</a> 中是热数据，并且是由专门的指令来操作它的。同时，使用你自己定义的在堆上分配的数据结构的相关开销是很大的。经常能看到人们写的一些比栈调用递归更复杂、性能更差的实现方法。最后，现代的 CPU 的性能都是 <a href="https://manybutfinite.com/post/what-your-computer-does-while-you-wait/" target="_blank" rel="noopener">非常好的</a> ，并且一般 CPU 不会是性能瓶颈所在。在考虑牺牲程序的简单性时要特别注意，就像经常考虑程序的性能及性能的<a href="https://manybutfinite.com/post/performance-is-a-science" target="_blank" rel="noopener">测量</a>那样。</p><p>下一篇文章将是探秘栈系列的最后一篇了，我们将了解尾调用、闭包、以及其它相关概念。然后，我们就该深入我们的老朋友—— Linux 内核了。感谢你的阅读！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://manybutfinite.com/img/stack/1000px-Sierpinski-build.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>via: <a href="https://manybutfinite.com/post/recursion/" target="_blank" rel="noopener">https://manybutfinite.com/post/recursion/</a><br>publish: <a href="https://linux.cn/article-9609-1.html" target="_blank" rel="noopener">https://linux.cn/article-9609-1.html</a></p><p>作者：<a href="http://duartes.org/gustavo/blog/about/" target="_blank" rel="noopener">Gustavo Duarte</a><br>译者：<a href="https://github.com/qhwdw" target="_blank" rel="noopener">qhwdw</a><br>校对：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创编译，<a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201805/06/111413hoaqz33ez2jdtrmz.jpg&quot; class=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="递归" scheme="https://fsslc.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>减小 VBoX 虚拟磁盘大小</title>
    <link href="https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/"/>
    <id>https://fsslc.github.io/2016/12/18/Decrease-VBoX-image/</id>
    <published>2016-12-18T08:28:48.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何使用 VBOX 自带工具减小虚拟磁盘大小</p></blockquote><p>由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ,WPS,MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。</p><p>虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。</p><a id="more"></a><p>问题来了，便开始上网搜索方法。在<a href="http://my.oschina.net/tsl0922/blog/188276" target="_blank" rel="noopener">开源中国的一个博客</a>里面找到了方法，下面进行简单的记录。</p><p>根据博主的文章，要达到减小 VBox 虚拟磁盘的大小，主要有两个步骤：</p><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>首先需要在虚拟机里面的系统下做碎片整理。</p><p>对于 Linux 系统，可以使用：</p><pre><code class="lang-bash">sudo dd if=/dev/zero of=/EMPTY bs=1Msudo rm -f /EMPTY</code></pre><p>对于 Windows 系统，则需要使用 <a href="http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx" target="_blank" rel="noopener">Sysinternals Suite</a>，点击上面的链接可以到微软的页面下进行下载。下载解压后，通过 CMD ，运行：</p><pre><code class="lang-bash">sdelete -z c:</code></pre><p>等待进度完成即可。然后关闭虚拟机。</p><h2 id="压缩磁盘"><a href="#压缩磁盘" class="headerlink" title="压缩磁盘"></a>压缩磁盘</h2><p>如果虚拟磁盘是 <code>Virtual Box</code> 自家的 <code>VDI</code> 格式，则只需要先通过终端到达含有后缀为 <code>.vdi</code> 的文件所在的那个目录，再执行：</p><pre><code class="lang-bash">VBoxManage modifyhd win7.vdi --compact</code></pre><p>这样就可以达到压缩磁盘的目的。</p><p>如果虚拟磁盘是 <code>VMDK</code> 的格式，则可以使用 vmware 自带的 <code>vmware-vdiskmanager</code> 工具，具体命令如下：</p><pre><code class="lang-bash">vmware-vdiskmanager -k disk.vmdk</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如何使用 VBOX 自带工具减小虚拟磁盘大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ,WPS,MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。&lt;/p&gt;
&lt;p&gt;虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="VBox" scheme="https://fsslc.github.io/tags/VBox/"/>
    
  </entry>
  
  <entry>
    <title>在 Archlinux 中安装 Opendx</title>
    <link href="https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/"/>
    <id>https://fsslc.github.io/2016/12/15/Install-opendx-In-Archlinux/</id>
    <published>2016-12-15T08:02:31.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Archlinux 中安装 Opendx</p></blockquote><p><a href="http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/">前面</a> 我说过， opendx 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 <code>sudo apt install dx dxsamples</code> 安装这个可视化软件。</p><p>现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。</p><a id="more"></a><p><strong>UPDATE</strong><br>现在下面那个久未更新的镜像网站已经不存在了，而我也没有保存那个安装包，所以只好自己想办法了。还好 Debian 还在维护这两个包，所以我就借鉴它的编译脚本来写成适合 Archlinux 编译的脚本。目前通过我自己编写的编译脚本编译这两个软件包基本可以使用，但还是有点小问题：</p><ol><li>Debian 维护者里面的那个仓库中，包含很多与 Debian 系统相关的补丁，我只清理了一点，有些可能没有清理干净；</li><li>有时会占用 100% 的 CPU，到时直接杀掉那个进程即可(PS: <code>htop</code>这个工具非常好用，推荐大家使用)；</li><li>在 dx 的窗口中仍然不能直接达到 samples 目录。</li></ol><hr><p>自己编译又不想安装那么多的依赖，最后在<a href="http://mirror.lzjtu.edu.cn/archlinux/community/os/x86_64/" target="_blank" rel="noopener">国内某个久未更新的镜像网站</a> 中找到了别人打包好的二进制文件，下载那个名为 opendx-4.4.4-2.pkg.tar.gz 的安装包后，可以直接使用命令 sudo pacman -U opendx-4.4.4-2.pkg.tar.gz 进行安装。</p><p>这样安装后，可能会有些依赖问题，例如我的系统里面会报 netcdf 和 tiff 的动态链接库找不到，而我已经安装了它们，所以只需要创建一些软链接就可以了。</p><pre><code class="lang-bash">sudo ln -s /usr/lib/libnetcdf.so.12.0.0 /usr/lib/libnetcdf.so.4sudo ln -s /usr/lib/libtiff.so.5.2.4 /usr/lib/libtiff.so.3</code></pre><hr><p>最后附上我改写的编译脚本和相关的源文件：</p><pre><code class="lang-bash">链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxt</code></pre><p>如果只需要编译这两个包，只需要下载 <code>Opendx_AUR_build_scripts.zip</code> 这个压缩包就行了。另外的东西是用来编译 AFEPack 的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Archlinux 中安装 Opendx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/&quot;&gt;前面&lt;/a&gt; 我说过， opendx 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 &lt;code&gt;sudo apt install dx dxsamples&lt;/code&gt; 安装这个可视化软件。&lt;/p&gt;
&lt;p&gt;现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Opendx" scheme="https://fsslc.github.io/tags/Opendx/"/>
    
      <category term="Archlinux" scheme="https://fsslc.github.io/tags/Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>使用 docker 构建 AFEPack 镜像</title>
    <link href="https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/"/>
    <id>https://fsslc.github.io/2016/12/15/Build-AFEPack-docker-image/</id>
    <published>2016-12-15T07:24:09.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦</p></blockquote><p>先前写了一篇<a href="http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/">如何在 Ubuntu 安装 AFEPack 的教程</a>，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在<a href="https://hub.docker.com/r/xywei/afebackpack/" target="_blank" rel="noopener">这里</a>。先前也知道 docker 掀起的热潮，但一直没有学习它。</p><a id="more"></a><p>关于 docker 的学习，网上一搜一大堆。我自己买了本 杨保华、戴王剑、曹亚仑 编著的《Docker 技术入门与实践》，利用一个下午学会了基本操作，后面的有些功能自己用不到就没有再深究下去。闲话少说，下面进入正题。</p><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p>首先，要构建 docker 镜像，你需要安装 <code>docker</code>，具体安装过程见官网或者 Google 、Baidu 一下。</p><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><p>要想实现自动构建 Docker 镜像，就需要编写 Dockerfile。只要知道 Dockerfile 编写时需要用的一些指令和编译安装的命令就可以了。</p><p>下面是我最后写好的 Dockerfile 。我在下面用中文添加注释，原文件参考我 GitHub 上的项目<a href="https://github.com/FSSlc/AFEPackDocker" target="_blank" rel="noopener">AFEPackDocker</a>。</p><pre><code class="lang-bash">FROM ubuntu:16.04                                   # 以 ubuntu 16.04 作为镜像的基础系统MAINTAINER FSSlc, liuchang011235 AT gmail DOT com   # 维护者的相关信息# install essential packagesRUN \                                               # RUN 后面跟上要运行的命令即可  mkdir -p /root/Pkg &amp;&amp; \  # use aliyun&#39;s mirror for better download speed  sed -i &#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&#39; /etc/apt/sources.list &amp;&amp; \  apt-get update &amp;&amp; \  apt-get install -y make automake autoconf wget build-essential \  libdeal.ii-dev mpi-default-dev nano # libhypre-dev trilinos-all-dev petsc-dev --no-install-recommends## set some env varibles                            # 设置与 AFEPack 相关的环境变量COPY env.txt /root/Pkg/env.txt ## prepare AFEPack easymeshRUN \cd /root/Pkg &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/AFEPack-snapshot.tar.gz &amp;&amp; \wget http://dsec.pku.edu.cn/~rli/source_code/easymesh.c.gz &amp;&amp; \tar -xzf ./AFEPack-snapshot.tar.gz -C /root/Pkg/  &amp;&amp; \gunzip easymesh.c.gz &amp;&amp; \## compile and install AFEPackcat /root/Pkg/env.txt &gt;&gt; /root/.bashrc &amp;&amp; . /root/.bashrc &amp;&amp; \cd /root/Pkg/AFEPack &amp;&amp; \                           # 将 ubuntu 中安装的 deal.ii 库文件改名ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.g.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.g.so &amp;&amp; \ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.so.8.1.0  /usr/lib/x86_64-linux-gnu/libdeal_II.so &amp;&amp; \aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; \env EXTRA_INCDIR=&quot;-I/usr/include/deal.II/&quot; EXTRA_LIBDIR=&quot;-L/usr/lib/x86_64-linux-gnu/&quot; ./configure &amp;&amp; \# make -j8 &amp;&amp; make install                      # 下面分开编译 AFEPack，直接编译会报错，镜像就编译不下去了cd ./template/ &amp;&amp; make -j8 &amp;&amp; cd ../library/ &amp;&amp; make -j8 &amp;&amp; make install &amp;&amp; \cd ../example/ &amp;&amp; make -j8 &amp;&amp; \## compile and install easymeshcd /root/Pkg/ &amp;&amp; \gcc -o easymesh easymesh.c -lm &amp;&amp; \mv ./easymesh /usr/local/bin/ &amp;&amp; \## do some clean work                           # 清理一些不需要的文件，减小镜像大小rm easymesh.c AFEPack-snapshot.tar.gz env.txt &amp;&amp; \rm -rf /var/lib/apt/lists/*CMD [&quot;/bin/bash&quot;]</code></pre><p><strong>UPDATE</strong><br>为了能够本地编译安装 AFEPack 的镜像，我编写了两个 Dockerfile，一个是直接使用<br>Ubuntu 16.04 里面 8.1 版本的 deal.II，另一个是在 Ubuntu 14.04 里使用源码编译的 deal.II 6.3.1，请自行选择。</p><p><strong>UPDATE 20181103</strong><br>好久没有更新了，最近在做 docker 相关的事。了解到 docker 可以进行所谓的多阶段构建了。这个功能可以进一步地减小镜像的大小，所以我今天就尝试了一下，效果还是很明显的。从原来的 <code>1.07GB</code> 减少到现在的 <code>573MB</code>。 </p><p>另外 AFEPack 的包做了一些更新，居然默认 <code>std=c++14</code> 了！所以原来的 Dockerfile 可能不能使用了，所以我顺便做了更新。从构建的结果看，<code>step-7</code> 这个例子跑不通，这次更新后的 Dockerfile 都有这个问题，它们获取的<br>AFEPack 源码都是今天我从官网下载的。但是我放在 docker Hub 的镜像可以运行。。。</p><h2 id="使用-docker-build-命令构建镜像"><a href="#使用-docker-build-命令构建镜像" class="headerlink" title="使用 docker build 命令构建镜像"></a>使用 <code>docker build</code> 命令构建镜像</h2><p>编写完 Dockerfile 后，便可以构建镜像了。使用的命令是：</p><pre><code class="lang-bash">sudo docker build  -t afepack:v0 .</code></pre><p>其中 <code>-t</code> 选项是指定编译后镜像的名称，即所谓的 <code>tag</code> 。</p><p>具体使用时，一般运行：</p><pre><code class="lang-bash">docker run -ti -v $HOME/Pkg:/opt afepack:v0 bash</code></pre><p>上面的命令将启动一个容器，其中的 <code>-v</code> 选项将把主机中的 <code>$HOME/Pkg</code> 目录挂载到容器中的 <code>/opt</code> 目录，这样我们便可以在 <code>$HOME/Pkg</code> 中让主机和容器之间进行数据交互。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先前写了一篇&lt;a href=&quot;http://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/&quot;&gt;如何在 Ubuntu 安装 AFEPack 的教程&lt;/a&gt;，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在&lt;a href=&quot;https://hub.docker.com/r/xywei/afebackpack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。先前也知道 docker 掀起的热潮，但一直没有学习它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="Docker" scheme="https://fsslc.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 AFEPack</title>
    <link href="https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/11/03/Install-AFEPack-In-Ubuntu/</id>
    <published>2015-11-03T06:02:55.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 AFEPack</p></blockquote><p><strong>Update</strong><br>相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考<a href="https://hub.docker.com/r/fsslc/afepack/" target="_blank" rel="noopener">我的说明</a>进行安装。</p><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）</p><a id="more"></a><h2 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h2><p>首先，下载好 deal. II、AFEPack、mpich（非必须） 这几个软件的安装包。</p><p>其中的 deal. II 和 AFEPack 可以到我的百度网盘去下载，这个是我从我大学同学的未来的师兄那里获得的，而那位师兄的老师正是这个软件包的作者 李若 老师。由于高版本的 deal. II 版本经过了许多的修改，且鉴于 AFEPack 几乎停滞的开发状态，我们采用的是 deal. II 的 6.3.1 版本。而 mpich 则可以到官网去下载最新的稳定版本。</p><p>相关软件的下载地址为：</p><p>deal.II 和 AFEPack : 链接: <a href="https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g" target="_blank" rel="noopener">https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g</a> 密码: utxt<br>mpich : <a href="http://www.mpich.org/downloads/" target="_blank" rel="noopener">http://www.mpich.org/downloads/</a></p><p>下载好这些包后，将他们进行解压备用。</p><h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>接下来，安装一些必要的软件。</p><p>首先安装 boost 库。这个可以用命令行，也可以使用 synaptic (新得立) 这个图形化的包管理软件来安装。命令行需要使用的命令为：</p><pre><code class="lang-bash">sudo apt-get install libboost-dbg  libboost-all-dev</code></pre><p>接着安装自动化产生 <code>makefile</code> 的相关工具。其中 <code>aclocal</code> 已经被包括在 <code>autoconf</code> 里了。</p><pre><code class="lang-bash">sudo apt-get install autoconf automake</code></pre><p>接着安装编译器，由于某些原因，编译 AFEPack 时，用高版本(如 4.8)的 gcc 和 g++ 会出错，所以需要安装对应的低版本的包。这里安装 4.6 版本。</p><pre><code class="lang-bash">sudo apt-get install gcc-4.6 g++-4.6 gfortran#  降低 gcc，g++ 的版本，可以在后面改回来cd /usr/binsudo ln -s gcc-4.6 gccsudo ln -s g++-4.6 g++</code></pre><h2 id="安装-deal-II"><a href="#安装-deal-II" class="headerlink" title="安装 deal. II"></a>安装 deal. II</h2><p>根据李若老师的解释，他选用这个包的原因是看上了这个包里面 <code>lac</code> 、 <code>base</code> 中的代码，即关于基础线性代数相关的代码写得很好，所以才采用了 deal. II 。所以我们可以只编译里面的部分文件，当然如果你不在乎占用一点额外的磁盘空间，也可以选择完整安装。</p><p>关于安装路径，下面以我的安装位置 <code>/home/lc/Pkg/deal.II</code> 来举例，其中 <code>/home/lc</code> 为我的家目录，可以对应地修改，也可以安装到其他路径，如 <code>/usr/local/deal.II</code> 等。</p><p>首先，进入解压后的 deal. II 目录，我的在 <code>/home/lc/Pkg/deal.II</code> 。 然后在终端中依次输入下面的命令，其中 # 后的内容为注释，可以忽略。</p><pre><code class="lang-bash">cd /home/lc/Pkg/deal.II # 进入解压后的 deal.II 目录./configuremake -j4 lac base contrib # -j 选项是启用多线程，以此来加快编译的速度，后面的数字最好与你机子的 CPU 的线程数相同或更少# 或者使用 make all 来完整安装</code></pre><p>经过一段时间后(根据你的机器配置而定)，就把需要的文件编译好了。下面需要做一些软链接。在以前安装时，我尝试过直接把 deal. II 编译后产生的相应目录加在系统变量中，然后再安装 AFEPack，结果 AFEPack 不能找到 deal. II 的头文件，所以还是做个链接。具体的原因我也不清楚，可能需要问作者本人。</p><p>下面是我做链接时使用的命令，请相应做些修改：</p><pre><code class="lang-bash">cd /usr/local/includesudo ln -s ~/Pkg/deal.II/deal.II/include/ .sudo ln -s ~/Pkg/deal.II/lac/include/lac/ .sudo ln -s ~/Pkg/deal.II/base/include/base/ .sudo ln -s ~/Pkg/deal.II/contrib/tbb/tbb22_20090809oss/include/tbb/ .# 这里的 tbb22_20090809oss 可能会有所不同，但一般这个目录都是以 tbb 开头的，可用 Tab 键来自动补全；# 最后的 `.` 代指当前目录 ，以下类型cd /usr/local/libsudo ln -s ~/Pkg/deal.II/lib/lib* .</code></pre><h2 id="安装-mpich"><a href="#安装-mpich" class="headerlink" title="安装 mpich"></a>安装 mpich</h2><p><strong>这个不是必须的，除了 mpich，也可以直接安装<br>OpenMPI</strong>。</p><p>这个的安装可以根据解压后文件夹中的指示来操作，一般都是如下几个命令：</p><pre><code class="lang-bash">cd /home/lc/Pkg/mpich2/ # 进入 mpich2 解压后的目录，根据你自己的情况调整./configuremake -j4sudo make install</code></pre><p>这样就安装好了 mpich。</p><p>当然，我们也可以直接使用软件源里面的 mpich，这样或许更省事些。</p><h2 id="安装-AFEPack"><a href="#安装-AFEPack" class="headerlink" title="安装 AFEPack"></a>安装 AFEPack</h2><p>现在进行 AFEPack 的安装。首先利用 autotools 套件中的软件(即 aclocal，autoconf，automake 等)来自动生成 configure 文件。使用的命令如下：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPackaclocalautoconfautomake --add-missing</code></pre><p>然后把</p><pre><code class="lang-bash"># AFEPack templeteexport AFEPACK_TEMPLATE_PATH=&quot;/home/lc/Pkg/AFEPack/template/triangle:/home/lc/Pkg/AFEPack/template/rectangle:/home/lc/Pkg/AFEPack/template/interval:/home/lc/Pkg/AFEPack/template/twin_triangle:/home/lc/Pkg/AFEPack/template/tetrahedron:/home/lc/Pkg/AFEPack/template/twin_tetrahedron:/home/lc/Pkg/AFEPack/template/four_tetrahedron&quot;</code></pre><p>加到 <code>～/.bashrc</code> 文件中，然后使用 <code>source ~/.bashrc</code> 来使更改生效。</p><p>接着对 AFEPack 进行配置和编译。</p><pre><code class="lang-bash">./configuremake -j4</code></pre><p>编译期间会报错停掉，报 mpi.h 找不到。这时仍然继续，输入：</p><pre><code class="lang-bash">make install</code></pre><p>然后进入 AFEPack 目录下的 template 目录，来编译模板。我使用的命令为：</p><pre><code class="lang-bash">cd /home/lc/Pkg/AFEPack/templatemake</code></pre><p>现在来编译关于 mpi 的静态文件。这里需要 MPI 的相关库，这里我们使用的是 mpich。</p><pre><code class="lang-bash">~/Pkg/AFEPack/library/mpimake -j4</code></pre><p>example 子目录下有一些实用的工具，我们现在来编译它们。</p><pre><code class="lang-bash">cd ~/Pkg/AFEPack/examplemake -j4</code></pre><p>最后执行下面的命令来使得 <code>ld</code> 能够找到 <code>AFEPack.so</code> 等静态库。</p><pre><code class="lang-bash">cd ～/Pkg/AFEPacksudo ldconfig</code></pre><p>至此， AFEPack 的安装就结束了。</p><p>如果你在安装期间有什么问题，可以来询问我，我尽量帮忙。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 AFEPack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;&lt;br&gt;相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考&lt;a href=&quot;https://hub.docker.com/r/fsslc/afepack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的说明&lt;/a&gt;进行安装。&lt;/p&gt;
&lt;h2 id=&quot;系统准备&quot;&gt;&lt;a href=&quot;#系统准备&quot; class=&quot;headerlink&quot; title=&quot;系统准备&quot;&gt;&lt;/a&gt;系统准备&lt;/h2&gt;&lt;p&gt;我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="AFEPack" scheme="https://fsslc.github.io/tags/AFEPack/"/>
    
      <category term="Deal. II" scheme="https://fsslc.github.io/tags/Deal-II/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 下 Opendx Data Explorer 的字体问题</title>
    <link href="https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/"/>
    <id>https://fsslc.github.io/2015/11/03/Cannot-convert-string-to-type-FontStruct/</id>
    <published>2015-11-03T05:51:25.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解决在 Ubuntu 下 Opendx Data Explorer 的字体问题</p></blockquote><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近一直在学习使用李若老师的 AFEPack 软件包，其中这个包输出的图形格式一般为 Opendx，但据网上的一些评论，它基本上处于类似渡渡鸟的境地了。但自己能力有限，还不能更改它输出为 Vtk 等现在主流的图像格式，所以还是先用着吧。</p><p>现在读取 opendx 格式的软件好像就只有 <code>Opendx Data Explorer</code> 了。自从 IBM 开源了 opendx 后，就没有多少官方的支持，现在它的开发主要由一个名为 <code>Visualization and Imagery Solutions, Inc.</code> 的公司负责。在 Ubuntu 中，可以直接通过软件源安装编译好的 dx 软件。</p><p>安装后，可以在终端中使用 dx 命令来启动 Opendx Data Explorer。但终端始终会出现类似如下的警告：</p><pre><code class="lang-bash">Cannot convert string &quot;-*-helvetica-bold-r-*-*-16-*&quot; to type FontStruct</code></pre><p>于是乎，便利用网络来搜索答案。下面是解决办法。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>搜索的过程就不说了，反正还是 Google 强。</p><p>最开始说的是先确认下有没有安装这些字体。一般是先建议你安装两个字体包，使用的命令是：</p><pre><code class="lang-bash">sudo apt-get install xfonts-75dpi xfonts-100dpi</code></pre><p>它们默认是安装在 <code>/usr/share/fonts/X11/</code> 目录中。</p><p>然后可以使用下面的命令来查看是否安装了上面警告中的字体：</p><pre><code class="lang-bash">xlsfonts -fn &quot;-*-helvetica-bold-r-*-*-10-*-*-*-*-*-*-*&quot;</code></pre><p>其中的 <code>*</code> 都是一些匹配。可以类似地修改匹配格式。</p><p>但是安装完后还是没有解决问题。于是又搜。</p><p>最后在<a href="http://www.linuxquestions.org/questions/linux-software-2/error-message-regarding-fonts-in-grace-943919/" target="_blank" rel="noopener">这个网页</a>里面找到了解决办法。</p><p>原来，在安装完这些字体后，我们还需要一些设置，具体的命令是：</p><pre><code class="lang-bash">xset +fp /usr/share/fonts/X11/75dpi/xset +fp /usr/share/fonts/X11/100dpi/</code></pre><p>至于上面的命令具体执行了什么步骤，可以 <code>man xset</code> 。随后问题便解决了。遇到类似的问题（例如某个软件中文乱码，呈现出方框），似乎都可以这样解决。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>最后说说我对 OpenDX 的看法吧。</p><p>刚开始入门的时候，总感觉资料很少，这个软件不太好使用。相比于 ViSit 或 ParaView 等软件，dx 太难用了，什么都要自己定义，而且找到的资料也不是很多；所以对它的印象不好。</p><p>现在由于导师分配的任务，我需要使用 AFEPack 来求解方程，最后需要用 dx 来展示结果。通过这几天的摸索，感觉了它的强大。现在基本明白了为什么李若老师喜欢这种数据格式和这个软件的原因了。说到底，还是需要折腾。</p><p>至于学习资料。安装好 dx 后，一般可以在 <code>/usr/share/dx/samples</code> 找到示例代码；文档说明的话，可以看 <code>/usr/share/dx/html</code> 里面的东西，这些 html 文件里面包含的内容其实很多的。一步一步的看下去还是有很多收获的。</p><p>至于 <code>Visualization and Imagery Solutions, Inc.</code> 公司出的那本名为 <code>OpenDX---Paths to Visualization</code> 的书，我觉得自带的 html 文件内容或许更多一些，当然看看还是不错的。</p><p>以前我在<a href="http://web.engr.oregonstate.edu/~mjb/opendx/" target="_blank" rel="noopener">这个网站</a>找到了很多关于 Opendx 的资料，现在仍然推荐去看看那里的东西。</p><p>TODO： 通过 Ubuntu 仓库安装 dx 软件有一个问题：</p><p>在经过一段时间的使用后， dx 会吃掉 100% 的 CPU。根据我的搜索，现在还没有找到解决办法，自编译的 dx 就好像没有这个问题。后面再搜索一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决在 Ubuntu 下 Opendx Data Explorer 的字体问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Font" scheme="https://fsslc.github.io/tags/Font/"/>
    
      <category term="Opendx" scheme="https://fsslc.github.io/tags/Opendx/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装 FEniCS</title>
    <link href="https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/12/Install-FEniCS-in-Ubuntu/</id>
    <published>2015-10-12T04:32:13.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Ubuntu 中安装 FEniCS</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://fenicsproject.org/pub/tutorial/sphinx1/_static/fenics_banner.png" alt="FEniCS Logo" title="">                </div>                <div class="image-caption">FEniCS Logo</div>            </figure><p><strong>Update 20161212</strong><br>现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看<a href="https://fenics-containers.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">官网的说明</a>。这样就可以少折腾了。</p><a id="more"></a><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近导师去开了个会议，从其他人那里打听到有很多人都在 FEniCS 的基础上写代码了。导师她最开始认为，它是用来写 Fortran 代码的一个平台，加之她主要使用的编程语言为 Fortran，所以希望我们能够去学习一下。</p><p>第一次看到 FEniCS 这个词，应该可以追溯到我大四做毕业论文的时候。那时想找个软件来书写有限元程序，因为自己从底层开始写起太费事了。通过搜索，找到了许多软件，具体可以看看这个链接。通过试用，左右权衡，最后决定使用 deal. II 来做毕业论文。</p><p>当时对于 FEniCS 的认识是：</p><pre><code>它是用 Python 写的，自己对 Python 不熟悉，查找到的资料不是很齐全；当时自己尝试从 PPA 安装了 FEniCS， 但程序运行地不是很顺利；</code></pre><p>现在，通过这一两天的使用，觉得这货实在是太简单了，用 Python 根据它自定义的 UFL 语言来自动生成可执行代码，最后使用 OpenGL 和 VTK 来生成图形和 vtu 文件。当然，方便的代价就是编译过程的时间有点长；毕竟鱼和熊掌是不能兼得的。</p><p>PS：FEnics 还可以与 C, C++, Fortran, 或 MATLAB 交互，具体可以看<a href="https://hplgit.github.io/fenics-mixed/doc/web/index.html" target="_blank" rel="noopener">这里的文档</a>。</p><h2 id="FEniCS-的安装过程"><a href="#FEniCS-的安装过程" class="headerlink" title="FEniCS 的安装过程"></a>FEniCS 的安装过程</h2><h3 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h3><p>首先我的安装平台为 ubuntu 14.04, 64 位，但从自己安装的过程来看，其他系统应该也可以安装，大体步骤是一致的，具体可以看官网的说明。</p><p>特别说明：对于使用 Windows 系统的同学，你就别指望能够完美安装和运行 FEniCS 了，官网上说了， Windows 平台的安装包没有更新了。所以还是尽快学习一些 Linux 或 Unix 这类系统的使用方法吧。命令行真的非常好用，包管理器的使用也非常方便。</p><p>下面我是通过 Anaconda 这个 Python 集成环境来安装 FEniCS 的，所以你需要安装好 Anaconda。可以到官网的下载页面 去下载相应版本的安装包，这里我们使用的是 Anaconda-2.3.0-Linux-x86_64.sh，至于安装，该页面里有提示，这里不赘述了。</p><p>另外，在运行 FEniCS 的程序之前，需要安装好 gcc g++ gfortran 等编译器，不然会出现意想不到的错误。可以使用如下的命令来安装这些软件：</p><pre><code class="lang-bash">sudo apt-get install build-essential gfortran</code></pre><h3 id="具体的安装过程"><a href="#具体的安装过程" class="headerlink" title="具体的安装过程"></a>具体的安装过程</h3><p>根据官网的解释，有如下几种方法可以来进行安装：</p><ol><li>直接添加 PPA 来进行下载。</li></ol><p>但安装尝试后，会引入许多不必要的安装依赖如 texlive 等，为了不污染系统，所以没有采取这种方法。当然，如果你订阅了他们的 PPA，这种方式能够使你获取到最新的更新。如果你没有‘洁癖’，可以尝试这种方法。</p><p>(注： 最近(2015-12) 找到了如何在安装有 Texlive 发型包的情况下，不再引起上面需要安装 texlive 依赖的方法，具体请参考<a href="http://www.latexstudio.net/archives/4017.html" target="_blank" rel="noopener">这篇文章</a>的最后一段，但请自己制作 dummy package，因为在安装时，可能会出现一点问题，请根据问题的描述更改相应的配置文件。 )</p><ol><li>通过下载脚本编译。</li></ol><p>通过下面的这个脚本来从源文件编译安装 FEniCS。</p><pre><code class="lang-bash">curl -s http://fenicsproject.org/fenics-install.sh | bash</code></pre><p>但在尝试的过程中，总是提示 SSL 认证失败。无果，所以放弃了这种方法。</p><ol><li>直接下载虚拟机镜像来运行。</li></ol><p>将镜像导入 Vbox 后，大概用了 7G 的空间，镜像里的系统使用的是 Lubuntu，感觉很精简，但没有自己安装的 Ubuntu 体验好。又考虑到空间占用的原因，亦弃之。</p><ol><li>通过 Anaconda 来安装 FEniCS。</li></ol><p>可以根据<a href="https://github.com/juanlu001/fenics-recipes" target="_blank" rel="noopener">这个网页</a>的指导安装。</p><p>这个 github 仓库里面用的命令是：</p><pre><code class="lang-bash">conda install fenics mkl --channel juanlu001</code></pre><p>而官网里面使用的命令是：</p><pre><code class="lang-bash">conda create --name fenics27 python=2.7source activate fenics27conda install fenics --channel juanlu001</code></pre><p>我最开始是根据 Github 上的命令来安装的。而再给其他人安装的时候，我特别使用了官网了给出的命令，现在大致知道了它们之间的区别：前者是直接将 FEniCS 安装到 Anaconda 的目录里面，而后者是创建了一个新的环境，单独进行了安装。考虑到简洁性，我推荐第二个命令。</p><p>在终端中依次输入上面的命令后，会大概下载 300M 左右的安装包，最后安装完毕会有 4G 左右(加上 Anaconda 原来安装后的文件)。经过一段漫长的等待后，FEniCS 就安装好了。</p><h2 id="安装后需要做的事"><a href="#安装后需要做的事" class="headerlink" title="安装后需要做的事"></a>安装后需要做的事</h2><p>安装完成后，自然需要运行一下 FEniCS 自带的示例程序，它们一般在 <code>~/anaconda/envs/fenics27/share/dolfin/</code> 目录下。随便进入某个示例目录，可以有名为 <code>cpp</code> 和 <code>python</code> 的两个目录。先进入 python 这个目录试试效果。</p><p>在终端运行：</p><pre><code class="lang-bash">python filename.py # 注意请将这句中的 filename 换为具体的程序名称</code></pre><p>然后终端会报错，大致意思是没有找到 <code>dolfin</code> 这个 module。这应该是环境变量的问题，最后通过搜索，参考<a href="https://answers.launchpad.net/dolfin/+question/166153" target="_blank" rel="noopener">这里的说明</a>，我们需要将 dolfin.conf 这个文件加到 PYTHONPATH 环境变量中。命令为：</p><pre><code class="lang-bash">source &lt;PATH_TO_YOUR_DOLFIN_INSTALLATION&gt;/share/dolfin/dolfin.conf</code></pre><p>对于使用 Anaconda 安装 FEniCS 的情况，dolfin.conf 一般在 <code>~/anaconda/envs/fenics27/share/dolfin</code> 目录里。</p><p>最好是将这个上面这个命令写入你本地的 <code>.bashrc</code> 文件里面，然后用 <code>source ~/.bashrc</code> 更新环境变量。</p><p>这个做完后，总该可以运行程序了吧。可惜，还不行。你会看终端里报错，提示说某些 VTK 的动态链接库找不到，根据 Github 里的 <a href="https://github.com/Juanlu001/fenics-recipes/issues/33" target="_blank" rel="noopener">issue</a>，需要使用下面的命令将 VTK 的版本降低：</p><pre><code class="lang-bash">conda list vtkconda install &quot;vtk=5.10&quot;</code></pre><p>这样就可以运行程序了。在程序执行的开始，你可能会看到有些提示，说 MKL 库有 30 天的试用期限，要你购买。对于这种情况，Anaconda 给学校和科研机构提供有学术版的许可，只要你使用 edu 的邮箱就可以申请到, <a href="https://store.continuum.io/cshop/academicanaconda" target="_blank" rel="noopener">申请地址</a> 。</p><p>申请后，会得到一个 license 文件，将其放在 <code>~/.continuum</code> 目录下即可。</p><p>另外，我发现我自己申请的 license 同样也可以用在别人的机器上，不知这是不是一个 bug。</p><h3 id="安装后软件的学习"><a href="#安装后软件的学习" class="headerlink" title="安装后软件的学习"></a>安装后软件的学习</h3><p>关于入门，可以直接看官网的文档，例如 tutorial，The FEniCS Book, Manual。</p><p>PS： 可以到<a href="https://launchpadlibrarian.net/83776282/fenics-book-2011-10-27-final.pdf" target="_blank" rel="noopener">这里</a>下载到 The FEniCS Book。</p><p>关于这两天学习的感受：我是从 tutorial 入门的，看了过后感觉这货居然这么简单，相比于我用 deal. II 写代码，这不知要轻松多少倍。另外，tutorial 里面的例子有些代码不能运行了，应该是 dolfin(或其他组件) 更新的缘故，而文档还没有被更新。下一步继续看文档来学习。</p><p>以后深入后，再写点东西来分享。</p><p><strong>UPDATE 2018.07.31</strong><br>有几点需要更新的：</p><ol><li><p>偶然发现了这个 <a href="http://www.fenics-hpc.org" target="_blank" rel="noopener">网站</a>， 似乎是将 fenics 应用到 HPC 领域中，并且在 edx 中开了<a href="https://www.edx.org/course/high-performance-finite-element-modeling-kthx-hpfem01-1x#" target="_blank" rel="noopener">一门 MOOC</a></p></li><li><p>关于学习资源，可以看看 <a href="http://people.cs.uchicago.edu/~ridg/" target="_blank" rel="noopener">这个老师的主页</a>，里面课程中有一些 notes。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 中安装 FEniCS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://fenicsproject.org/pub/tutorial/sphinx1/_static/fenics_banner.png&quot; alt=&quot;FEniCS Logo&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;FEniCS Logo&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Update 20161212&lt;/strong&gt;&lt;br&gt;现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看&lt;a href=&quot;https://fenics-containers.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网的说明&lt;/a&gt;。这样就可以少折腾了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="FEniCS" scheme="https://fsslc.github.io/tags/FEniCS/"/>
    
      <category term="Anaconda" scheme="https://fsslc.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView</title>
    <link href="https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/"/>
    <id>https://fsslc.github.io/2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/</id>
    <published>2015-10-10T04:07:08.000Z</published>
    <updated>2020-03-01T15:42:43.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView</p></blockquote><h2 id="Deal-II-的安装与配置"><a href="#Deal-II-的安装与配置" class="headerlink" title="Deal. II 的安装与配置"></a>Deal. II 的安装与配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://dealii.org/developer/doxygen/deal.II/logo200.png" alt="Deal. II Logo" title="">                </div>                <div class="image-caption">Deal. II Logo</div>            </figure><a id="more"></a><h3 id="Deal-II-的安装"><a href="#Deal-II-的安装" class="headerlink" title="Deal. II 的安装"></a>Deal. II 的安装</h3><p>关于安装，有如下几种方式：</p><ol><li><p>到 dealii 的下载页面去下载打包好的文件：</p><p> 对于 Ubuntu、Mac、Debain 都已经有编译好的二进制文件，Arch、Gentoo 可以分别通过 AUR 和 Gentoo Science Overlay 来得到；</p></li><li><p>利用 docker 来生成相关的镜像，具体可以参考<a href="https://hub.docker.com/r/dealii/dealii/" target="_blank" rel="noopener">这里</a>；</p></li><li><p>基于源码安装：</p><p> 官网上推荐 <a href="https://github.com/dealii/candi" target="_blank" rel="noopener">candi</a>，也可以通过 <a href="https://spack.io/" target="_blank" rel="noopener">spack</a>来安装。</p></li></ol><p>下面是我自己的安装过程，算是一个记录吧。</p><p>下载好源文件后，进行解压，然后进入解压的目录，具体安装方法可以通过 README.md 这个文件知晓。需要注意的是 deal. II 是一套有限元 C++ 库，所以在 Linux 上面需要进行编译安装。编译时，需要使用 cmake 和 make，所以先将这两个软件安装好。<br>然后依次执行下面的命令来进行编译安装：</p><pre><code class="lang-bash">cmake -DCMAKE_INSTALL_PREFIX=/path/where/deal.II/should/be/intalled/to ..make install  # (alternatively $ make -j&lt;N&gt; install)</code></pre><p>这里需要注意的是：</p><ol><li>如果 dealii 的安装为一般用户不可写的目录，需要 <code>sudo</code> 命令；</li><li>为了加快编译的速度，在第二句中，在 make 后加上 <code>-jN</code> 参数，其中 N 最好不要超过电脑的最大 CPU 数目；</li></ol><p>执行完上面的命令后，接着就是漫长的等待了。在我的机子上 (Ubuntu 14.04, x86_64, Intel® Core™ i5-2430M CPU @ 2.40GHz × 4，SSD) 编译安装总共花了将近 40 min；一般的机子大概需要 1 个小时左右。</p><h3 id="Deal-II-的配置"><a href="#Deal-II-的配置" class="headerlink" title="Deal. II 的配置"></a>Deal. II 的配置</h3><p>首先是 将 dealii 的目录加入系统环境变量之中，只需要在 <code>~/.bashrc</code> 中加入如下几行代码即可：</p><pre><code class="lang-bash"># dealii 环境变量export PATH=/opt/deal.II:$PATHDEAL_II_DIR=/opt/deal.II</code></pre><p>在具体使用时，主要使用这三个命令：</p><pre><code class="lang-bash">cmake .make # 也可以直接使用 make release, 这样编译出来的出现运行快些make run</code></pre><p>关于 deal. II 的学习，开发者为自学者提供了详尽的文档，可以在 dealii 的下载页面里找到离线的文档，并且在 dealii 的安装目录下有文档中的示例代码；</p><p>另外，dealii 的主要开发者 Wolfgan Bangerth 还在他的教学网址上提供了讲义和授课的<a href="http://www.math.colostate.edu/~bangerth/videos.html" target="_blank" rel="noopener">视频链接</a>(不过视频在 YouTube 上)。</p><p><strong>Update 20161210</strong><br>这里只是介绍了最简单的安装，要安装额外的软件库还需要自己去安装。可以参考 <a href="https://github.com/dealii/docker-files" target="_blank" rel="noopener">这里</a> 中的命令来进行安装。当然，在 Ubuntu 、Debian 、Gento 中有官方支持的版本，如果嫌麻烦，可以直接用包管理器安装。</p><h2 id="VisIt-的安装和配置"><a href="#VisIt-的安装和配置" class="headerlink" title="VisIt 的安装和配置"></a>VisIt 的安装和配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://wci.llnl.gov/content/assets/images/simulation/computer-codes/visit/visit-home.jpg" alt="VisIt Logo" title="">                </div>                <div class="image-caption">VisIt Logo</div>            </figure><h3 id="VisIt-的安装"><a href="#VisIt-的安装" class="headerlink" title="VisIt 的安装"></a>VisIt 的安装</h3><p>安装方面，首先到<a href="https://wci.llnl.gov/simulation/computer-codes/visit/" target="_blank" rel="noopener">官网</a>的下载页面里下载相关的包，并在同一页面下载 <code>Visit install script</code> 文件，具体安装过程，可以参考同一页面的 <code>Visit install notes</code> 。</p><h3 id="VisIt-的配置"><a href="#VisIt-的配置" class="headerlink" title="VisIt 的配置"></a>VisIt 的配置</h3><p>关于配置，在 <code>~/.bashrc</code> 中加入如下几行代码来添加环境变量：</p><pre><code class="lang-bash"># visit 环境变量export PATH=/opt/visit:$PATH</code></pre><p>当然，如果你想和我一样，想为 <code>VisIt</code> 添加一个快捷方式，来达到 在系统的应用里面直接点击图标就启动软件的目的，可以按照下面方法来进行。</p><p>首先创建一个名为 <code>visit.desktop</code> 的文件，然后进行编辑，将如下的内容复制到该文件中(当然你可以进行自定义)：</p><pre><code class="lang-bash">[Desktop Entry]Version=2.8.1Type=ApplicationName=VisItGenericName=image viewerComment=VisIt is an Open Source, interactive, scalable, visualization, animation and analysis tool.Exec=/opt/visit/bin/visitTerminal=falseMimeType=image/vtk;Icon=/opt/visit/visit.jpgCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><p>注意: 上面的 Icon 后面的图片是我从 visit 官网里下载的，当然可以使用其他图片。</p><p>最后保持修改的文件，然后将该文件移动到 <code>/usr/share/applications/</code> 目录中。当然，你也可以直接在这个目录中创建这个文件。这样，你就可以在系统的应用中找到 visit 了，通过点击图标就可以启动 visit。</p><h2 id="Paraview-的安装和配置"><a href="#Paraview-的安装和配置" class="headerlink" title="Paraview 的安装和配置"></a>Paraview 的安装和配置</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.paraview.org/wp-content/uploads/2018/02/ParaView_Logo.svg" alt="paraview Logo" title="">                </div>                <div class="image-caption">paraview Logo</div>            </figure><h3 id="Paraview-的安装"><a href="#Paraview-的安装" class="headerlink" title="Paraview 的安装"></a>Paraview 的安装</h3><p>当然，对于各种发行版本，对应的软件仓库里面可能已经有 paraview 的二进制包了，可以直接用相应的包管理器下载安装。</p><p>下面介绍的是自己手动安装 paraview 的过程。</p><p>首先到<a href="https://www.paraview.org/" target="_blank" rel="noopener">官网</a>的下载页面上选择适合自己机子的相应压缩包并下载。然后解压，将解压的文件夹复制到需要安装的位置即可。</p><h3 id="Paraview-的配置"><a href="#Paraview-的配置" class="headerlink" title="Paraview 的配置"></a>Paraview 的配置</h3><p>关于配置，和 visit 基本相似。</p><p>首先添加环境变量：</p><pre><code class="lang-bash"># paraview 环境变量export PATH=/opt/paraview:$PATH</code></pre><p>然后制作图标；方法与上面一致，这里只列出 <code>paraview.desktop</code> 文件的内容：</p><pre><code class="lang-bash">[Desktop Entry]Version=4.2Type=ApplicationName=ParaviewGenericName=image viewerComment=ParaView is an open-source, multi-platform data analysis and visualization applicationExec=/opt/paraview/bin/paraviewTerminal=falseMimeType=image/vtk;Icon=/opt/paraview/share/icons/hicolor/96x96/apps/paraview.pngCategories=Development;Graphics;Viewer;StartupNotify=trueActions=Window;Document;</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写这个文档的目的主要是为了进行一些纪录，好在遗忘的时候可以查看，也当做是备份。<br>有限元软件当然不止这几个，还有如 gmesh、freefem++、getfem++ 等等，这里就不介绍了。总之学习之路漫漫，吾将上下而求索。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Deal-II-的安装与配置&quot;&gt;&lt;a href=&quot;#Deal-II-的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Deal. II 的安装与配置&quot;&gt;&lt;/a&gt;Deal. II 的安装与配置&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://dealii.org/developer/doxygen/deal.II/logo200.png&quot; alt=&quot;Deal. II Logo&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;Deal. II Logo&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://fsslc.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Deal. II" scheme="https://fsslc.github.io/tags/Deal-II/"/>
    
      <category term="Paraview" scheme="https://fsslc.github.io/tags/Paraview/"/>
    
      <category term="VisIt" scheme="https://fsslc.github.io/tags/VisIt/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 想找点激烈的游戏？那就试试这 13 款 Roguelike 游戏吧！</title>
    <link href="https://fsslc.github.io/2015/04/06/Translate-Intense-Gameplay-Try-these-13-Roguelike-games/"/>
    <id>https://fsslc.github.io/2015/04/06/Translate-Intense-Gameplay-Try-these-13-Roguelike-games/</id>
    <published>2015-04-06T00:25:53.000Z</published>
    <updated>2020-03-02T06:05:59.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍 13 款 Roguelike 类游戏</p></blockquote><p>Roguelike 是角色扮演游戏的一个子类。从字面上看，它的意思是 “像 Rogue 的游戏”。Rogue 是一个关于地下城冒险的视频游戏，于 1980 年第一次发行，以极其上瘾而著称。这个游戏的目标是取得深藏于第 26 层的 “Amulet of Yendor”，再返回到顶层逃出生天。</p><p>Roguelike 的准确定义并不存在，但这类游戏通常具有下面的特点：</p><ul><li>奇幻的叙事背景；</li><li>用程序产生关卡。游戏中的绝大多数场景在开始新的游戏时由游戏自动创建。这样做是为了鼓励玩家不断重玩; </li><li>回合制的地下城探险和战斗；</li><li>随机生成的基于贴片的图形环境；</li><li>随机发生战斗；</li><li>永久死亡 ：在游戏中，死亡真的存在，一旦你的角色死了，那就真的结束了；</li><li>高难度。</li></ul><a id="more"></a><p>这篇文章精心挑选了一些可运行在 Linux 平台下的 roguelike 游戏。假如你喜欢激烈、易上瘾的游戏，可以尝试这 13 款游戏。不要因它们原始的画质而退缩，一旦你沉浸其中，你将很快忘记画面的简陋。所有的这些都可以免费下载，并且几乎所有的游戏都是在开源协议下发行的。</p><hr><h3 id="Dungeon-Crawl-Stone-Soup"><a href="#Dungeon-Crawl-Stone-Soup" class="headerlink" title="Dungeon Crawl Stone Soup"></a>Dungeon Crawl Stone Soup</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183124a6h6arh02l26yxpy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dungeon Crawl Stone Soup 是一个开源的，单用户角色扮演类的 roguelike 游戏，玩家要在遍布危险而充满敌意的怪兽的地下城中进行探险和寻找宝藏，并在任务中拯救传说中的神秘 Zot 宝珠。</p><p>Dungeon Crawl Stone Soup 是 Linley 开发的 Dungeon Crawl 游戏的延续。它是公开开发的，并邀请 Crawl 社区的人员来参与其中。</p><p>Dungeon Crawl 有着超棒且深层次的战术游戏环节，创新的魔法和信仰系统，以及数量宏大的和你战斗的怪兽。Crawl 也是最难以攻陷的 roguelike 游戏之一。当你最终在游戏中通关，将胜利宣言张贴在 rec.games.roguelike.misc 时，你才会知道这有多么令人骄傲！</p><p>特点包括:</p><ul><li>丰富多彩的、富含深层次战术的 roguelike 游戏；</li><li>手绘地图；</li><li>无数的金库；</li><li>漂亮的界面；</li><li>创新的魔法和信仰系统；</li><li><p>各种神灵，角色，物品和聪明的怪兽；</p></li><li><p>网站: <a href="http://crawl.develz.org/" target="_blank" rel="noopener">crawl.develz.org</a></p></li><li>开发者: Stone Soup 开发小组</li><li>协议: Crawl General Public License</li><li>版本号: 0.15.2</li></ul><hr><h3 id="Dwarf-Fortress"><a href="#Dwarf-Fortress" class="headerlink" title="Dwarf Fortress"></a>Dwarf Fortress</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183127v0p0456e0nmnr0lp.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dwarf Fortress 是一个单人魔幻游戏，与 NetHack 类似。你可以在一个随机生成的持久的世界中，控制一个矮人哨兵或一个冒险者。</p><p>这个游戏的特色有：三种游戏模式(矮人要塞，冒险者，传说模式)，一个独特的随机生成的世界(由地形，野生生物和传奇生物等组成)， 阴森的战斗机制以及各种邪恶鱼群。</p><p>特点包括：</p><ul><li>在这个世界里，你想玩多久都可以。可以经历许多次游戏，记录历史事件，对更改进行跟踪等；</li><li>当你扮演的矮人在山群中寻找宝藏时，你可以对他们下达命令<ul><li>用各种材料来手工制作珍宝、物品，并可以用贵重金属、宝石等来改进它们；</li><li>通过各种手段保护你自己，防御来自敌对文明的袭击；</li><li>支持贵族，他们会管理你的民众</li><li>让你的矮人高兴起来，了解他们工作和休闲时的想法；</li><li>不同的 Z 坐标可以使你在多个层级上建造你的堡垒。建立塔台或征服地下深处；</li><li>建立水闸来灌溉作物或用水淹没你的对手；</li></ul></li><li>扮演一个探险者并进行探索，为荣誉而战或复仇<ul><li>与以前的游戏中的对手相遇；</li><li>在你经过的旅途中营救小城里的人们；</li><li>没有繁琐的情节，只需要探索；</li><li>无缝连接的漫游游戏世界-总共达到 197376 x 197376 平方 -可以在区域地图上更快速地穿行；</li><li>接受小镇或文明社会的领导所委托的任务；</li><li>可以找到你以前的角色，以一个新的角色带上他们来一场新的冒险，或者直接重新激活并使用他们；</li><li>通过 Z 轴使得你可以在各个地下城的不同层级间和结构间平滑的上下移动来和对手战斗；</li></ul></li><li>战斗模式是通过技巧、身体部位、搏斗、在不同区域间蓄势和躲避，体验流血、疼痛，恶心及其他感受；</li><li>一个动态的天气模型跟踪风，湿度及空气流动，以创造冷暖气流锋面、风、暴风雨雪；</li><li>超过 200 种岩石和矿物类型被引入到了游戏世界，它们被放置在合适的地理环境中；</li><li>通过可更改的文本文件来添加生物，武器，植物，金属和其他对象；</li><li><p>以 16 色(包括黑色)渲染的扩展 ASCII 字符集，以及 8 种背景颜色(包括黑色); </p></li><li><p>网站: <a href="http://www.bay12games.com/dwarves/index.html" target="_blank" rel="noopener">www.bay12games.com/dwarves/</a></p></li><li>开发者: Tarn Adams</li><li>协议: 免费软件</li><li>版本号: 0.40.19</li></ul><hr><h3 id="Ancient-Domains-of-Mystery"><a href="#Ancient-Domains-of-Mystery" class="headerlink" title="Ancient Domains of Mystery"></a>Ancient Domains of Mystery</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183129gnog9not3lggaso3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ancient Domains of Mystery (ADOM) 是一个 rogue-like 游戏，从 1994 年至今一直在不断开发。</p><p>它是一个包含复杂地下城的单用户游戏。你控制一个用种族、类别、属性、技巧和装备等描述的虚构角色。这个虚构角色正尝试着达到一个特定的目标（参考下面的介绍）并在一个困难的任务中取胜。为了完成任务，你必须在以前没有发现的隧道和地下城中探险，和丑陋的怪兽战斗，解开一系列遗忘的秘密，并找到宝藏。</p><p>在游戏期间，你在每次游戏时随机生成的各层地下城中探索。你也可能遇到某个特定的关卡，其中有着特定的挑战或者围绕某个特定主题而生成。</p><p>特点包括:</p><ul><li>拥有上百个地点的巨大游戏世界，例如城堡、随机生成的地下城、主题寺庙、墓地、古代遗迹、塔台和其他名胜；</li><li>各种各样的种族（矮人、drakeling、雾精灵、hurthling、兽人、巨魔、ratling 等等）（LCTT注：种族信息可以参考<a href="http://ancardia.wikia.com/wiki/Race" target="_blank" rel="noopener">这里</a> 和丰富的职业（战士、 元素法师、 刺客、 混沌骑士，决斗士等等）带来无限的游戏乐趣；</li><li>上百个怪兽和物品，其中的许多带有随机的增强特性；</li><li>迫使你在对力量的欲望和对诅咒的恐惧之间进行权衡的腐败体系；</li><li>法术、祈祷、思想技艺、炼金术、手工艺和更多；</li><li>多样的任务和分支故事主线；</li><li><p>许多完全不同的结局，可能改变现实本身。</p></li><li><p>网站: <a href="http://www.adom.de/" target="_blank" rel="noopener">www.adom.de</a></p></li><li>开发者: Thomas Biskup</li><li>协议: Postcardware</li><li>版本号: 1.20 Prelease 20</li></ul><hr><h3 id="Tales-of-Maj’Eyal-ToME"><a href="#Tales-of-Maj’Eyal-ToME" class="headerlink" title="Tales of Maj’Eyal (ToME)"></a>Tales of Maj’Eyal (ToME)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183205sa8m8jxbugiuubou.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Tales of Maj’Eyal (ToME) (注：中文译名为 马基埃亚尔的传说) 是一个免费、开源的 roguelike 角色扮演游戏，包含特色的战术回合制战役和先进角色构建。它作为运行在 T-Engine 4.0 中的一个模块而被创造。</p><p>现在处于王权世纪(Age of Ascendancy)，在长达一万年的冲突痛苦和混乱之后，我们所知的世界终于进入了一个相对和平的时期。 “魔法大爆裂（Spellblaze）” 留下的影响已经大为减缓, 大地的伤痕也慢慢地开始愈合。在薪火世纪（Age of Pyre）之后，各个文明也纷纷开始重建家园。(注：翻译来源于 <a href="http://www.qiyun.org/zhuanti/majiaiyaerdechuanshuo.htm" target="_blank" rel="noopener">这里</a>)</p><p>特点包括:</p><ul><li>适合于那些没有 rogueline 体验的玩家；</li><li>同时支持图形界面和 ASCII 模式；</li><li>某些角色拥有多达 40 种的能力；</li><li>天赋系统；</li><li>战役引擎；</li><li>在线的持久状态/成就追踪；</li><li>IRC 聊天客户端；</li><li>可扩展，可修改；</li><li>充满激情的音乐；</li><li><p>可解锁新的种族，类别，起始点，游戏模式和特点等；</p></li><li><p>网站: <a href="http://te4.org/" target="_blank" rel="noopener">te4.org</a></p></li><li>开发者: ToME 开发团队</li><li>协议: GNU GPL v3.0</li><li>版本号: 1.2.5</li></ul><hr><h3 id="Cataclysm-Dark-Days-Ahead"><a href="#Cataclysm-Dark-Days-Ahead" class="headerlink" title="Cataclysm Dark Days Ahead"></a>Cataclysm Dark Days Ahead</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183208illnjjazel3j3axn.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Cataclysm 是一个开源的 “后末世” roguelike 游戏，背景设定在由怪兽和僵尸带来的毁灭性的瘟疫后虚构的新英格兰(New England) 乡村。它是 Whale 开发的原有 Cataclysm 的继续，拓展了更多新的生物，建筑，游戏机制和其他特点。</p><p>尽管有些人描述它为一个 “僵尸游戏”，但 Cataclysm 远比一个“僵尸游戏”包含更多内容。玩家要在一个由程序生成的严酷、持久的世界中艰难生存下去。在一个死寂的文明世界中搜寻剩下的食物和装备，或者假如你足够幸运，搞到一辆装满汽油的汽车逃离 Dodge —这个如地狱一般的地方。从僵尸到巨型昆虫或机器人杀手以及更加奇怪和致命的东西，你要通过战斗来击败它们或逃离，以及和那些想要抢夺你的东西的那些同你一样的人战斗。</p><p>在许多方面上， Cataclysm 与大多数的 roguelike 游戏不同。它被设定在一个没有边界的三维世界里，而不是设定在一个垂直、线性的地下城中。这意味着相比于大多数的 roguel 游戏，探险将占一个更大的比重，而且这个游戏将具有更大的自由度。由于地图是如此的巨大，在每次游戏之间，它可以完全保持原样。假如你死了，并以一个新的角色开始，你的新游戏将会设定在同你最近呆过的游戏世界相同的世界里。同许多 roguelike 游戏一样，你可以获得先前角色的战利品；而与大多数 roguelike 不同的是，你也可以重新踏上先前角色的轨迹，并且对世界做出的任何戏剧性改变将会维持到你的下一次游戏。</p><p>特点包括:</p><ul><li>详细的角色创建，提供了数量众多的特性来选择；</li><li>防御模式，这是一个有着快节奏作战的休息模式；</li><li>Bionics；类似于在许多其他游戏里的魔法系统；</li><li>基因突变, 有好的和坏的变化；</li><li>无界的，完全随机的世界地图，可以在角色交替时保持不变；</li><li>创造物品<ul><li>新的制作方法可能需要通过练习或从书本中获得来磨练你的知识；</li></ul></li><li>逼真的火、烟和其他动态的地图特效；</li><li>昼/夜循环，需要睡觉。假如你必须的话，可以使用咖啡因来保持更长时间的清醒，但这不健康；</li><li>超过 300 种物品类型，包括众多的现实世界的枪支，药品和工具；<ul><li>许多药品是上瘾的，并需要持续使用来避免负面效果；</li></ul></li><li>通过修补门、窗、建造陷阱和巩固你的家的基石来防止一个僵尸的突然造访；</li><li>能够构建你自己的木屋，包括墙和屋顶；</li><li>可以驾驶在“后末世”发现的汽车兜风；<ul><li>这个可以根据你的需求来修改，或甚至你可以自己制造一辆；</li></ul></li><li>温度系统，太冷或太热都非常危险；</li><li>初步支持贴片界面；</li><li><p>根据选项生成世界，以及各种编辑方式；</p></li><li><p>网站: <a href="http://en.cataclysmdda.com/" target="_blank" rel="noopener">en.cataclysmdda.com</a></p></li><li>作者: Kevin Granade 及其他</li><li>协议: Creative Commons Attribution-ShareAlike 3.0 Unported License</li><li>版本号: 0. B</li></ul><hr><h3 id="Goblin-Hack"><a href="#Goblin-Hack" class="headerlink" title="Goblin Hack"></a>Goblin Hack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183221dhwiojw8fe7900wo.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Goblin Hack 是一个开源 roguelike 游戏，基于 OpenGL 的平滑滚动的ASCII 图形界面。这个游戏受 NetHack 外观的启发，但更加快速且使用更少的按键。</p><p>Goblin Hack 有一个简洁的界面，在今天这个过度强调渲染的游戏世界中，似乎它对所有年龄段的玩家都有吸引力，并启发了这些玩家的想象力。</p><p>在被投进一个随机的正在生成的地下城之前，玩家可以从几个角色类别中选择一个角色。</p><p>特点包括:</p><ul><li>令人印象深刻的界面(相比于许多其他的 roguelike 游戏)；</li><li>简洁的界面；</li><li>在被投进一个随机的正在生成的第一层地下城之前，玩家可以从几个角色类别中选择一个角色；</li><li><p>手动保存游戏；</p></li><li><p>网站: <a href="http://goblinhack.sourceforge.net/" target="_blank" rel="noopener">goblinhack.sourceforge.net</a>, <a href="https://github.com/goblinhack/goblinhack" target="_blank" rel="noopener">github.com/goblinhack/goblinhack</a></p></li><li>作者: Neil McGill</li><li>协议: GNU GPL v2</li><li>版本号: 1.19</li></ul><hr><h3 id="SLASH’EM"><a href="#SLASH’EM" class="headerlink" title="SLASH’EM"></a>SLASH’EM</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183224ckiy2wsxoj705x0e.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Super Lotsa Added Stuff Hack - Extended Magic (SLASH’EM) 是一个角色扮演游戏，在其中你控制一个单独的角色。SLASH’EM 是 NetHack 的一个变种。它拥有一个和 Rogue、ADOM、Anghand 及 NetHack 相似的界面和游戏玩法。你通过键盘来控制角色的动作，以一个俯视的视角来查看这个世界。</p><p>背景： Amulet of Yendor 已被偷走，不仅如此，偷走 amulet 的 Wizard of Yendor（坏蛋）似乎深藏于 Dungeons of Doom（危险的地方）。</p><p>特点包括:</p><ul><li>提供额外的特色、怪兽和项目；</li><li>新颖的特点包括僧人职业和类似推箱子的关卡；</li><li><p>主地下城比在 NetHack 中的要大很多；</p></li><li><p>网站: <a href="http://www.slashem.org/" target="_blank" rel="noopener">www.slashem.org</a></p></li><li>开发者:  Slash’EM 开发团队</li><li>协议: MIT License, NetHack General Public License</li><li>版本号: 0.0.7E7F3</li></ul><hr><h3 id="NetHack"><a href="#NetHack" class="headerlink" title="NetHack"></a>NetHack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183227gbbvxbzzajneo07k.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>NetHack 是一个极简，但又非常吸引人的具有地下城与龙风格的冒险游戏。“net”元素指的是它的发展已经根据网络进行了调整，“hack”元素指的是角色扮演游戏的一种类型，以乱砍、猛砍著称，着眼于战斗。</p><p>在 NetHack 中，你扮演凶猛的战士、巫师或许多其他职业中的一种，一路战斗着，为你的神灵获取 Amulet of Yendor（可以说这是一个倒退!）。在这个过程中，你可能会遇到一个或两个 quantum mechanic（LCTT 译注：从<a href="http://nethack.wikia.com/wiki/Quantum_mechanic" target="_blank" rel="noopener">这里</a>得知，这指的是一种怪兽），或者可能遇到一个小型的太空舰队，抑或是 —— 假如你<em>足够</em>幸运会遇到 —— Ravenous Bugblatter Beast of Traal。（LCTT 译注：我参考了<a href="http://nethack.wikia.com/wiki/Douglas_Adams" target="_blank" rel="noopener">这里</a>）。</p><p>特点包括:</p><ul><li>45-50 个关卡, 其中的大多数随机生成；</li><li>各种各样的物品：武器、盔甲、卷轴、药水、戒指、宝石和各种各样的工具，如钥匙和灯；</li><li>祝福和诅咒；</li><li>永久死亡: 若没有对当前的保存文件进行备份，失效的角色就找不回来了；</li><li><p>界面：</p><ul><li>文本模式；</li><li>图形化界面， 使用 X、Qt 工具集或 GNOME 库；</li></ul></li><li><p>网站: <a href="http://www.nethack.org/" target="_blank" rel="noopener">www.nethack.org</a></p></li><li>开发者: NetHack 开发团队</li><li>协议: NetHack 通用公共许可证</li><li>版本号: 3.4.3</li></ul><hr><h3 id="Ascii-Sector"><a href="#Ascii-Sector" class="headerlink" title="Ascii Sector"></a>Ascii Sector</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183228gztj827ygcvg8gq7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Ascii Sector 是一个免费的太空战斗/探险/交易游戏，它基于经典的电脑游戏 <code>Wing Commander: Privateer</code> ，后者由 Origine Systems 公司于 1993 年发布。</p><p>在 Ascii Sector 中，刚开始你将驾驶一艘简易的飞船，然后可以通过接受任务或者贩卖物品来挣得足够多的钱以升级你的飞船或重新再买一艘。不管是在太空中，还是在地面上，抑或是在飞船上，你可以专注于致命的战斗；并且通过使用 Ascii Sector 的脚本语言，你还可以为游戏创造自己的任务或享受其他玩家创造的任务。</p><p>特点包括:</p><ul><li>使用 ANSI 字符集生成图形界面；</li><li>真正的深入到游戏中；</li><li>提供各种基地，任务，商品和飞船；</li><li>飞船型号包括: Broadsword, Centurion, Demon, Dralthi, Drayman, Galaxy, Gladius, Gothri, Kamekh, Nexus, Orion, Paradign, Stileto, Talon, Tarsus 和 Ulysses；</li><li>四个象限: Alizarin, Crimson, Mauve, 和 Viridian；</li><li>可下载的任务；</li><li>任务可用脚本编辑；</li><li>Ascii Sector 任务语言，在 Ascii Sector 宇宙中创造你自己的故事；</li><li>可以袭击或抢劫星球上的 NPC（非玩家控制角色）；</li><li>可以到处移动的持久性舰队、可以改变系统的控制、引来敌人的舰队、回基地修复或重建；</li><li>可以登录系统受损的飞船；</li><li><p>可下载高质量的音乐文件；</p></li><li><p>网站: <a href="http://www.asciisector.net/" target="_blank" rel="noopener">www.asciisector.net</a></p></li><li>开发者: Christian Knudsen</li><li>协议: 免费软件</li><li>版本号: 0.7.1.4</li></ul><hr><h3 id="Angband"><a href="#Angband" class="headerlink" title="Angband"></a>Angband</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183229e4fp5p4yuy0oaoqc.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Angband 是一个免费、单用户、使用 ASCII 字符图形化的地下城探险游戏，在其中你将以一个冒险者的角色探索一个深深的地下城，与怪兽战斗，获得你能取得的最好武器，准备着与黑暗之主 Morgoth 的最后决战。从上世纪九十年代开始，它一直在持续地开发着。</p><p>Angband 沿袭了 Rogue 和 NetHack 的风格路线。它由 Moria 和 Umoria 游戏衍生而来，基于 Rogue 回合制。它经常被描述为一个 “roguelike”游戏，因为它的外观和游戏体验与 Rogue 非常相似。很多游戏中的新生物、物品都来自 J. R. R Tolkien 的画作，尽管有些野兽直接来源于经典的神话、龙与地下城、Rolemaster，或 Angband 的原开发者的脑海中。</p><p>特点包括:</p><ul><li>100 层地下城；</li><li>随机产生的新关卡；</li><li>可以选择成为人类、半精灵、精灵、霍比特人、地精、矮人，半兽人，半巨魔， 登丹人 ，高等精灵，或者狗头人；</li><li>神器；</li><li>施法；</li><li>怪物；</li><li>怪物坑；</li><li><p>怪物巢穴；</p></li><li><p>网站: <a href="http://rephial.org/" target="_blank" rel="noopener">rephial.org</a></p></li><li>开发者: Angband 开发小组</li><li>协议: GNU GPL v2</li><li>版本号: 3.5.0</li></ul><hr><h3 id="UnNetHack"><a href="#UnNetHack" class="headerlink" title="UnNetHack"></a>UnNetHack</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183231lfcue7f22idy7g5j.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>UnNetHack 是 NetHack 的一个分支版本。NetHack 最开始于 1987 年发行，并且许多游戏玩家认为它是计算机世界所能提供的最好游戏体验的游戏之一。</p><p>特点包括：</p><ul><li>增加了许多针对 NetHack 的增强，如额外的怪兽、更多的关卡、许多新的元素、更多的危险、更具挑战性的游戏，以及最重要的，相比普通的 NetHack，它更具娱乐性；</li><li><p>帮助新手开始的教程；</p></li><li><p>网站: <a href="http://sourceforge.net/apps/trac/unnethack/" target="_blank" rel="noopener">sourceforge.net/apps/trac/unnethack</a></p></li><li>作者: Patric Mueller</li><li>协议: Nethack General Public License</li><li>版本号: 5.1.0</li></ul><hr><h3 id="Hydra-Slayer"><a href="#Hydra-Slayer" class="headerlink" title="Hydra Slayer"></a>Hydra Slayer</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183238turvck9u5rnkzdac.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Hydra Slayer 是一个专注于杀死九头蛇的开源 Roguelike 游戏。它受到了希腊神话、地下城探险、MathRL seven day roguelike ，和一些关于勇者杀死多头野兽的数字谜题等启发。</p><p>特点如下:</p><ul><li>独特的游戏机制；</li><li>混合希腊神话和数字迷宫的主题；</li><li>传统的 roguelike ASCII 字符界面或贴片/3D 界面；</li><li>5 种人物角色，具有极为不同的战术、力量及弱点；</li><li>28 种敌人类型:<ul><li>10 种基本的九头蛇类型（每种类型都有两种变种）；</li><li>8 种特殊类型的敌人；</li><li>可用作战术工具的无害蘑菇；</li></ul></li><li>28 种装备（并包括材料和装备的大小/力量的变种）；</li><li>15 种武器材料；</li><li>18 种非装备物品；</li><li>3 种可供选择的地图；</li><li>8 种关卡拓扑结构（包括莫比乌斯带和克莱因瓶）；</li><li>11 个关卡生成器；</li><li><p>2 种结局；</p></li><li><p>网站: <a href="http://www.roguetemple.com/z/hydra/" target="_blank" rel="noopener">www.roguetemple.com/z/hydra</a></p></li><li>开发者: Zeno Rogue</li><li>协议: GNU GPL v2</li><li>版本号: 16.1</li></ul><hr><h3 id="Brogue"><a href="#Brogue" class="headerlink" title="Brogue"></a>Brogue</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201504/04/183246gya2gf712y4y011i.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Brogue 是一个开源的 Roguelike 游戏，它可以运行在 Mac OS X, Windows, Linux, iOS 和 Android 等平台下。</p><p>Brogue 是 Rogue 的一个直系分支，后者是一个最早由 Michael Toy 和 Glenn Wichman 于 1980 年左右开发的地下城探险视频游戏。与其他受欢迎的现代 Roguelike 游戏不同， Brogue 追求简单而不是复杂性，同时尽力确保游戏的不同组成之间的联系是有趣且纷繁多彩。</p><p>这个游戏的目标是取得深藏于地下第 26 层的 “Amulet of Yendor”，再返回到地面逃出生天。对于那些技术娴熟且想进一步探险的人来说，位于 26 层之下的每层均包含 3 颗 lumenstone （流明石）(LCTT 译注：此处与我在<a href="http://brogue.wikia.com/wiki/Lumenstone" target="_blank" rel="noopener">这里</a>看到的有些出入），获得它们，将在胜利的基础上被授予额外的得分。</p><p>Brogue 是一个富有挑战性的游戏，但玩起来非常有趣。尽量不要因游戏的高难度而灰心；试玩一段时间之后，你会发现它变得非常吸引人。</p><p>特点如下:</p><ul><li>追求简单而非复杂；</li><li>对用户友好；</li><li>相比于 Rogue， Brogue 关卡生成更加复杂；</li><li>移除了 XP 和 水平系统 ；</li><li>陷阱，防护性物品；</li><li><p>额外的怪兽类型和魔法物品；</p></li><li><p>网站: <a href="lhttps://sites.google.com/site/broguegame/">sites.google.com/site/broguegame</a></p></li><li>作者: Brian Walker</li><li>协议: GNU Affero GPL</li><li>版本号: 1.7.3</li></ul><hr><p>via: <a href="http://www.linuxlinks.com/article/201412031524381/RoguelikeGames.html" target="_blank" rel="noopener">http://www.linuxlinks.com/article/201412031524381/RoguelikeGames.html</a><br>public: <a href="https://linux.cn/article-5200-1.html" target="_blank" rel="noopener">https://linux.cn/article-5200-1.html</a></p><p>作者：Frazer Kline<br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍 13 款 Roguelike 类游戏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Roguelike 是角色扮演游戏的一个子类。从字面上看，它的意思是 “像 Rogue 的游戏”。Rogue 是一个关于地下城冒险的视频游戏，于 1980 年第一次发行，以极其上瘾而著称。这个游戏的目标是取得深藏于第 26 层的 “Amulet of Yendor”，再返回到顶层逃出生天。&lt;/p&gt;
&lt;p&gt;Roguelike 的准确定义并不存在，但这类游戏通常具有下面的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇幻的叙事背景；&lt;/li&gt;
&lt;li&gt;用程序产生关卡。游戏中的绝大多数场景在开始新的游戏时由游戏自动创建。这样做是为了鼓励玩家不断重玩; &lt;/li&gt;
&lt;li&gt;回合制的地下城探险和战斗；&lt;/li&gt;
&lt;li&gt;随机生成的基于贴片的图形环境；&lt;/li&gt;
&lt;li&gt;随机发生战斗；&lt;/li&gt;
&lt;li&gt;永久死亡 ：在游戏中，死亡真的存在，一旦你的角色死了，那就真的结束了；&lt;/li&gt;
&lt;li&gt;高难度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Roguelike" scheme="https://fsslc.github.io/tags/Roguelike/"/>
    
      <category term="游戏" scheme="https://fsslc.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 让你玩转 Ubuntu 桌面的十一件武器</title>
    <link href="https://fsslc.github.io/2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/"/>
    <id>https://fsslc.github.io/2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/</id>
    <published>2015-03-11T01:00:00.000Z</published>
    <updated>2020-03-01T16:28:56.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能</p></blockquote><p><strong>无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。</strong></p><p>从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你<strong>调整 Ubuntu ，随时满足你的需求</strong>。</p><a id="more"></a><p>注意： Ubuntu 总是配备了‘合理的默认设置’（即工作良好的选项），以达到开箱即用，这些默认设置适合大多数人，并且它们都是经过了测试、采用及推荐等过程的。</p><p>但一个尺码并不适合所有人。对于我们当中的能工巧匠和实验主义者来说，默认设置只是他们定制系统的起点。</p><p>所以，无需更多的唠叨， 这里有 11 个极好的实用工具可以帮助你增强 Ubuntu 使用体验。</p><h3 id="Unity-Tweak-Tool"><a href="#Unity-Tweak-Tool" class="headerlink" title="Unity Tweak Tool"></a>Unity Tweak Tool</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004329h9lncxutj7s98l66.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我将以这个列表中最重要的一个工具: <strong>Unity Tweak Tool</strong> 来开始这次的介绍。融汇了各种定制选项，Unity Tweak Tool 提供了一系列针对 Ubuntu 和 Unity 桌面的系统综合调整功能。</p><p>它被各种开关、切换和控制器塞得满满的，使得你可以任意设置从 Unity 桌面的外观到 Unity 的行为之类的任何东西。你可以使用它<strong>快速简便地改变 GTK 主题和图标集</strong>、设置热区、调整启动器图标尺寸、增加或移除工作区，以及 —-特别地—-开启 Unity 桌面中被巧妙隐藏的“通过点击最小化”的功能。</p><p>它是免费的，可直接从 Ubuntu 软件中心里找到， Unity Tweak Tool 是非常值得保留在你的口袋里的工具之一。</p><h3 id="Unity-隐私指示器"><a href="#Unity-隐私指示器" class="headerlink" title="Unity 隐私指示器"></a>Unity 隐私指示器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004331vjf9qq1vv3jq7913.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>隐私是一个非常、非常重要的事，事实也恰恰如此，但这个话题要比二进制还难以说明白。让一些数据或习惯，比如说你经常打开的应用，在本地被记录下来，这或许会让你感到高兴，但对于你在 Dash 中的搜索数据被发送到第三方服务机构(尽管这些数据或许是匿名的)这类事情，你就高兴不起来了。</p><p><a href="http://www.florian-diesch.de/software/indicator-privacy/index.html" target="_blank" rel="noopener">隐私指示器</a> 是一个帮助你时刻跟踪 Ubuntu桌面系统中有哪些文件、目录和服务正被获取、记录及搜索的实用工具。</p><p>通过快速的点击被添加到桌面面板上的‘眼睛’图标，你可以：</p><ul><li>开启或关闭在线搜索结果，使用 Zeitgeist 记录系统活动，存储 HUD 使用记录和启用 Ubuntu GeoIP 服务</li><li>快速清理 Zeitgeist 日志、 ALT-F2 历史、最近访问文件等等的记录数据</li><li>展示或隐藏桌面图标及面板上显示的用户名</li></ul><p>上述的最后一条的功能似乎不应该出现在这个应用程序中，但对于那些要分享截图或截屏的人来说，这将会泄露更少的隐私。</p><ul><li><a href="http://www.florian-diesch.de/software/indicator-privacy/dist/indicator-privacy_0.04-1_all.deb" target="_blank" rel="noopener">从这里下载隐私指示器 (.deb)</a></li></ul><h3 id="Unity-橱窗"><a href="#Unity-橱窗" class="headerlink" title="Unity 橱窗"></a>Unity 橱窗</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004337qh83z5gv3pwq7s8h.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>Android, iOS, OS X, Chrome OS, 和 GNOME Shell 都有应用橱窗, 借助一个极好的第三方应用，Unity 也可以实现类似功能。</strong></p><p>“Unity 橱窗” 允许你将 Unity 启动器中的应用分组到实用的橱窗中，—- 如游戏，办公，社交等。不必打开 Dash，你就可以快速启动你喜爱的应用，这非常适合你的工作流。</p><p>每一个 ‘橱窗’其实上是一个打开在图标附近的应用窗口，但总体效果看上去就像是一个 OS X 风格的“堆栈”或 Android 的分组框。</p><p>橱窗的图标可以自定义或根据橱窗内的应用来自动生成。已有的橱窗可以修改和重新组织、重命名以及如下的更多选择：</p><ul><li>根据你的喜好创建任意多的橱窗</li><li>选择自定义或自动生成橱窗图标</li><li>可选择 3 种橱窗样式</li><li>为添加到橱窗中的应用设定自定义图标</li><li>编辑现有橱窗</li></ul><p><a href="http://unity-folders.exceptionfound.com/" target="_blank" rel="noopener">Unity 橱窗的网址</a></p><h3 id="咖啡因（Caffeine）"><a href="#咖啡因（Caffeine）" class="headerlink" title="咖啡因（Caffeine）"></a>咖啡因（Caffeine）</h3><p>对于我们中的许多人来说，咖啡因是必需品，而不仅仅是饮料。而这里的“咖啡因”则提供了一个快速，温和的方式来避免屏保/锁屏占据屏幕。它的有用程度将取决于你的环境(即你系统的怪癖)，并且尽管它不像以前那样好用，它仍然值得你<a href="http://www.omgubuntu.co.uk/2014/05/stop-ubuntu-sleeping-caffeine" target="_blank" rel="noopener">尝试一下</a>。</p><p><a href="https://launchpad.net/~caffeine-developers/+archive/ppa/+files/caffeine_2.7_all.deb" target="_blank" rel="noopener">下载咖啡因（Caffeine） </a></p><h3 id="系统监控指示器"><a href="#系统监控指示器" class="headerlink" title="系统监控指示器"></a>系统监控指示器</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004338tii8ix884b8tz81r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假如你是一个状态迷，即一个喜欢密切关注程序，进程和硬件的状态的人， Linux 很容易满足你的需求。从 Conky 的配置到终端命令，并不缺少监视你的 CPU 使用情况、网络流量或 GPU 温度的方法。</p><p>但至今为止，我最喜爱的应用是<strong>系统监控指示器</strong>（也被叫做多负载指示器），它可从 Ubuntu 软件中心获得。它也有着大量的配置选项。</p><ul><li><a href="apt://indicator-mulitload">点击这个链接，在 Ubuntu 中下载 ‘系统监控指示器’</a></li></ul><h3 id="针对-Linux-笔记本电脑的省电工具"><a href="#针对-Linux-笔记本电脑的省电工具" class="headerlink" title="针对 Linux 笔记本电脑的省电工具"></a>针对 Linux 笔记本电脑的省电工具</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004339r5tvyyli0enujnty.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h4><p>当提到便携式设备上的电池使用效率时，Linux 发行版的声誉并不算好。</p><p>如果你的 Linux 笔记本在重新充电前，电池只够让你从沙发走到厨房的话，那么这里有几个你可以试试的工具。</p><p>TLP 是最受欢迎的确保延长 Linux 笔记本的电池寿命的自动化后台工具之一，它是通过调整系统进程和硬件的设置及行为来达成省电的，例如 启动 Wi-Fi 省电模式， PCI 总线设备的实时电量管理和处理器的降频调整。</p><p>在 Ubuntu 14.04 LTS 以及后续发行版本中可以<a href="https://launchpad.net/~linrunner/+archive/ubuntu/tlp/+packages" target="_blank" rel="noopener">使用 TLP 专用的 PPA 来安装它</a>，通过它的‘一下搞定’的设置就能用起来。在我们之中的高级用户可以潜心研究并根据你自己的硬件来调整设置，一个<a href="http://linrunner.de/en/tlp/docs/tlp-configuration.html" target="_blank" rel="noopener">关于 TLP 的完整指导 wiki</a> 使得设置更加容易。</p><h4 id="Laptop-Mode-Tools"><a href="#Laptop-Mode-Tools" class="headerlink" title="Laptop Mode Tools"></a>Laptop Mode Tools</h4><p>假如 TLP 听起来有一点复杂，这也并没有什么可羞耻的，这里有一个更简单的替代品： <strong>Laptop Mode Tools</strong>。 这个软件包可从 Ubuntu 软件中心直接安装，且本身设置好了一系列合理的默认设置(Wi-Fi,蓝牙等等)。</p><p>切记，Laptop Mode Tools 不能和 TLP 同时被安装在电脑中。</p><ul><li><a href="https://apps.ubuntu.com/cat/applications/laptop-mode-tools/" target="_blank" rel="noopener">Ubuntu 软件中心里的 Laptop Mode Tools </a></li></ul><h3 id="Intel-显卡驱动安装工具"><a href="#Intel-显卡驱动安装工具" class="headerlink" title="Intel 显卡驱动安装工具"></a>Intel 显卡驱动安装工具</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004340x03qzr5r0cpo3ddb.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对于那些运行 Intel 显卡硬件，并想使得这些硬件发挥出最佳性能的人来说，Intel 显卡安装工具是必须拥有的。 它使得查找并安装最新的 Intel GPU 驱动变得不再是一件痛苦和大费周折的事，因为这无需 PPA 或任何的终端使用知识。</p><ul><li><a href="https://01.org/linuxgraphics/downloads/2014/intelr-graphics-installer-linux-1.0.7" target="_blank" rel="noopener">下载针对 Linux平台的 Intel 显卡驱动安装器 0.7 版本</a></li></ul><h3 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004342ux0qm9a244szxjqx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>假如你计划升级你的 PC 或想替换一个坏掉的零部件，你需要知道一些特定的硬件信息，例如 RAM 类型，CPU插座类型 或查看哪个 PCI 槽是可用的等信息。</p><p><strong>I-Nex</strong>可以使得找出这些以及其他的系统具体配置变得更加容易。使用它来查找你的主板型号、S.M.A.R.T.(注：为 Self-Monitoring, Analysis and Reporting Technology 的缩写，经常写为 SMART ) 状态，以及你想的出的很多东西！</p><ul><li><a href="https://launchpad.net/i-nex" target="_blank" rel="noopener">可从 Launchpad 了解到更多关于 I-Nex 的信息</a></li></ul><h3 id="磁盘空间可视化程序"><a href="#磁盘空间可视化程序" class="headerlink" title="磁盘空间可视化程序"></a>磁盘空间可视化程序</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004343whhai9rxqxh5hrah.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在这个硬盘以 TB 计数的时代，我们或许不必同以前一样对硬盘空间的使用三思而后行。但对于那些使用小容量的 SSD，分成多个分区或在一个拥有固定大小的虚拟磁盘的虚拟机上工作的人来说，总有“应该释放一些额外空间是必要的”这种想法的时候。</p><p>GNOME Disks，在 Ubuntu 中被默认安装，使得查找占用最大磁盘空间的罪魁祸首变得容易。对于定位隐藏的日志、缓存和视频文件，它是非常完美的工具。</p><h3 id="BleachBit-Cruft-Cleaner"><a href="#BleachBit-Cruft-Cleaner" class="headerlink" title="BleachBit (Cruft Cleaner)"></a>BleachBit (Cruft Cleaner)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/11/004344vbyyaa4w8582lpn4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Windows 用户可能对像 CCleaner 之类的应用很熟悉，它可以扫描并清理垃圾文件、空白文件夹、臃肿的缓存以及陈旧的软件包。在 Ubuntu 上，一个相似的快速且毫不费力的一键式清理方法可以试试 <strong>BleachBit</strong> 。</p><p>它是一个强大的工具，所以一定要注意你正在清理什么。不要漫无目的地确认每个选项框；不是所有的东西它都可以清理。所以请合理地使用它，当你对某个选项有疑问时，就跳过它。</p><ul><li><a href="https://apps.ubuntu.com/cat/applications/bleachbit/" target="_blank" rel="noopener">从 Ubuntu 软件中心里安装 BleachBit</a></li></ul><p>你已经有了自己最喜欢的系统实用工具了吗？可以在下面的评论中让其他人知晓它。</p><hr><p>via: <a href="http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-them" target="_blank" rel="noopener">http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-them</a><br>publish: <a href="https://linux.cn/article-5025-1.html" target="_blank" rel="noopener">https://linux.cn/article-5025-1.html</a></p><p>作者：<a href="https://plus.google.com/117485690627814051450/?rel=author" target="_blank">Joey-Elijah Sneddon</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你&lt;strong&gt;调整 Ubuntu ，随时满足你的需求&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ubuntu" scheme="https://fsslc.github.io/tags/Ubuntu/"/>
    
      <category term="桌面" scheme="https://fsslc.github.io/tags/%E6%A1%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] dupeGuru - 直接从硬盘中查找并移除重复文件</title>
    <link href="https://fsslc.github.io/2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/"/>
    <id>https://fsslc.github.io/2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/</id>
    <published>2015-03-05T03:38:00.000Z</published>
    <updated>2020-03-01T16:43:44.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 dupeGuru 来查找并删除重复文件</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 <strong>dupeGuru</strong> 可能会帮助到你。</p><p>dupeGuru 团队也开发了名为 <strong>dupeGuru 音乐版</strong> 的应用来移除重复的音乐文件，和名为 <strong>dupeGuru 图片版</strong> 的应用来移除重复的图片文件。</p><a id="more"></a><h3 id="1-dupeGuru-标准版"><a href="#1-dupeGuru-标准版" class="headerlink" title="1. dupeGuru (标准版)"></a>1. dupeGuru (标准版)</h3><p>需要告诉那些不熟悉 <a href="http://www.hardcoded.net/dupeguru/" target="_blank" rel="noopener">dupeGuru</a> 的人，它是一个免费、开源、跨平台的应用，其用途是在系统中查找和移除重复文件。它可以在 Linux, Windows, 和 Mac OS X 等平台下使用。通过使用一个快速的模糊匹配算法，它可以在几分钟内找到重复文件。同时，你还可以调整 dupeGuru 使它去精确查找特定文件类型的重复文件，以及从你想删除的文件中，清除某种文件。它支持英语、 法语、 德语、 中文 （简体）、 捷克语、 意大利语、亚美尼亚语、俄语、乌克兰语、巴西语和越南语。</p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru</h4><p>dupeGuru 开发者已经构建了一个 Ubuntu PPA (Personal Package Archives)来简化安装过程。想要安装 dupeGuru，依次在终端中键入以下命令：</p><pre><code class="lang-bash">sudo apt-add-repository ppa:hsoft/ppasudo apt-get updatesudo apt-get install dupeguru-se</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用非常简单，可从 Unity 面板或菜单中启动 dupeGuru。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru_007.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>点击位于底部的 <code>+</code> 按钮来添加你想扫描的文件目录。点击 <code>扫描</code> 按钮开始查找重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru_008.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一旦所选目录中含有重复文件，那么它将在窗口中展示重复文件。正如你所看到的，在下面的截图中，我的下载目录中有一个重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Results_009.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在，你可以决定下一步如何操作。你可以删除这个重复的文件，或者对它进行重命名，抑或是 复制/移动 到另一个位置。为此，选定该重复文件，或在菜单栏中选定写有“<strong>仅显示重复</strong>”选项 ，如果你选择了“<strong>仅显示重复</strong>”选项，则只有重复文件在窗口中可见，这样你便可以轻松选择并删除这些文件。点击“操作”下拉菜单，最后选择你将执行的操作。在这里，我只想删除重复文件，所以我选择了“移动标记文件到垃圾箱”这个选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/Menu_010.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接着，点击“继续”选项来移除重复文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/Deletion-Options_011.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-dupeGuru-音乐版"><a href="#2-dupeGuru-音乐版" class="headerlink" title="2. dupeGuru 音乐版"></a>2. dupeGuru 音乐版</h3><p><a href="http://www.hardcoded.net/dupeguru_me/" target="_blank" rel="noopener">dupeGuru 音乐版</a> 或简称 dupeGuru ME，它的功能与 dupeGuru 类似。它拥有 dupeGuru 的所有功能，但它包含更多的信息列 （如比特率，持续时间，标签等）和更多的扫描类型（如带有字段的文件名，标签以及音频内容）。和 dupeGuru 一样，dupeGuru ME 也运行在 Linux、Windows 和 Mac OS X 中。</p><p>它支持众多的格式，诸如 MP3、WMA、AAC (iTunes 格式)、OGG、FLAC，以及失真率较少的 AAC 和 WMA 格式等。</p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-ME"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-ME" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME</h4><p>现在，我们不必再添加任何 PPA，因为在前面的步骤中，我们已经进行了添加。所以在终端中键入以下命令来安装它：</p><pre><code class="lang-bash">sudo apt-get install dupeguru-me</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>你可以从 Unity 面板或菜单中启动它。dupeGuru ME 的使用方法、操作界面以及外观和正常的 dupeGuru 类似。添加你想扫描的目录并选择你想执行的操作。重复的音乐文件就会被删除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Music-Edition-Results_012.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="3-dupeGuru-图片版"><a href="#3-dupeGuru-图片版" class="headerlink" title="3. dupeGuru 图片版"></a>3. dupeGuru 图片版</h3><p><a href="http://www.hardcoded.net/dupeguru_pe/" target="_blank" rel="noopener">dupeGuru 图片版</a>,或简称为 duepGuru PE，是一个在你的电脑中查找重复图片的工具。它和 dupeGuru 类似，但独具匹配重复图片的功能。dupeGuru PE 可运行在 Linux、Windows 和 Mac OS X 中。</p><p>dupeGuru PE 支持 JPG、PNG、TIFF、GIF 和 BMP 等图片格式。所有的这些格式可以被同时比较。Mac OS X 版的 dupeGuru PE 还支持 PSD 和 RAW (CR2 和 NEF) 格式。  </p><h4 id="在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-PE"><a href="#在-Ubuntu-14-10-14-04-13-10-13-04-12-04-中安装-dupeGuru-PE" class="headerlink" title="在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE"></a>在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE</h4><p>由于我们已经添加了 PPA，我们也不必为 dupeGuru PE 再次添加。只需运行如下命令来安装它。</p><pre><code class="lang-bash">sudo apt-get install dupeguru-pe</code></pre><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>就使用方法，操作界面和外观而言，它与 dupeGuru，dupeGuru ME 类似。我就纳闷为什么开发者为不同的类别开发了不同的版本。我想如果开发一个结合以上三个版本功能的应用，或许会更好。</p><p>启动它，添加你想扫描的目录，并选择你想执行的操作。就这样，你的重复文件将被清除。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru-Picture-Edition-Results_014.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果因为任何的安全问题而不能移除某些重复文件，请记下这些文件的位置，通过终端或文件管理器来手动删除它们。</p><p>欢呼吧！</p><hr><p>via: <a href="http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/" target="_blank" rel="noopener">http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/</a><br>publish: <a href="https://linux.cn/article-4992-1.html" target="_blank" rel="noopener">https://linux.cn/article-4992-1.html</a></p><p>作者：<a href="http://www.unixmen.com/author/sk/" target="_blank" rel="noopener">SK</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/carolinewuyan" target="_blank" rel="noopener">Caroline</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 dupeGuru 来查找并删除重复文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://s24255.pcdn.co/wp-content/uploads/2014/11/dupeGuru.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 &lt;strong&gt;dupeGuru&lt;/strong&gt; 可能会帮助到你。&lt;/p&gt;
&lt;p&gt;dupeGuru 团队也开发了名为 &lt;strong&gt;dupeGuru 音乐版&lt;/strong&gt; 的应用来移除重复的音乐文件，和名为 &lt;strong&gt;dupeGuru 图片版&lt;/strong&gt; 的应用来移除重复的图片文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="重复文件" scheme="https://fsslc.github.io/tags/%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/"/>
    
      <category term="dupeGuru" scheme="https://fsslc.github.io/tags/dupeGuru/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号</title>
    <link href="https://fsslc.github.io/2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/"/>
    <id>https://fsslc.github.io/2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/</id>
    <published>2015-02-28T12:53:00.000Z</published>
    <updated>2020-03-01T16:28:21.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过 GitHub 将它们嵌入到网页和其他项目中</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205325gyj2l10yn2zxgm4y.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。</p><p>现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近<a href="https://blog.twitter.com/2014/open-sourcing-twitter-emoji-for-everyone" target="_blank" rel="noopener">开源了</a>他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。</p><a id="more"></a><p>但这需要一点体力活。 Unicode 已经识别甚至标准化了 emoji 字母表， 然而 emoji 仍然<a href="http://www.unicode.org/reports/tr51/full-emoji-list.html" target="_blank" rel="noopener">不能完全与所有的网络浏览器相兼容</a>，这意味着大多数情况下，它们将呈现为 “豆腐块”或“空白盒子”。当 Twitter 想使得 emoji 到处可用时，这家社交网络联合了一家名为<a href="https://twitter.com/iconfactory" target="_blank" rel="noopener">Icon Factory</a>的公司来渲染浏览器以模仿文本信息符号的效果。Twiter 认为人们对他们的 emoji 库有很大的需求。</p><p>现在， 你可以从 <a href="https://github.com/twitter/twemoji" target="_blank" rel="noopener">GitHub</a> 上克隆 Twitter 的整个库，从而在你的开发项目中使用它们。 下面将为你介绍如何达到上面的目的以及如何使得 emoji 更容易被使用。</p><h3 id="为-Emoji-得到-Unicode-支持"><a href="#为-Emoji-得到-Unicode-支持" class="headerlink" title="为 Emoji 得到 Unicode 支持"></a>为 Emoji 得到 Unicode 支持</h3><p>Unicode 是国际编码标准，它为任意的符号、字母或人们想在网络上使用的数字配置了一串编码。换句话说，它是你如何在计算机上阅读文本与计算机如何读取文本之间的缺失环节。例如，对于你正看到的位于这些句子中的<code>空格</code>（LCTT 译注：英文分词中间的空格），计算机读取为 “&amp;nbsp”。</p><p>Unicode 甚至拥有其自己的<a href="http://www.unicode.org/reports/tr51/full-emoji-list.html" target="_blank" rel="noopener">原始 emoji</a>，它们可以在没有你的任何努力的情况下在浏览器中被阅读。例如，当你看到了 一个 ❤ 符号，你的计算机正在解码字符串 “2665” 。</p><p>要在大多数情况下使用 Twitter 的 emoji 库，你只需在你的 HTML 网页中的 <code>&lt;head&gt;</code>块中添加如下脚本：</p><pre><code class="lang-html">&lt;script src=&quot;//twemoji.maxcdn.com/twemoji.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>这样就使得你的项目可以访问包含有已经在 Twitter 中可使用的数以百计的 Emoji 符号的 JavaScript 库。然而，创建一个仅仅包含这个脚本的文档并不能使得在你的网站中呈现出 emoji 符号，实际上，你仍需要嵌入这些 emoji 符号！</p><p>在 <code>&lt;body&gt;</code>块中，粘贴一些可以在 Twitter 的<a href="https://github.com/twitter/twemoji/blob/gh-pages/preview.html" target="_blank" rel="noopener">preview.html 文件源代码</a> 中找到的 emoji 字符串。我使用了 &#x1F3B9; 和 &amp;#x1F3C1，当然我并不知道在浏览器窗口中它们的样子。是的，你必须粘贴并猜测它们。你已经看出了问题，我们将在第二小节中予以解决。</p><p>无论如何，通过一些尝试，你可以将一个如下图的原始 HTML 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205332ff1vf82k13o18t92.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>显示为如下图的网页：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205334iei6li3wvl3vl6tr.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="将-Emoji-转换为可阅读的语言"><a href="#将-Emoji-转换为可阅读的语言" class="headerlink" title="将 Emoji 转换为可阅读的语言"></a>将 Emoji 转换为可阅读的语言</h3><p>对于一个网站或应用，Twitter 的解决方案是非常适用的。但如果你想通过 HTML 轻易地插入你喜爱的 emoji 符号，你需要一个更易实现的解决方案，而不是记住所有代表 emoji 的 Unicode 字符串。</p><p>那正是程序员 Elle Kasai 的 <a href="http://ellekasai.github.io/twemoji-awesome/" target="_blank" rel="noopener">Twemoji Awesome</a> 样式大展身手的地方。</p><p>通过向任意网页中添加 Elle 的开源样式表，你可以适用 英语单词来理解你正插入的 emoji 符号的意义。所以如若你想展示一个 心形 emoji 符号，你可以简单地输入：</p><pre><code class="lang-html">&lt;i class=&quot;twa twa-heart&quot;&gt;&lt;/i&gt;</code></pre><p>为了实现上面的目的，让我们下载 Elle 的项目，通过点击在 GitHub 上 “Download ZIP” 按钮。</p><p>接着，我们在桌面上新建一个文件夹，然后进入该文件夹，并将 emoji.html—-我先前向你展示的 HTML 源文件—- 和 Elle 的 <a href="https://github.com/ellekasai/twemoji-awesome/blob/gh-pages/twemoji-awesome.css" target="_blank" rel="noopener">twemoji-awesome.css</a> 一同放进去。</p><p>我们还需要 HTML 文件识别这个 CSS 文件，所以在 html 网页中的 <code>&lt;head&gt;</code> 块中，为 CSS 文件添加一个链接：</p><pre><code class="lang-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;twemoji-awesome.css&quot;&gt;</code></pre><p>一旦你将上面的代码添加了进去，你便可以删除先前添加的 Twitter 的脚本链接。</p><p>现在，找到 <code>body</code> 块部分的代码，然后添加一些 emoji 符号。我使用了 <code>&lt;i class=&quot;twa twa-sparkling-heart&quot;&gt;&lt;/i&gt;</code>, <code>&lt;i class=&quot;twa twa-exclamation&quot;&gt;&lt;/i&gt;</code>, <code>&lt;i class=&quot;twa twa-lg twa-sparkles&quot;&gt;&lt;/i&gt;</code> 和 <code>&lt;i class=&quot;twa twa-beer&quot;&gt;&lt;/i&gt;</code>。</p><p>最终，你将得到如下的代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205336rpl22xbdxl2ixljx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>保存并在浏览器中查看上面的文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201503/01/205337gn1jaazgj47jnfcf.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Duang！这样你不仅得到了一个可以在浏览器中支持 emoji 符号的基本网页，而且还知道了如何简单地实现它。你可以随意的在<a href="https://github.com/laurenorsini/Emoji-Everywhere" target="_blank" rel="noopener">我的 GitHub</a> 中查看这个教程，并且可以克隆这些实际的文件而不只是看看这些截图。</p><p>题图来自于<a href="http://getemoji.com/" target="_blank" rel="noopener">得到 Emoji</a>； Lauren Orsini 截图。</p><hr><p>via: <a href="http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-window" target="_blank" rel="noopener">http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-window</a><br>publish: <a href="https://linux.cn/article-4961-1.html" target="_blank" rel="noopener">https://linux.cn/article-4961-1.html</a></p><p>作者：<a href="http://readwrite.com/author/lauren-orsini" target="_blank" rel="noopener">Lauren Orsini</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过 GitHub 将它们嵌入到网页和其他项目中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201503/01/205325gyj2l10yn2zxgm4y.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。&lt;/p&gt;
&lt;p&gt;现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近&lt;a href=&quot;https://blog.twitter.com/2014/open-sourcing-twitter-emoji-for-everyone&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开源了&lt;/a&gt;他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Emoji" scheme="https://fsslc.github.io/tags/Emoji/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 怎样在 Linux 系统中恢复已删除文件</title>
    <link href="https://fsslc.github.io/2015/02/25/Translate-Undelete-Files-on-Linux-Systems/"/>
    <id>https://fsslc.github.io/2015/02/25/Translate-Undelete-Files-on-Linux-Systems/</id>
    <published>2015-02-25T04:51:50.000Z</published>
    <updated>2020-03-02T06:03:41.711Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105434g7z0wrwdh76fdw3d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。</p><a id="more"></a><p>这里将解释它是如何工作的。在一个文件系统中，有一个叫做 <code>文件分配表</code> 的东西，这个表跟踪文件在存储单元（如硬盘， MicroSD 卡，闪存驱动器等等）中的位置。当一个文件被删除，文件系统将会在<code>文件分配表</code>中执行以下两个任务之一：这个文件在<code>文件分配表</code>上的条目被标记为 “自由空间” 或删除<code>文件分配表</code>里这个文件的条目，且将相应的空间被标记为自由空间 。现在，如果有一个新的文件需要被放置在一个存储单元上，操作系统将会把这个文件放置到标记为空位的地方。在新文件被写入到这个空位后，被删除的文件就彻底消失了。当需要恢复一个已经删除的文件时，用户绝对不能再对任何文件进行操作，因为假如该文件对应的“空位”被占用，这个文件就永远也不能恢复了。</p><h3 id="恢复软件是如何工作的？"><a href="#恢复软件是如何工作的？" class="headerlink" title="恢复软件是如何工作的？"></a>恢复软件是如何工作的？</h3><p>大多数的文件系统（在删除文件时）只是标记空间为空白。在这些文件系统下，恢复软件查看<code>文件分配表</code>这个文件，然后复制被删除的文件到另外的存储单元中。假如该文件被复制到其它需要恢复的被删除的存储单元中，那么用户将有可能会失去那个所需的删除文件。</p><p>文件系统很少会擦除<code>文件分配表</code>中的条目。假如文件系统真的这样做了， 这便是恢复软件在恢复文件了。恢复软件在存储单元中扫描文件头，所有文件都拥有一个特殊的编码字符串，它们位于文件的最前面，也被叫做 <code>魔法数字</code>。例如，一个编译的 JAVA 类文件的魔法数字在十六进制中是“CAFEBABE”。所以，假如要恢复该类型的文件，恢复软件会查找 “CAFEBABE” 然后复制文件到另一个存储单元。一些恢复软件可以查找某种特殊的文件类型。若用户想恢复一个 PDF 文件，则恢复软件将会查找十六进制的魔法数字 “25504446”，这恰恰是 ASCII 编码中的 “%PDF”。恢复软件将会查找所有的魔法数字，然后用户可以选择恢复哪个已删除的文件。</p><p>假如一个文件的部分被覆写了，则整个文件就会被损坏。通常这个文件可以被恢复，但是其中的内容可能已经没有什么用处。例如，恢复一个已损坏的 JPEG 文件将会是无意义的，因为图片查看器不能从这个损坏的文件产生一幅图片。因此，即使用户拥有了这个文件，该文件也将毫无用处。</p><h3 id="设备的位置："><a href="#设备的位置：" class="headerlink" title="设备的位置："></a>设备的位置：</h3><p>在我们继续之前，下面的一些信息将会对指引恢复软件找到正确的存储单元起到一定的帮助。所有的设备均挂载在 <code>/dev/</code> 目录下。操作系统赋予每个设备的名称（并不是管理员给予每个分区或设备的名称）遵循一定的命名规律。</p><p>第一个 SATA 硬盘的第二个分区的名称将会是 sda2。名称的第一个字母暗示了存储类型，在这里指的是 SATA，但字母 “s” 也可能指的是 SCSI、 FireWire（火线端口）或 USB。第二个字母 “d” 指的是 disk(硬盘)。第三个字母指的是设备序数，即字母 “a” 指的是第一个 SATA 而 “b” 指的是第二个。最后的数字代表分区。没有分区数字的设备名代表该设置的所有分区。对于上面的例子，对应的名称为 sda 。作为命名的第一个字母还可能是 “h” ，这对应 PATA 硬盘（IDE）。</p><p>以下为命名规律的一些例子。假如一个用户有一个 SATA 硬盘（sda），这个设备有 4 个分区- sda1、 sda2、 sda3 和 sda4 。该用户删除了第三个分区，但直到格式化第四个分区之前，第四个分区名 sda4 都将保留不变。然后该用户插入了一个带有一个分区 - 即sdb1- 的 usb 存储卡（sdb），又增加了一个带有一个分区 -hda1- 的 IDE 硬盘 ，接着该用户又增加了一个 SCSI 硬盘 - sdc1 。接着用户移除了 USB 存储卡（sdb）。现在，SCSI 硬盘的名称仍然为 sdc，但如果这个 SCSI 被移除接着再被插入，则它的名称将变为 sdb。虽然还有其他的存储设备存在， 那个 IDE 硬盘的名称仍会有一个 “a”， 因为它是第一个 IDE 硬盘，IDE 设备的命名与 SCSI、 SATA、 FireWire 和 USB 设备要分开计数。</p><h3 id="使用-TestDisk-进行恢复："><a href="#使用-TestDisk-进行恢复：" class="headerlink" title="使用 TestDisk 进行恢复："></a>使用 TestDisk 进行恢复：</h3><p>每个恢复软件有其不同的功能，特征及支持的不同文件系统。下面是一些关于 使用 TestDisk  在各种文件系统中恢复文件的指南。</p><h4 id="FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-3-4："><a href="#FAT16、-FAT32、-exFAT-FAT64-、-NTFS-以及-ext2-3-4：" class="headerlink" title="FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4："></a>FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4：</h4><p>TestDisk 是一个运行在 Linux、 *BSD、 SunOS、 Mac OS X、 DOS 和 Windows 等操作系统下的开源的自由软件。 TestDisk 可以从下面的链接中找到 ：<a href="http://www.cgsecurity.org/wiki/TestDisk" target="_blank" rel="noopener">http://www.cgsecurity.org/wiki/TestDisk</a>。TestDisk 也可以通过键入 <code>sudo apt-get install testdisk</code> 来安装。TestDisk 有着许多的功能，但这篇文章将只关注恢复文件这个功能。</p><p>使用 root 权限从终端中打开 TestDisk 可以通过键入 <code>sudo testdisk</code> 命令。</p><p>现在， TestDisk 命令行应用将会被执行。终端的显示将会改变。TestDisk 询问用户它是否可以保留日志，这完全由用户决定。假如一个用户正从系统存储中恢复文件，则不必保留日志。可选择的选项有“生成”、 “追加” 和 “无日志”。假如用户想保留日志，则日志将会保留在该用户的主目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105436uwecycts99wwsy9c.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在接着的屏幕中，存储设备以 <code>/dev/*</code>的方式被罗列出来。对于我的系统，系统的存储单元为 <code>/dev/sda</code>，这意味着我的存储单元为 一个 SATA硬盘（sd）且它是第一个硬盘（a）。每个存储单元的容量以 Gigabyte（千兆字节）为单位显示的。使用上下键来选择一个存储设备然后点击进入。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105439itbspn7drs6san5r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下一屏显示出一个列有分区表（也叫做分区映射表）的清单。正如文件有<code>文件配置表</code>，分区有着分区表。分区是存储设备上的分段。例如在几乎所有的 Linux 系统中，至少存在两种分区类型 - EXT3/4 和 Swap 。每一个分区表将会在下面被简要地描述。TestDisk 并不支持所有类型的分区表，所以这并不是完整的列表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105441pakd3jd7fihfdaxj.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>Intel</strong> - 这类分区表在 Windows 系统和许多的 Linux 系统中非常普遍，它也常常称作 MBR 分区表。</li><li><strong>EFI GPT</strong> - 这种类型的分区表通常用在 Linux 系统中。对于 Linux 系统，这种分区表是最为推荐的， 因为逻辑分区或扩展分区的概念并不适用于 GPT (GUID Partition Table) 分区表。 这意味着，如果每个分区中有一个 Linux 系统，一个 Linux 用户可以从多种类型的 Linux 系统中进行多重启动。当然使用 GPT 分区表还有其他的优势，但那些已超出了本文的讨论范围。</li><li><strong>Humax</strong> - Humax 分区映射表适用于韩国公司 Humax 生产的设备。</li><li><strong>Mac</strong> -  Apple 分区映射表 (APM) 适用于 Apple 的设备。</li><li><strong>None</strong> - 某些设备并没有分区表。例如，许多 Subor 游戏控制台不使用分区映射表。如果一个用户试图以其它分区表类型从这类设备中恢复文件，用户就会困扰 TestDisk 为何找卟到任何的文件系统或者文件。</li><li><strong>Sun</strong> - Sun 分区表适用于 Sun 系统。</li><li><strong>Xbox</strong> -Xbox 适用于使用 Xbox 分区映射表的存储设备。</li></ul><p>假如用户选择了 “Xbox” ，尽管他的系统使用了 GPT 分区表， 那么 TestDisk 将不能找到任何分区或文件系统。假如 TestDisk 按照用户的选择执行，则它可能猜测错误。（下面的图片显示的是当分区表类型错误时的输出）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105443izh5h604yhqe6e5d.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当用户为他们的设备选择了正确的选项，则在下一屏中，选择 “高级” 选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105445a6ld97gdq99sz5g7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在，用户将看到一个列有用户存储设备中所有的文件系统或分区的列表。假如用户选择了错误的分区映射表，则在这一步中用户就将会知道他们做出了错误的选择。假如没有错误，通过移动文字光标来高亮选择含有被删除文件的分区。使用 左右键来高亮位于终端底部的 “列表”。接着，按下回车确认。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105447ovkm1kvmzp2mx5cg.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>新的一屏便会呈现出列有文件和目录的列表。那些白色的文件名就是未被删除的文件，而红色的文件名是那些已被删除的文件。最右边的一列是文件的名称，从右到左方向的接着一列是文件的创建日期，再往左的一列是文件的大小（以 byte/ 比特为单位），最左边带有“-”，“d” ,“r”, “w” 和”x”的一列则代表的是文件的权限情况。“d” 表示该文件为一个目录，其他的权限术语与本文关系不大。在列表的最顶端以“.”代表的一项表示当前目录，第二行以”..”代表的一项表示当前目录的上级目录，所以用户可以通过选择目录所在行到达该目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105454tz8xhlx1hh10plhx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>举个例子，我想进入”Xaiml_Dataset” 目录，该目录基本上由被删除的文件组成。通过按键盘上的 “c”键，我将恢复文件 “computers.xaiml”，接着我被询问选择一个目标目录，当然，我应该放置该文件到另一个分区中。现在，当我在我的家目录时，按下了“c”键。（选择目标目录时）哪个目录被高亮并没有什么影响，当前目录就是目标目录，在屏幕的上方，将会显示“复制完成”的消息。在我的家目录中便会有一个名为”Xaiml_Dataset”的目录，里面里有一个 Xaiml 文件。 假如我在更多的已删除文件上按“c” 键，则这些文件将会被放置到新的文件夹中而无需再向我询问目标目录。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105458r4d1dt34tq6h264j.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/25/105502w2eaueg8bgoa828t.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>当这些步骤完成后，重复按“q”键直到看到正常的终端模样。目录”Xaiml_Dataset” 只能被 root 用户访问。为了解决这个问题，使用 root 权限改变该目录及其子目录的权限。做完这些后，文件便被恢复了且用户可以访问它们。</p><h3 id="特别的-ReiserFS："><a href="#特别的-ReiserFS：" class="headerlink" title="特别的 ReiserFS："></a>特别的 ReiserFS：</h3><p>为了从 ReiserFS 文件系统中恢复一个文件，首先需将分区中的所有文件做一个备份。因为如果发生某些错误， 这个方法可能会引起文件丢失。接着执行下面的命令，其中 <code>DEVICE</code>指的是那些以 sda2 形式命名的设备。一些文件将被放入 lost+found 目录而其他则会保存到原先被删除的位置。 </p><pre><code class="lang-bash">reiserfsck --rebuild-tree --scan-whole-partition /dev/DEVICE</code></pre><h3 id="恢复被某个程序打开的删除文件："><a href="#恢复被某个程序打开的删除文件：" class="headerlink" title="恢复被某个程序打开的删除文件："></a>恢复被某个程序打开的删除文件：</h3><p>假设用户意外地删除了一个文件，且该文件被某个程序打开。虽然在硬盘中该文件被删除了，但这个程序正使用着位于 RAM 中的该文件的副本。幸好，我们有两种简单的解决方法来恢复该文件。</p><p>假如这个软件有保存功能，如文本编辑器，则用户可以重新保存该文件，这样，文本编辑器可以将该文件写入硬盘中。</p><p>假设在音乐播放器中有一个 MP3 文件，而该音乐播放器并不能保存该 MP3 文件，则这种情形下需要比先前花更多的时间来恢复文件。不幸的是，这种方法并不能保证在所有的系统和应用中有效。首先，键入下面的命令。</p><pre><code class="lang-bash">lsof -c smplayer | grep mp3</code></pre><p>上面的命令会列出所有由 smplayer 使用的文件，这个列表由 <code>grep</code> 命令通过管道搜索 mp3 。命令的输入类似于下面：</p><pre><code class="lang-bash">smplayer  10037 collier  mp3    169r      8,1  676376  1704294 /usr/bin/smplayer</code></pre><p>现在，键入下面的命令来直接从 RAM（在 Linux 系统中，<code>/proc/</code>映射到 RAM）中恢复文件，并复制该文件到选定的文件夹中。其中 <code>cp</code> 指的是复制命令，输出中的数字 10037 来自于进程数，输出中的数字 169 指的是文件描述符，”~/Music/“为目标目录，最后的 “music.mp3” 为用户想恢复的文件的名称。</p><pre><code class="lang-bash">cp /proc/10037/fd/169 ~/Music/music.mp3</code></pre><h3 id="真正的删除："><a href="#真正的删除：" class="headerlink" title="真正的删除："></a>真正的删除：</h3><p>为确保一个文件不能被恢复，可以使用一个命令来 “擦除” 硬盘。擦除硬盘实际上是向硬盘中写入无意义的数据。例如，许多擦除程序向硬盘中写入零，随机字母或随机数据。不会有空间被占用或丢失，擦除程序只是对空位进行重写覆盖。假如存储单元被文件占满而没有空余空间，则所有先前被删除的文件将会消失而不能恢复。</p><p>擦除硬盘的目的是确保隐私数据不被他人看见。举个例子，一个公司可能预订了一些新的电脑，总经理决定将旧的电脑卖掉，然而，新的电脑拥有者可能会看到公司的一些机密或诸如信用卡号码，地址等顾客信息。幸好，公司的电脑技术人员可以在卖掉这些旧电脑之前，擦除这些硬盘。</p><p>为了安装擦除程序 secure-delete，键入 <code>sudo apt-get install secure-delete</code>,这个命令将会安装一个包含 4 个程序的程序集，用以确保被删除的文件不能被恢复。</p><ul><li>srm - 永久删除一个文件。使用方法： <code>srm -f ./secret_file.txt</code></li><li>sfill - 擦除空白空间。使用方法: <code>sfill -f /mount/point/of/partition</code></li><li>sswap - 擦除 swap 空间。使用方法: <code>sswap -f /dev/SWAP_DEVICE</code></li></ul><p>假如电脑实际去清除那些删除的文件，那么就需要花费更长的时间去执行删除任务。将某些空间标记为空位是快速且容易的，但使得文件永远消失需要花费一定的时间。例如，擦除一个存储单元，可能需要花费几个小时的时间（根据磁盘容量大小）。总之，现在的系统工作的就挺好，因为即便用户清空了垃圾箱，他们仍然有另一次机会来改变他们当初的想法（或错误）。</p><hr><p>via: <a href="http://www.linux.org/threads/undelete-files-on-linux-systems.4316/" target="_blank" rel="noopener">http://www.linux.org/threads/undelete-files-on-linux-systems.4316/</a><br>public: <a href="https://linux.cn/article-4938-1.html" target="_blank" rel="noopener">https://linux.cn/article-4938-1.html</a></p><p>作者：<a href="http://www.linux.org/members/devyncjohnson.4843/" target="_blank" rel="noopener">DevynCJohnson</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201502/25/105434g7z0wrwdh76fdw3d.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="TestDisk" scheme="https://fsslc.github.io/tags/TestDisk/"/>
    
      <category term="文件恢复" scheme="https://fsslc.github.io/tags/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] 使用 APT-mirror 四步配置 Ubuntu 本地软件仓库</title>
    <link href="https://fsslc.github.io/2015/02/23/Translate-4-Steps-to-Setup-Local-Repository-in-Ubuntu-using-APT-mirror/"/>
    <id>https://fsslc.github.io/2015/02/23/Translate-4-Steps-to-Setup-Local-Repository-in-Ubuntu-using-APT-mirror/</id>
    <published>2015-02-23T03:17:07.000Z</published>
    <updated>2020-03-02T06:17:56.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍使用 APT-Mirror 来制作本地源</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222342ybiibj1mj1jdrbam.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>今天，我们将向你展示如何在你的 Ubuntu 个人电脑或 Ubuntu 服务器中，直接通过 Ubuntu 官方软件仓库来配置本地软件仓库。在你的电脑中创建一个本地软件仓库有着许多的好处。假如你有许多电脑需要安装软件 、安全升级和修复补丁，那么配置一个本地软件仓库是一个做这些事情的高效方法。因为，所有需要安装的软件包都可以通过快速的局域网连接从你的本地服务器中下载，这样可以节省你的网络带宽，降低互联网接入的年度开支 …</p><p>你可以使用多种工具在你的本地个人电脑或服务器中配置一个 Ubuntu 的本地软件仓库，但在本教程中，我们将为你介绍 APT-Mirror。这里，我们将把默认的镜像包镜像到我们本地的服务器或个人电脑中，并且在你的本地或外置硬盘中，我们至少需要 <strong>120 GB</strong> 或更多的可用空间才行。 我们可以通过配置一个 <strong>HTTP</strong> 或 <strong>FTP</strong> 服务器来与本地系统客户端共享这个软件仓库。</p><p>我们需要安装 Apache 网络服务器和 APT-Mirror 来使得我们的工作得以开始。下面是配置一个可工作的本地软件仓库的步骤：</p><h3 id="1-安装需要的软件包"><a href="#1-安装需要的软件包" class="headerlink" title="1. 安装需要的软件包"></a>1. 安装需要的软件包</h3><p>我们需要从 Ubuntu 的公共软件包仓库中取得所有的软件包，然后在我们本地的 Ubuntu 服务器硬盘中保存它们。</p><p>首先我们安装一个Web 服务器来承载我们的本地软件仓库。这里我们将安装 Apache Web 服务器，但你可以安装任何你中意的 Web 服务器。对于 http 协议，Web 服务器是必须的。假如你需要配置 ftp 协议 及 rsync 协议，你还可以再分别额外安装 FTP 服务器，如  proftpd, vsftpd 等等 和 Rsync 。</p><pre><code class="lang-bash">$ sudo apt-get install apache2</code></pre><p>然后我们需要安装 apt-mirror:</p><pre><code class="lang-bash">$ sudo apt-get install apt-mirror</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222345kfzfsdrdyrq0dbbr.png" alt="apt-mirror-installation" title="">                </div>                <div class="image-caption">apt-mirror-installation</div>            </figure><p><strong>注: 正如我先前提到的，我们需要至少 120 GB 的可用空间来使得所有的软件包被镜像或下载。</strong></p><h3 id="2-配置-APT-Mirror"><a href="#2-配置-APT-Mirror" class="headerlink" title="2. 配置 APT-Mirror"></a>2. 配置 APT-Mirror</h3><p>现在，在你的硬盘上创建一个目录来保存所有的软件包。例如，我们创建一个名为 <code>/linoxide</code>的目录，我们将在这个目录中保存所有的软件包：</p><pre><code class="lang-bash">$ sudo mkdir /linoxide</code></pre><p>现在，打开文件 <strong>/etc/apt/mirror.list</strong> :</p><pre><code class="lang-bash">$ sudo nano /etc/apt/mirror.list</code></pre><p>复制下面的命令行配置到 <code>mirror.list</code>文件中并按照你的需求进行修改：</p><pre><code class="lang-bash">############# config ###################set base_path    /linoxide## set mirror_path  $base_path/mirror# set skel_path    $base_path/skel# set var_path     $base_path/var# set cleanscript $var_path/clean.sh# set defaultarch  &lt;running host architecture&gt;# set postmirror_script $var_path/postmirror.sh# set run_postmirror 0set nthreads     20set _tilde 0############## end config ##############deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse#deb http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse#deb http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiversedeb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse#deb-src http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse#deb-src http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverseclean http://archive.ubuntu.com/ubuntu</code></pre><p><strong>注: 你可以将上面的官方镜像服务器网址更改为离你最近的服务器的网址，可以通过访问 <a href="https://launchpad.net/ubuntu/+archivemirrors" target="_blank" rel="noopener">Ubuntu Mirror Server</a>来找到这些服务器地址。假如你并不太在意镜像完成的时间，你可以沿用默认的官方镜像服务器网址。</strong></p><p>这里，我们将要镜像最新和最大的 Ubuntu LTS 发行版 —- 即 Ubuntu 14.04 LTS (Trusty Tahr) —- 的软件包仓库，所以在上面的配置中发行版本号为 trusty 。假如我们需要镜像 Saucy 或其他的 Ubuntu 发行版本，请修改上面的 trusy 为相应的代号。</p><p>现在，我们必须运行 apt-mirror 来下载或镜像官方仓库中的所有软件包。</p><pre><code class="lang-bash">sudo apt-mirror</code></pre><p>从 Ubuntu 服务器中下载所有的软件包所花费的时间取决于你和镜像服务器之间的网络连接速率和性能。这里我中断了下载，因为我已经下载好了 …</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.linux.net.cn/data/attachment/album/201502/22/222346n1bcve3ytotgjct5.png" alt="downloading-packages" title="">                </div>                <div class="image-caption">downloading-packages</div>            </figure><h3 id="3-配置网络服务器"><a href="#3-配置网络服务器" class="headerlink" title="3.配置网络服务器"></a>3.配置网络服务器</h3><p>为了使得其他的电脑能够访问这个软件仓库，你需要一个Web服务器。你也可以通过 ftp 来完成这件事，但我选择使用一个Web服务器因为在上面的步骤 1 中我提及到使用Web服务器。因此，我们现在要对 Apache 服务器进行配置:</p><p>我们将为我们本地的软件仓库目录 建立一个到 Apache 托管目录 —- 即 <code>/var/www/ubuntu</code> —- 的符号链接。</p><pre><code class="lang-bash">$ sudo ln -s /linoxide /var/www/ubuntu$ sudo service apache2 start</code></pre><p>上面的命令将允许我们从本地主机(localhost) —- 即 <a href="http://127.0.0.1(默认情况下" target="_blank" rel="noopener">http://127.0.0.1(默认情况下</a>) —-  浏览我们的镜像软件仓库。</p><h3 id="4-配置客户端"><a href="#4-配置客户端" class="headerlink" title="4. 配置客户端"></a>4. 配置客户端</h3><p>最后，我们需要在其他的电脑中添加软件源，来使得它们可以从我们的电脑中取得软件包或软件仓库。为达到此目的，我们需要编辑 <code>/etc/apt/sources.list</code> 文件并添加下面的命令：</p><pre><code class="lang-bash">$ sudo nano /etc/apt/sources.list</code></pre><p>添加下面的一行到<code>/etc/apt/sources.list</code>中并保存。</p><pre><code class="lang-bash">deb http://192.168.0.100/ubuntu/ trusty main restricted universe</code></pre><p><strong>注: 这里的 192.168.0.100 是我们的服务器电脑的局域网 IP 地址，你需要替换为你的服务器电脑的局域网 IP 地址</strong></p><pre><code class="lang-bash">$ sudo apt-get update</code></pre><p>最终，我们完成了任务。现在，你可以使用<code>sudo apt-get install packagename</code> 命令来从你的本地 Ubuntu 软件仓库中安装所需的软件包，这将会是高速的且消耗很少的带宽。</p><hr><p>via: <a href="http://linoxide.com/ubuntu-how-to/setup-local-repository-ubuntu/" target="_blank" rel="noopener">http://linoxide.com/ubuntu-how-to/setup-local-repository-ubuntu/</a><br>public: <a href="https://linux.cn/article-4926-1.html" target="_blank" rel="noopener">https://linux.cn/article-4926-1.html</a></p><p>作者：<a href="http://linoxide.com/author/arunp/" target="_blank" rel="noopener">Arun Pyasi</a><br>译者：<a href="https://github.com/FSSlc" target="_blank" rel="noopener">FSSlc</a><br>校对：<a href="https://github.com/wxy" target="_blank" rel="noopener">wxy</a></p><p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="noopener">Linux中国</a> 荣誉推出</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍使用 APT-Mirror 来制作本地源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://img.linux.net.cn/data/attachment/album/201502/22/222342ybiibj1mj1jdrbam.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Ubuntu" scheme="https://fsslc.github.io/tags/Ubuntu/"/>
    
      <category term="APT-mirror" scheme="https://fsslc.github.io/tags/APT-mirror/"/>
    
  </entry>
  
</feed>

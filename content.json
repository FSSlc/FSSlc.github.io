[{"title":"构建 Seafile Pro docker 镜像及添加 OnlyOffice 支持","date":"2020-03-28T04:44:52.000Z","path":"2020/03/28/build-seafile-pro-with-onlyoffice-support/","text":"主要介绍如何构建 Seafile Pro Docker 镜像以及为它添加 OnlyOffice 的支持。 seafile+onlyoffice 缘由按照我一贯的书写风格（其实就是流水话），这里先讲讲为什么要做这个事情，以及后面怎么做的。 首先最开始接触 Seafile 是在公司北京中心，他们那边用来做内部网盘，分享数据。与那边的 方红杰 认识后，简单了解了是如何部署的。 接着再去年5月底，因为工作原因，到航发那边部署了相关的环境，例如 CentOS 本地源、Seafile 文件共享服务等，再次进行了 Seafile 的部署，但那个时候还是直接使用 Seafile 的安装包，然后将需要的依赖离线安装好，接着再运行 Seafile 官方提供的一个脚本来进行安装的。 最后，最近公司内网需要对 Seafile 的内容进行备份，虽然不是我在做，但自己自从上次到航发部署后，老觉得该直接使用 Docker 来进行 Seafile 的部署了。然后就开始了相关的制作。 另外在 2 月底，因为疫情影响，中心那边想再试试文档协同办公，所以 方红杰 就调查了下，决定用 OnlyOffice 来提供支持，他找了我要相关的安装包。 于是在那两天的周末，一直在搞这个相关的内容，写这篇博文算是一种记录。 好了，说好了缘由，下面开始正式开干。 Seafile 镜像构建首先，Seafile 官方在 github 上有个名为 seafile-docker 仓库 专门用于 Seafile 容器镜像的制作，我的起点也是基于此。 首先将代码 clone 下来，然后看这些代码的操作。因为先前自己有 Bash 和 Docker 等基础，相对来说，这些内容都不难。 然后再基于代码中的 Dockerfile 进行自己的定制。 准备材料所谓的定制就是相关的 crack 了。自己能力有限，只能做相关的搬运工作，通过 Google 查到的相关资料如下： 6 系列版本的 Crack： 破解经历：seafile-pro-6.3.9 破解试用人数上限，开启LADP-解决BUG。 Seafile Pro 6.3.13 专业版破解方法 记录一次破解经历：seafile-pro-6.3.9 破解试用人数上限 较新 Seafile 破解： 订阅的 License 记CentOS7_1904下安装Seafile7.0.11专业版 docker hub 上相关镜像： leeyanzhe/seafile-pro:latest leeyanzhe/seafile-pro-mc:7.0.11 官方相关的资源： 官方文档 seafile pro 下载包地址 根据上面这些资源，就可以找到 6 系列版本的安装包以及破解方法。 老实说，这样搞的确有点不厚道，Seafile 的公司很良心了，在 github 上开源了他们大多数产品的代码和文档，但似乎国内被破解多了，当前他们的客户主要是欧洲那边的了。。。 修改相关脚本参考了上面安装包以及 leeyanzhe/seafile-pro:latest 这个镜像，我们可以将自己准备的材料替换掉原来 seafile-docker 这个仓库中相关的配置以及软件包。 具体内容请看我 github 上提交的仓库 FSSlc/docker-seafile-onlyoffice。 原本 seafile-docker 项目中的镜像分为 base、pro_base、pro_seafile 等几个镜像，其中 base 用来安装基本的环境。 它使用了 phusion/baseimage:0.11 这个镜像，这个镜像的特点改进了原本 Ubuntu 官方镜像的缺点，使用 runit 来做服务管理，使用 /sbin/my_init 来管理容器内的进行，可以使用自定义的启动脚本，在容器创建后，就可以直接启动它们，关于这个镜像的内容，请参考 https://github.com/phusion/baseimage-docker 这个仓库。 而 pro_base 和 pro_seafile 则分别安装了 seafile 需要的依赖和在此基础上，安装了 seafile 。 所以一般只需要该 pro_seafile 这个目录里面的东西即可。 另外，这个仓库还使用了 Makefile 来进行相关任务的管理，这个可以在后面做借鉴。 我在本地构建镜像时，看到 Makefile 里面有 docker-squash 来对镜像做压缩，使得容器大小最小化，另外还有个特点是让别人不能通过查看镜像反推 Dockerfile 的内容，因为它将中间层全部删除了。 对于常用的镜像，可以使用 dive 或者 dockerhub 每个镜像 tag 部分的内容来查看 Dockerfile，原理大抵是利用了 docker history。 我在使用它的时候，自己通过 AUR 安装了 docker-squash，结果老是出错，最后根据网上的讨论，找到了还是需要使用 pip 安装 docker-squash，这个版本的软件才是最好用的。 做完了这个，后来再看 seafile-docker 里面的 ci 脚本，才知道自己饶了一个大圈，早知道先看他们的 ci 脚本了。。 接着再按照自己的需求，使用 Makefile 构建自己需要的镜像就好了。 添加 OnlyOffice 支持前面说过，这个 OnlyOffice 的支持主要用于文档的在线编辑，参考文档为 Seafile 的服务器手册，具体内容看这里。 这个教程讲解得很清楚，照着做就基本可以用来。 但恰恰是这个步骤让我折腾了将近 1 天。。。前后出现两个问题： 如何将相关的配置写入启动的容器中； 如何支持文件的预览与编辑 其中第一个问题的解决办法是：直接找到 seafile 中相关配置文件的生成脚本，然后按照自己的需求做对应的修改。对于第二个问题，我部署好后，老是不能编辑 docx 类似的文件，自己却找不到原因，后来才发现是上面的官方文档挖的坑，在[这里(https://manual-cn-origin.seafile.com/deploy_pro/office-wen-jian-yu-lan-he-bian-ji/only_office#pei-zhi-seafile-fu-wu-1) 只配置了可以修改 ‘docx’, ‘pptx’, ‘xlsx’ 这几种格式，其实还可以按照上面那行，添加对应的修改就可以了。。。 做完这个后，为了测试是否可以同时更改，我还创建了多个用户，同时进行修改，最终的结果还算满意，基本达到了自己预期的效果。 但最后还是留下个问题，编辑文档之前，老是要弹窗，报 onlyoffice 没有配置好，不能保存等，但文档是自动保存的。。 使用 Travis CI 进行发布经过了上面的折腾，后面基本上就没有什么要做的了。但作为一个爱动脑子的人，这样还不满足，我再参考了 seafile-docker 原来的 travis.yml 脚本，进行了容器镜像的自动构建和推送。 具体来说就是如下步骤： 配置好 travis.yml，如何编写可以查看阮一峰的教程 持续集成服务 Travis CI 教程； 申请 travis ci 账号，在 github 上配置好与 Travis ci 的配合； 提交代码触发构建 自己前后提交了 5 6 次才最终将这个任务做成功了，看来还是得多测试。。。 后记在上面的工作做完后，自己再对这些内容做了整理，最终将相关的代码放到了 github 的仓库中，具体是 https://github.com/FSSlc/docker-seafile-onlyoffice，有兴趣的话可以去看看，能够给个 star 就再好不过了。 虽然本篇博文的内容是 2 月底做的，但现在才写了个文章来总结，看来还是需要自己多书写，多输出。","tags":[{"name":"Docker","slug":"Docker","permalink":"https://fsslc.github.io/tags/Docker/"},{"name":"Seafile","slug":"Seafile","permalink":"https://fsslc.github.io/tags/Seafile/"},{"name":"OnlyOffice","slug":"OnlyOffice","permalink":"https://fsslc.github.io/tags/OnlyOffice/"}]},{"title":"《Linux 实战技能 100 讲》笔记","date":"2020-03-21T02:30:30.000Z","path":"2020/03/21/Note-for-geektime-Linux-in-Action/","text":"本文目的主要是对学习 《Linux 实战技能 100 讲》过程中的内容做记录，防止忘记，即便忘记了也可以再回来查。 极客专栏地址： https://time.geekbang.org/course/intro/193 第三章： 系统管理篇26 网络管理网络状态查看工具早期使用 net-tools 工具集，现在较新的 Linux 发行版使用 iproute2 工具集。 简要介绍如下： 1.net-tools ifconfig eth0 第一块网卡 ens33 PCI-E 网卡 enp0s3 无法获取物理信息的 PCI-E 网卡 CentOS 7 使用了一致性网络设备命名，以上都不匹配则使用 eth0 route netstat 2.iproute2 ip ss 网卡接口命名修改 网卡命名规则受 biosdevname 和 net.ifnames 两个参数影响 编辑 /etc/default/grub 文件，增加 biosdevname=0 net.ifnames=0 更新 grub #grub2-mkconfig -o /boot/grub2/grub.cfg 重启 #reboot biosdevname net.ifnames 网卡名 默认 0 1 ens33 组合 1 1 0 em1 组合 2 0 0 eth0 systemd 网络端口命名规则 https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/ 27 查看网络配置ifconfig 输出ifconfig /sbin/ifconfig enp0s31f6: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 ether e8:6a:64:44:77:3c txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 16 memory 0xee300000-ee320000 lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 1425567 bytes 5078552462 (4.7 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1425567 bytes 5078552462 (4.7 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 wlp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.9 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::92ed:8a43:7e6:6880 prefixlen 64 scopeid 0x20&lt;link&gt; ether 1c:1b:b5:3f:4b:4d txqueuelen 1000 (Ethernet) RX packets 78354285 bytes 111604642686 (103.9 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 40923681 bytes 4766853522 (4.4 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 inet 网卡的 ipv4 地址 inet6 网卡的 ipv6 地址 ether 网卡的 MAC 地址 RX TX 发送、接收数据包统计 lo 代表本地环回 网卡，本地地址永远是 127.0.0.1 查看网卡物理链接状态mii-tool - view, manipulate media-independent interface status # sudo mii-tool enp0s31f6 enp0s31f6: no link 查看网关命令 route -n 使用 -n 参数不解析主机名 --&gt;$ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default _gateway 0.0.0.0 UG 600 0 0 wlp2s0 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.18.0.0 0.0.0.0 255.255.0.0 U 0 0 0 br-a1bd391f73c0 192.168.1.0 0.0.0.0 255.255.255.0 U 600 0 0 wlp2s0 default 表示默认网关 28 修改网络配置网络配置命令 ifconfig &lt;接口&gt; &lt;IP地址&gt; [netmask 子网掩码] ifup &lt;接口&gt; ifdown &lt;接口&gt; 网关配置命令添加网关添加默认网关：route add default gw &lt;网关ip&gt;添加明细路由：route add -host &lt;指定ip&gt; gw &lt;网关ip&gt;route add -net &lt;指定网段&gt; netmask &lt;子网掩码&gt; gw &lt;网关ip&gt; 访问某个网段的明细路由 ip 命令 ip addr ls = ifconfig ip link set dev eth0 up = ipup eth0 ip addr add 10.0.0.1/24 dev eth1 = ifconfig eth1 10.0.0.1/24 netmask 255.255.255.0 ip route add 10.0.0.1/24 via 192.168.0.1 = route add -net 10.0.0.0 netmask 255.255.255.0 gw 192.168.0.1 29 网络故障排除排除命令： ping 检测网络是否可达 , -c 指定次数 traceroute 检测每一跳的情况 ； -w 等待时间 mtr 检测包是否丢失 My traceroute nslookup 域名查看 ip telnet 检查端口连接状态 telnet www.baidu.com 80 tcpdump 抓取数据包 tcpdump -i any -n port 80 tcpdump -i any -n host 10.0.0.1 tcpdump -i any -n host 10,0.0.1 and port 80 -w /tmp/dump.txt netstat 端口查看状态 -n 显示 ip 地址， t tcp -p 进程 l listen ss 参数与 netstat 类似 30 网络管理和配置文件网络服务管理网络服务管理程序分为 SysV 和 systemd， 下面是常用的一些命令： service network start/stop/restart chkconfig -list network chkconfig --level 2345 network off/on systemctl list-unit-files NetworkManager.service systemctl start/stop/restart NetworkManager systemctl enable/disable NetworkManager 配置文件： /et/sysconfig/network-scripts/ifcfg-** BOOTPROTO=dhcp/static/none ONBOOT=&quot;yes&quot;/&quot;no&quot; IPADDR NETMASK GATEWAY DNS1 DNS2 DNS3 /etc/hosts 主机名 hostname # 展示主机名 hostname NAME # 临时设置主机名 hostnamectl set-hostname NAME # 永久设置主机名","tags":[{"name":"笔记","slug":"笔记","permalink":"https://fsslc.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"https://fsslc.github.io/tags/Linux/"}]},{"title":"[翻译] 在 Linux 系统中禁用与解禁用户的账号","date":"2020-01-23T13:43:13.000Z","path":"2020/01/23/Translate-Locking-and-unlocking-accounts-on-Linux-systems/","text":"总有这样的时候：有时你需要禁用某位 Linux 用户的账号，有时你还需要反过来解禁用户的账号。本文将介绍一些管理用户访问的命令，并介绍它们背后的原理。 假如你正管理着一台 Linux 系统，那么很有可能将遇到需要禁用一个账号的情况。可能是某人已经换了职位，他们是否还需要该账号仍是个问题；或许有理由相信再次使用该账号并没有大碍。不管上述哪种情况，知晓如何禁用账号并解禁账号都是你需要知道的知识。 需要你记住的一件重要的事是尽管有多种方法来禁用账号，但它们并不都达到相同的效果。假如用户使用公钥/私钥来使用该账号而不是使用密码来访问，那么你使用的某些命令来阻止用户获取该账号或许将不会生效。 使用 passwd 来禁用一个账号最为简单的用来禁用一个账号的方法是使用 passwd -l 命令。例如： $ sudo passwd -l tadpole 上面这个命令的效果是在加密后的密码文件 /etc/shadow 中，用户对应的那一行的最前面加上一个 ! 符号。这样就足够阻止用户使用密码来访问账号了。 在没有使用上述命令前，加密后的密码行如下所示（请注意第一个字符）： $6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPCnXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7::: 而禁用该账号后，这一行将变为： !$6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPCnXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7::: 在 tadpole 下一次尝试登录时，他可能会使用他原有的密码来尝试多次登录，但就是无法再登录成功了。另一方面，你则可以使用下面的命令来查看他这个账号的状态（-S = status）： $ sudo passwd -S tadpole tadpole L 10/15/2019 0 99999 7 -1 第二项的 L 告诉你这个账号已经被禁用了。在该账号被禁用前，这一项应该是 P。如果显示的是 NP 则意味着该账号还没有设置密码。 命令 usermod -L 也具有相同的效果（添加 ! 来禁用账号的使用）。 使用这种方法来禁用某个账号的一个好处是当需要解禁某个账号时非常容易。只需要使用一个文本编辑器或者使用 passwd -u 命令来执行相反的操作，即将添加的 ! 移除即可。 $ sudo passwd -u tadpole passwd: password expiry information changed. 但使用这种方式的问题是如果用户使用公钥/私钥对的方式来访问他/她的账号，这种方式将不能阻止他们使用该账号。 使用 chage 命令来禁用账号另一种禁用用户账号的方法是使用 chage 命令，它可以帮助管理用户账号的过期日期。 $ sudu chage -E0 tadpole $ sudo passwd -S tadpole tadpole P 10/15/2019 0 99999 7 -1 chage 命令将会稍微修改 /etc/shadow 文件。在这个使用 : 来分隔的文件（下面将进行展示）中，某行的第 8 项将被设置为 0（先前为空），这就意味着这个账号已经过期了。chage 命令会追踪密码更改期间的天数，通过选项也可以提供账号过期信息。第 8 项如果是 0 则意味着这个账号在 1970 年 1 月 1 日后的一天过期，当使用上面显示的那个命令时可以用来禁用账号。 $ sudo grep tadpole /etc/shadow | fold tadpole:$6$IC6icrWlNhndMFj6$Jj14Regv3b2EdK.8iLjSeO893fFig75f32rpWpbKPNz7g/eqeaPC nXl3iQ7RFIN0BGC0E91sghFdX2eWTe2ET0:18184:0:99999:7::0: ^ | +--- days until expiration 为了执行相反的操作，你可以简单地使用下面的命令将放置在 /etc/shadow 文件中的 0 移除掉： % sudo chage -E-1 tadpole 一旦一个账号使用这种方式被禁用，即便是无密码的 SSH 登录也不能再访问该账号了。 via: https://www.networkworld.com/article/3513982/locking-and-unlocking-accounts-on-linux-systems.html 作者：Sandra Henry-Stocker选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://fsslc.github.io/tags/Linux/"},{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"禁用用户","slug":"禁用用户","permalink":"https://fsslc.github.io/tags/%E7%A6%81%E7%94%A8%E7%94%A8%E6%88%B7/"}]},{"title":"使用 Python 软件包来处理较为复杂的 JSON 文件","date":"2019-12-16T08:04:26.000Z","path":"2019/12/16/Python-Deals-large-json-file-md/","text":"使用 Python 软件包来处理较为复杂的 JSON 文件 最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。 复杂 json 示例下面展示的是一个较为复杂的 JSON 数据，这里列出只是展示一个较为复杂的 JSON 数据会怎么复杂。 [ // 一个 data group 根数据库的示例 { // 首先是激活条件 &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, // 接着是它包含的键值对，可包含多个，这里只显示一个 &quot;items&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;enum_list&quot;: null, &quot;max&quot;: null, &quot;min&quot;: null, &quot;name&quot;: &quot;periodic_dimension&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;int_array&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/periodic_dimension&quot;, &quot;value&quot;: &quot;0,0,0&quot; } ], // 然后是它包含的子数据库，可能会嵌套 &quot;librarys&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;items&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;enum_list&quot;: null, &quot;max&quot;: null, &quot;min&quot;: null, &quot;name&quot;: &quot;SAT_MODEL&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;string&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel/SAT_MODEL&quot;, &quot;value&quot;: &quot;model.sat&quot; } ], &quot;librarys&quot;: [], &quot;name&quot;: &quot;CADModel&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;Library_Fixed&quot;, &quot;uid&quot;: &quot;{b717c641-4145-44ac-8468-efb7afa451f1}&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel&quot; } ], // 最后是 data group 的额外属性 &quot;name&quot;: &quot;CartesianGeometry&quot;, &quot;show&quot;: { &quot;show_name&quot;: &quot;CartesianGeometry&quot;, &quot;show_on_interface&quot;: true }, &quot;type&quot;: &quot;Library_Fixed&quot;, &quot;uid&quot;: &quot;{909515c3-d978-4021-943b-0d6e7fc3136d}&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry&quot; }, // 后面再添加类似的其他 data group ] Python 标准库中对 json 数据的处理在 Python 标准库中，自带 json 模块，可以使用 import json 来使用它。 主要的函数有如下几个： json.dumps：将 Python 对象序列化为 json 字符串 json.dump：将 Python 对象序列化为 json 对象 json.loads：将 json 字符串导入为 Python 对象 json.load：将 json 对象导入为 Python 对象 另外，json 模块还提供一个命令行接口 json.tool，可以在终端中使用，常用的例子如下： $ echo &#39;{&quot;json&quot;: &quot;obj&quot;}&#39; | python -m json.tool { &quot;json&quot;: &quot;obj&quot; } 另外最为常见的使用场景是读入 json 文件的数据，然后经过修改，再将 json 数据写回 json 文件中。 下面的代码就展示这两个常用的使用场景： # 打开文件将 json 数据读入 data_json 对象中 with open(modelFile) as f: data_json = json.load(f) # 打开新文件，将 data_json 数据写入新的 json 文件中 with open(modModleFile, &#39;w&#39;) as f: f.write(json.dumps(data_json, indent=2)) 常见处理 JSON 的 Python 软件包针对上面我们的需求，需要对复杂 JSON 数据做处理，所以就在网上进行了相关的搜索。针对 JSON 数据的筛选，搜索后知道有个 JSONPath 的提议，仿照XPath 的语法来查询 JSON 数据。 然后就根据 JSONPath 这个关键字在 PyPI 中搜索都了一些软件包，下面简单罗列一下： dpath主页：https://www.github.com/akesterson/dpath-python特点：使用类型 XPath 的语法来对复杂 json 数据做查询优点：如果熟悉 XPath 的话，可以快速上手缺点：无法做复杂的模糊查询，需要知道大致路径来获取数据 jsonpath主页：www.ultimate.com/phil/python/#jsonpath特点：是对上面 jsonPath 提议的一个实现，经过测试发现，相比于后面提及的这些软件，它的查询效率最高优点：查询效率高，单文件的实现缺点：缺乏文档，开发久远；但还在持续更新 jsonpath2主页：https://pypi.org/project/jsonpath2/特点：是对上面 jsonPath 提议的一个实现，有 ANTLR v4 的语法支持，可以生成 antlr 语法解析优点：支持 antlr 语法缺点：文档太少，只是 jsonPath 的又一个实现，特点不突出 jsonpath-rw主页：https://github.com/kennknowles/python-jsonpath-rw特点：提供健壮的实现，在 Python 2.7, 3.4, 3.5, 3.6, 3.7, pypy 和 pypy3 上都测试过； 实现早，开发者多（15），GitHub 上的星多（434）；优点：开发者多，将 jsonPath 表达式当做第一类对象缺点：无法对数据做复杂的筛选 jsonpath-rw-ext主页：https://github.com/sileht/python-jsonpath-rw-ext特点：对上面的 jsonpath-rw 做了一些扩展，尤其是对筛选的支持优点：支持筛选缺点：文档不是太详细，筛选似乎只支持 list jsonpath-ng主页：https://github.com/h2non/jsonpath-ng特点：结合了上面 jsonpath-rw 和 jsonpath-rw-ext 的能力，是 jsonpath-rw 的一个 fork优点：具有上面两个包的功能，才能使用；文档详细缺点：扩展的使用有点不太方便 在查找到了这些软件包后，我针对它们都进行了一些测试，最后测试后发现，在查询方面， jsonpath 这个包的解析速度最快。 注：同时引入 jsonpath 和 jsonpath-rw-ext 会引起冲突，我的解决办法是只安装 jsonpath-rw-ext ，将 jsonpath 的单文件实现直接放入代码中，要使用时再引入。 下面回到整体，介绍如何对复杂 JSON 数据进行查询、筛选和修改。 如何查询复杂 json 数据经过了上面的搜索，简单来说可以直接使用上面的多个软件包，然后按照 JsonPath 的语法来对复杂数据进行查询。 下面是 JsonPath 的提议，摘自上面提及的网址。 JSONPath 描述 $ 代表根对象 @ 代表当前对象 . 或 [] 取孩子操作 .. 递归搜索后代 * 通配符，代表所有对象 [] 取下标操作，在 JSON 中，它是自带的数组操作 [,] 表示去其中的任意一个 [start:end:step] 数组切片操作 ?() 执行筛选操作 () 脚本表达式，不常用 如何筛选复杂 json 数据基于前面的搜索，如果要实现对复杂 json 数据的筛选功能，当前就只能使用上面的 jsonpath-rw-ext 或者 jsonpath-ng ，其中 jsonpath-ng 的筛选功能来自于 jsonpath-rw-ext，所以在最后的解决方案中，我直接使用了 jsonpath-rw-ext 来做复杂筛选。 在使用时，为了支持变量值的替换，可能还需要使用转义符。 另外，在做筛选时，可以利用 jsonPath 中 .. @ 等运算符来做模糊筛选。 具体的使用方法可以参考上面两个软件包的主页。这里就不再介绍。 下面重点介绍如何修改 json 数据。 如何修改复杂 json 数据基于上面的说明，我们知道可以使用上面的这些软件包来查询复杂 json ，但是对于如何修改数据，这些软件的文档中都没有太多的涉及。 另外根据我做的这个任务的需求，可能还需要在对 json 数据做了筛选后，再对筛选到的数据做修改。 python-jsonpath-rw GitHub 主页上的 issue 21 上有类似的说明，但自己根据上的说明去实现时，感觉无法满足上面的需求，故作罢。 另外 python-jsonpath-rw 在代码仓库中似乎更新了一个 update 方法，但没有更新到 PyPI 中，所以必须下载 GitHub 的代码才能使用该功能。在最后的实现时便没有使用该功能。 最终，我在 stack overflow 上找到了一个参考的例子： from jsonpath_rw import jsonpath, parse data = {&quot;dogs&quot;:[{&quot;tail&quot;: True, &quot;properties&quot;:{&quot;test&quot;:1}}]} jsonpath_expr = parse(&quot;dogs.[0].properties&quot;) jsonpath_expr.find(data)[0].value[&#39;test&#39;] = 2 print(data) # {&#39;dogs&#39;: [{&#39;tail&#39;: True, &#39;properties&#39;: {&#39;test&#39;: 2}}]} 通过上面的例子我得到启发，可以使用 jsonpath-rw-ext 或者 jsonpath-ng 包的筛选功能，再使用上面例子中类型的做法来达到筛选并修改特定键值的目的，这样我的需求就可以解决了。 在经过测试后，最终用来修改 input 模板文件中给定键值对的代码如下： import json import jsonpath_rw_ext def Modify_model(refVar, refValue, modelFile, modModleFile=&#39;run.json&#39;): &quot;&quot;&quot;利用 jsonpath_rw_ext 库搜索 json 格式的模板文件，并修改相应的值 refVar: 需要修改的参数的名称 refValue: 修改过后参数的值 modelFile: json 格式的模板文件 modModleFile: 修改过后的 json 模板文件 &quot;&quot;&quot; with open(modelFile) as f: data_json = json.load(f) parse_str = f&#39;$..items[?(@.unique_name=\\&quot;{refVar}\\&quot;)]&#39; jsonpath_rw_ext.parser.ExtentedJsonPathParser().parse(parse_str).find(data_json)[0].value[&#39;value&#39;] = f&#39;{refValue}&#39; if not os.path.exists(modModleFile): # 如果不存在文件，则直接创建空文件 # ref: https://stackoverflow.com/questions/12654772/create-empty-file-using-python open(modModleFile, &#39;a&#39;).close() with open(modModleFile, &#39;w&#39;) as f: f.write(json.dumps(data_json, indent=2)) 上面的代码中有几点需要说明： parse_str = f&#39;$..items[?(@.unique_name=\\&quot;{refVar}\\&quot;)]&#39; 这句使用了 Python 的新语法，直接将 refVar 的值替换到字符串中，这需要 Python 3.6 才能支持。另外还转义了括号，使得这个函数更加通用； jsonpath_rw_ext.parser.ExtentedJsonPathParser() 这句是为了使用扩展功能才这样写的，具体的使用方法可以参考其主页章的文档； 根据 GitHub 上的 issue，似乎筛选功能只对 list 生效，相关代码在这里。","tags":[{"name":"Python","slug":"Python","permalink":"https://fsslc.github.io/tags/Python/"},{"name":"JSON","slug":"JSON","permalink":"https://fsslc.github.io/tags/JSON/"}]},{"title":"[翻译] 如何在 Linux 中验证 ISO 镜像","date":"2019-08-11T00:01:36.000Z","path":"2019/08/11/Translate-How-To-Verify-ISO-Images-In-Linux/","text":"介绍在 Linux 中使用如何验证 ISO 镜像的合法性。 你从喜爱的 Linux 发行版的官方网站或第三方网站下载了它的 ISO 镜像之后，接下来要做什么呢？是创建可启动介质并开始安装系统吗？并不是，请稍等一下。在开始使用它之前，强烈建议你检查一下你刚下载到本地系统中的 ISO 文件是否是下载镜像站点中 ISO 文件的一个精确拷贝。因为在前几年 Linux Mint 的网站被攻破了，并且攻击者创建了一个包含后门的经过修改的 Linux Mint ISO 文件。 所以验证下载的 Linux ISO 镜像的可靠性和完整性是非常重要的一件事儿。假如你不知道如何在 Linux 中验证 ISO 镜像，本次的简要介绍将给予你帮助，请接着往下看！ 在 Linux 中验证 ISO 镜像我们可以使用 ISO 镜像的“校验和”来验证 ISO 镜像。校验和是一系列字母和数字的组合，用来检验下载文件的数据是否有错以及验证其可靠性和完整性。当前存在不同类型的校验和，例如 SHA-0、SHA-1、SHA-2（224、256、384、512）和 MD5。MD5 校验和最为常用，但对于现代的 Linux 发行版，SHA-256 最常被使用。 我们将使用名为 gpg 和 sha256 的两个工具来验证 ISO 镜像的可靠性和完整性。 下载校验和及签名针对本篇指南的目的，我将使用 Ubuntu 18.04 LTS 服务器 ISO 镜像来做验证，但对于其他的 Linux 发行版应该也是适用的。 在靠近 Ubuntu 下载页的最上端，你将看到一些额外的文件（校验和及签名），正如下面展示的图片那样： 其中名为 SHA256SUMS 的文件包含了这里所有可获取镜像的校验和，而 SHA256SUMS.gpg 文件则是这个文件的 GnuPG 签名。在下面的步骤中，我们将使用这个签名文件来 验证 校验和文件。 下载 Ubuntu 的 ISO 镜像文件以及刚才提到的那两个文件，然后将它们放到同一目录下，例如这里的 ISO 目录： $ ls ISO/ SHA256SUMS SHA256SUMS.gpg ubuntu-18.04.2-live-server-amd64.iso 如你所见，我已经下载了 Ubuntu 18.04.2 LTS 服务器版本的镜像，以及对应的校验和文件和签名文件。 下载有效的签名秘钥现在，使用下面的命令来下载正确的签名秘钥： $ gpg --keyid-format long --keyserver hkp://keyserver.ubuntu.com --recv-keys 0x46181433FBB75451 0xD94AA3F0EFE21092 示例输出如下： gpg: key D94AA3F0EFE21092: 57 signatures not checked due to missing keys gpg: key D94AA3F0EFE21092: public key &quot;Ubuntu CD Image Automatic Signing Key (2012) &lt;[email protected]&gt;&quot; imported gpg: key 46181433FBB75451: 105 signatures not checked due to missing keys gpg: key 46181433FBB75451: public key &quot;Ubuntu CD Image Automatic Signing Key &lt;[email protected]&gt;&quot; imported gpg: no ultimately trusted keys found gpg: Total number processed: 2 gpg: imported: 2 验证 SHA-256 校验和接下来我们将使用签名来验证校验和文件： $ gpg --keyid-format long --verify SHA256SUMS.gpg SHA256SUMS 下面是示例输出： gpg: Signature made Friday 15 February 2019 04:23:33 AM IST gpg: using DSA key 46181433FBB75451 gpg: Good signature from &quot;Ubuntu CD Image Automatic Signing Key &lt;[email protected]&gt;&quot; [unknown] gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: C598 6B4F 1257 FFA8 6632 CBA7 4618 1433 FBB7 5451 gpg: Signature made Friday 15 February 2019 04:23:33 AM IST gpg: using RSA key D94AA3F0EFE21092 gpg: Good signature from &quot;Ubuntu CD Image Automatic Signing Key (2012) &lt;[email protected]&gt;&quot; [unknown] gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 8439 38DF 228D 22F7 B374 2BC0 D94A A3F0 EFE2 1092 假如你在输出中看到 Good signature 字样，那么该校验和文件便是由 Ubuntu 开发者制作的，并且由秘钥文件的所属者签名认证。 检验下载的 ISO 文件下面让我们继续检查下载的 ISO 文件是否和所给的校验和相匹配。为了达到该目的，只需要运行： $ sha256sum -c SHA256SUMS 2&gt;&amp;1 | grep OK ubuntu-18.04.2-live-server-amd64.iso: OK 假如校验和是匹配的，你将看到 OK 字样，这意味着下载的文件是合法的，没有被改变或篡改过。 假如你没有获得类似的输出，或者看到不同的输出，则该 ISO 文件可能已经被修改过或者没有被正确地下载。你必须从一个更好的下载源重新下载该文件。 某些 Linux 发行版已经在它的下载页面中包含了校验和。例如 Pop!_os 的开发者在他们的下载页面中提供了所有 ISO 镜像的 SHA-256 校验和，这样你就可以快速地验证这些 ISO 镜像。 在下载完 ISO 镜像文件后，可以使用下面的命令来验证它们： $ sha256sum Soft_backup/ISOs/pop-os_18.04_amd64_intel_54.iso 示例输出如下： 680e1aa5a76c86843750e8120e2e50c2787973343430956b5cbe275d3ec228a6 Soft_backup/ISOs/pop-os_18.04_amd64_intel_54.iso 在上面的输出中，以 680elaa 开头的部分为 SHA-256 校验和的值。请将该值与位于下载页面中提供的 SHA-256 校验和的值进行比较，如果这两个值相同，那说明这个下载的 ISO 文件是合法的，与它的原有状态相比没有经过更改或者篡改。万事俱备，你可以进行下一步了！ 上面的内容便是我们如何在 Linux 中验证一个 ISO 文件的可靠性和完整性的方法。无论你是从官方站点或者第三方站点下载 ISO 文件，我们总是推荐你在使用它们之前做一次简单的快速验证。希望本篇的内容对你有所帮助。 参考文献： https://tutorials.ubuntu.com/tutorial/tutorial-how-to-verify-ubuntu via: https://www.ostechnix.com/how-to-verify-iso-images-in-linux/ 作者：sk选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://fsslc.github.io/tags/Linux/"},{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Autojump","slug":"Autojump","permalink":"https://fsslc.github.io/tags/Autojump/"}]},{"title":"[翻译] Linux 中改变主机名的 4 种方法","date":"2019-03-25T03:18:37.000Z","path":"2019/03/25/Translate-4-Methods-To-Change-The-HostName-In-Linux/","text":"介绍如何修改主机名。 昨天我们已经在我们的网站中写过如何在 Linux 中修改主机名的文章。今天，我们将向你展示使用不同的方法来修改主机名。你可以从中选取最适合你的方法。 使用 systemd 的系统自带一个名为 hostnamectl 的好用工具，它可以使我们能够轻易地管理系统的主机名。 当你使用这个原生命令时，它可以立刻改变主机名而无需重启来生效。 但假如你通过手动修改某个配置文件来更改主机名，那么就可能需要经过重启来生效。 在这篇文章中，我们将展示在使用 systemd 的系统中改变主机名的 4 种方法。 hostnamectl 命令允许在 Linux 中设置三类主机名，它们的细节如下： 静态： 这是静态主机名，由系统管理员添加。 瞬时/动态： 这个由 DHCP 或者 DNS 服务器在运行时赋予。 易读形式： 它可以由系统管理员赋予。这个是自由形式的主机名，以一种易读形式来表示服务器，例如 “JBOSS UAT Server” 这样的名字。 这些都可以使用下面 4 种方法来设置。 hostnamectl 命令：控制系统主机名。 nmcli 命令：是一个控制 NetworkManager 的命令行工具。 nmtui 命令：是一个控制 NetworkManager 的文本用户界面。 /etc/hostname 文件：这个文件中包含系统的静态主机名。 方法 1：在 Linux 中使用 hostnamectl 来改变主机名hostnamectl 可被用来查询和改变系统的主机名，以及相关设定。只需运行 hostnamectl 便可以查看系统的主机名了。 $ hostnamectl 或者使用下面的命令： $ hostnamectl status Static hostname: daygeek-Y700 Icon name: computer-laptop Chassis: laptop Machine ID: 31bdeb7b83230a2025d43547368d75bc Boot ID: 267f264c448f000ea5aed47263c6de7f Operating System: Manjaro Linux Kernel: Linux 4.19.20-1-MANJARO Architecture: x86-64 假如你想改变主机名，可以使用下面的命令格式： 语法格式： $ hostnamectl set-hostname [YOUR NEW HOSTNAME] 使用下面的命令来使用 hostnamectl 更改主机名。在这个例子中，我将把主机名从 daygeek-Y700 改为 magi-laptop 。 $ hostnamectl set-hostname magi-laptop 你可以使用下面的命令来查看更新后的主机名。 $ hostnamectl Static hostname: magi-laptop Icon name: computer-laptop Chassis: laptop Machine ID: 31bdeb7b83230a2025d43547368d75bc Boot ID: 267f264c448f000ea5aed47263c6de7f Operating System: Manjaro Linux Kernel: Linux 4.19.20-1-MANJARO Architecture: x86-64 方法 2：在 Linux 中使用 nmcli 命令来更改主机名nmcli 是一个命令行工具，旨在控制 NetworkManager 并报告网络状态。 nmcli 被用来创建、展示、编辑、删除、激活和注销网络连接，同时还可以用来控制和展示网络设备的状态。另外，它也允许我们更改主机名。 使用下面的命令来利用 nmcli 查看当前的主机名。 $ nmcli general hostname daygeek-Y700 语法格式： $ nmcli general hostname [YOUR NEW HOSTNAME] 使用下面的命令来借助 nmcli 命令可以更改主机名。在这个例子中，我将把主机名从 daygeek-Y700 变成 magi-laptop 。 $ nmcli general hostname magi-laptop 它可以在不重启下设备的情况下生效，但为了安全目的，只需要重启 systemd-hostnamed 服务来使得更改生效。 $ sudo systemctl restart systemd-hostnamed 再次运行相同的 nmcli 命令来检查更改后的主机名。 $ nmcli general hostname magi-laptop 方法 3：在 Linux 中使用 nmtui 来更改主机名nmtui 是一个基于 curses 库的 TUI 应用，被用来和 NetworkManager 交互。当启动 nmtui 后，如果没有指定 nmtui 的第一个命令行参数，它将提醒用户选择执行某项活动。 在终端中运行下面的命令来开启文本用户界面。 $ nmtui 使用向下箭头按键来选择 “Set system hostname” 这个选项，然后敲击回车键。 下面的截图展示的是原来的主机名。 我们需要做的就是删除原来的主机名，再输入新的主机名，然后选中 “OK” 敲击回车确认就可以了。 然后它将在屏幕中向你展示更新后的主机名，再次选中 “OK” 敲击回车确认就完成更改了。 最后，选中 “Quit” 按钮来从 nmtui 终端界面离开。 它可以在不重启设备的情况下生效，但为了安全目的，需要重启 systemd-hostnamed 服务来使得更改生效。 $ sudo systemctl restart systemd-hostnamed 你可以运行下面的命令来查看更新后的主机名。 $ hostnamectl Static hostname: daygeek-Y700 Icon name: computer-laptop Chassis: laptop Machine ID: 31bdeb7b83230a2025d43547368d75bc Boot ID: 267f264c448f000ea5aed47263c6de7f Operating System: Manjaro Linux Kernel: Linux 4.19.20-1-MANJARO Architecture: x86-64 方法 4：在 Linux 中使用 /etc/hostname 来更改主机名除了上面的方法外，我们还可以通过修改 /etc/hostname 文件来达到修改主机名的目的。但这个方法需要服务器重启才能生效。 使用下面的命令来检查 /etc/hostname 文件以查看当前的主机名： $ cat /etc/hostname daygeek-Y700 要改变主机名，只需覆写这个文件就行了，因为这个文件只包含主机名这一项内容。 $ sudo echo &quot;magi-daygeek&quot; &gt; /etc/hostname $ cat /etc/hostname magi-daygeek 然后使用下面的命令重启系统： $ sudo init 6 最后查看 /etc/hostname 文件的内容来验证主机名是否被更改了。 $ cat /etc/hostname magi-daygeek via: https://www.2daygeek.com/four-methods-to-change-the-hostname-in-linux/publish: https://linux.cn/article-10651-1.html 作者：Magesh Maruthamuthu选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"主机名","slug":"主机名","permalink":"https://fsslc.github.io/tags/%E4%B8%BB%E6%9C%BA%E5%90%8D/"}]},{"title":"[翻译] 在 Linux 中运行特定命令而无需 sudo 密码","date":"2019-03-21T14:07:56.000Z","path":"2019/03/21/Translate-Run-Particular-Commands-Without-Sudo-Password-In-Linux/","text":"介绍 sudo 的一个高级用法。 我有一台部署在 AWS 上的 Ubuntu 系统，在它的里面有一个脚本，这个脚本的原有目的是以一定间隔（准确来说是每隔 1 分钟）去检查某个特定服务是否正在运行，如果这个服务因为某些原因停止了，就自动重启这个服务。但问题是我需要 sudo 权限来开启这个服务。正如你所知道的那样，当我们以 sudo 用户运行命令时，我们应该提供密码，但我并不想这么做，实际上我想做的是以 sudo 用户的身份运行这个服务但无需提供密码。假如你曾经经历过这样的情形，那么我知道一个简单的方法来做到这点。今天，在这个简短的指南中，我将教你如何在类 Unix 的操作系统中运行特定命令而无需 sudo 密码。 就让我们看看下面的例子吧。 $ sudo mkdir /ostechnix [sudo] password for sk: 正如上面的截图中看到的那样，当我在根目录（ / ）中创建一个名为 ostechnix 的目录时，我需要提供 sudo 密码。每当我们尝试以 sudo 特权执行一个命令时，我们必须输入密码。而在我的预想中，我不想提供 sudo 密码。下面的内容便是我如何在我的 Linux 机子上运行一个 sudo 命令而无需输入密码的过程。 在 Linux 中运行特定命令而无需 sudo 密码基于某些原因，假如你想允许一个用户运行特定命令而无需提供 sudo 密码，则你需要在 sudoers 文件中添加上这个命令。 假如我想让名为 sk 的用户去执行 mkdir 而无需提供 sudo 密码，下面就让我们看看该如何做到这点。 使用下面的命令来编辑 sudoers 文件： $ sudo visudo 将下面的命令添加到这个文件的最后。 sk ALL=NOPASSWD:/bin/mkdir 其中 sk 是用户名。根据上面一行的内容，用户 sk 可以从任意终端执行 mkdir 命令而不必输入 sudo 密码。 你可以用逗号分隔的值来添加额外的命令（例如 chmod ），正如下面展示的那样。 sk ALL=NOPASSWD:/bin/mkdir,/bin/chmod 保存并关闭这个文件，然后注销（或重启）你的系统。现在以普通用户 sk 登录，然后试试使用 sudo 来运行这些命令，看会发生什么。 $ sudo mkdir /dir1 看到了吗？即便我以 sudo 特权运行 mkdir 命令，也不会弹出提示让我输入密码。从现在开始，当用户 sk 运行 mkdir 时，就不必输入 sudo 密码了。 当运行除了添加到 sudoers 文件之外的命令时，你将被提示输入 sudo 密码。 让我们用 sudo 来运行另一个命令。 $ sudo apt update 看到了吗？这个命令将提示我输入 sudo 密码。 假如你不想让这个命令提示你输入 sudo 密码，请编辑 sudoers 文件： $ sudo visudo 像下面这样将 apt 命令添加到 sudoers 文件中： sk ALL=NOPASSWD:/bin/mkdir,/usr/bin/apt 你注意到了上面命令中 apt 二进制执行文件的路径与 mkdir 的有所不同吗？是的，你必须提供一个正确的可执行文件路径。要找到任意命令的可执行文件路径，例如这里的 apt ，可以像下面这样使用 whichis 命令来查看： $ whereis apt apt: /usr/bin/apt /usr/lib/apt /etc/apt /usr/share/man/man8/apt.8.gz 如你所见， apt 命令的可执行文件路径为 /usr/bin/apt ，所以我将这个路径添加到了 sudoers 文件中。 正如我前面提及的那样，你可以添加任意多个以逗号分隔的命令。一旦你做完添加的动作，保存并关闭你的 sudoers 文件，接着注销，然后重新登录进你的系统。 现在就检验你是否可以直接运行以 sudo 开头的命令而不必使用密码： $ sudo apt update 看到了吗？ apt 命令没有让我输入 sudo 密码，即便我用 sudo 来运行它。 下面展示另一个例子。假如你想运行一个特定服务，例如 apache2 ，那么就添加下面这条命令到 sudoers 文件中： sk ALL=NOPASSWD:/bin/mkdir,/usr/bin/apt,/bin/systemctl restart apache2 现在用户 sk 就可以运行 sudo systemctl restart apache 命令而不必输入 sudo 密码了。 我可以再次让一个特别的命令提醒输入 sudo 密码吗？当然可以！只需要删除添加的命令，注销然后再次登录即可。 除了这种方法外，你还可以在命令的前面添加 PASSWD: 指令。让我们看看下面的例子： 在 sudoers 文件中添加或者修改下面的一行： sk ALL=NOPASSWD:/bin/mkdir,/bin/chmod,PASSWD:/usr/bin/apt 在这种情况下，用户 sk 可以运行 mkdir 和 chmod 命令而不用输入 sudo 密码。然而，当他运行 apt 命令时，就必须提供 sudo 密码了。 免责声明：本篇指南仅具有教育意义。在使用这个方法的时候，你必须非常小心。这个命令既可能富有成效但也可能带来摧毁性效果。例如，假如你允许用户执行 rm 命令而不输入 sudo 密码，那么他们可能无意或有意地删除某些重要文件。我警告过你了！ 那么这就是全部的内容了。希望这个能够给你带来帮助。更多精彩内容即将呈现，请保持关注！ 干杯！ via: https://www.ostechnix.com/run-particular-commands-without-sudo-password-linux/publish: https://linux.cn/article-10641-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"sudo","slug":"sudo","permalink":"https://fsslc.github.io/tags/sudo/"}]},{"title":"[翻译] McFly：利用神经网络为 Bash 提供历史命令搜索功能","date":"2019-01-04T15:25:53.000Z","path":"2019/01/04/Translate-McFly-A-Replacement-To-Ctrl-R-Bash-History-Search-Feature/","text":"介绍 McFly，替代 Bash 中 Ctrl + R 的功能。 假如你在命令行模式下渡过了很长时间，那么你必定使用过或者听说过 BASH 的 反向搜索 功能，在 Bash 中执行反向搜索功能的快捷键是 Ctrl+r 。通过使用这个特性，我们可以找到我们执行过的命令而无需再次输入它们。当然，你可以使用上下键来搜索你的 bash 命令记录，但使用 Ctrl+r 快捷键可以让这个搜索过程更简单快速。今天我找寻到了 Bash 历史命令搜索特性 Ctrl+r 的一个替代品，它就是 McFly。McFly 是一个使用 Rust 编程语言写就的简洁工具，自带一个智能的搜索引擎，用来替换默认的 Ctrl+r 这个 Bash 历史命令搜索功能。 McFly 提供的命令建议都是通过一个小巧的 神经网络 来实时排序给出的。 McFly 重新绑定了 Ctrl+r 快捷键，可以从你的 Bash 历史命令中找到所有最近执行过的命令。它通过追溯下面的信息来增强你的 shell 历史命令搜索特性： 命令结束状态 当你运行命令时的时间戳 以及你运行命令的执行目录 它将所有追溯的信息保存在一个 SQLite 数据库中。由于它追溯了命令的历史结束状态，所以你可以很轻易地忽略掉失败的命令。听起来很酷，对吧？ 在给出一个命令建议时，它将考虑如下因素： 你在哪个目录执行的这个命令，将来你很有可能在相同的目录重复这个命令 在你执行这个命令之前，执行过什么命令 你执行这个命令有多频繁 你最后执行该命令的时间 你是否在 McFly 中选择过这个命令 以及这个命令的历史结束状态。因为你很有可能不会去执行失败过的命令，对吧？ McFly 维护着你的默认 Bash 历史文件，所以你可以随时停止使用它。McFly 也并不只服务于 BASH， 它也可以扩展到其他 shell 程序。 安装 McFly在 Linux 中，McFly 可以使用 Linuxbrew 来安装。如若你还没有安装过 Linuxbrew，那么你可以参考下面的这个链接。（LCTT 译注：从其 GitHub 主页了解到也可以下载其二进制来使用。） Linuxbrew：一个用于 Linux 和 Mac OS X 的通用包管理 一旦安装好了 Linuxbrew，运行下面的命令来安装 McFly： $ brew tap cantino/mcfly https://github.com/cantino/mcfly $ brew install mcfly 在安装完成后，你将看到下面的输出： ==&gt; Installing mcfly from cantino/mcfly ==&gt; Downloading https://github.com/cantino/mcfly/releases/download/v0.2.5/mcfly-v0 ==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.c ######################################################################## 100.0% ==&gt; ONE MORE STEP! Edit ~/.bashrc and add the following: if [ -f $(brew --prefix)/opt/mcfly/mcfly.bash ]; then . $(brew --prefix)/opt/mcfly/mcfly.bash fi 🍺 /home/linuxbrew/.linuxbrew/Cellar/mcfly/v0.2.5: 4 files, 3.5MB, built in 33 seconds 正如你上面看到的那样，在使用 McFly 之前我们需要再做一些配置。 将下面几行添加到你的 ~/.bashrc 文件中： if [ -f $(brew --prefix)/opt/mcfly/mcfly.bash ]; then . $(brew --prefix)/opt/mcfly/mcfly.bash fi 最后，再运行下面的命令来让更改生效。 $ source ~/.bashrc 当你第一次执行上面的这个命令时，你的 BASH 历史将会被导入 McFly 的数据库。依据你的 bash 历史文件的大小，这个过程将花费一些时间。一旦导入完成，你讲看到下面的提示信息。 McFly: Importing Bash history for the first time. This may take a minute or two...done. 现在你就可以使用 McFly 了。 使用方法要在你的命令历史中执行搜索，只需要键入 mcfly search 再加上命令名的一部分，最后敲击回车键即可。Mcfly 将会基于你刚才键入的搜索查询语句给出命令建议。 $ mcfly search &lt;part-of-the-command&gt; 例如我键入了下面的命令： $ mcfly search mk 下面展示的是我 Ubuntu 机子上的示例输出： 如你所见，我已经使用过 mkdir 这个命令两次。假如你想从这些命令建议中执行其中之一，只需使用上下键来选择它，然后敲击回车键来执行它就可以了。假如你想编辑其中一个命令，则需要先选择它，然后敲 TAB 键将这个命令放置到终端中，最后在运行它之前更改它就行了。要从历史中删除已经选择的命令，按 F2 即可。 或者，输入下面的命令来打开历史搜索，然后输入任意一个命令或者命令的一部分来从你的历史命令中查看它提供的建议。 $ mcfly search 在你输入的同时， McFly 将会展示命令的提示。 下面是一个介绍 McFly 的简短演示视频： 你还可以使用下面的命令来查看帮助： $ mcfly --help 移除 McFly不喜欢 McFly，没问题！可以使用下面的命令来移除它： $ brew uninstall mcfly $ brew untap cantino/mcfly 最后，移除先前添加到 ~/.bashrc 文件中的几行命令。 好了，这些就是所有了，更多精彩内容敬请期待，请保存关注！ 干杯！ via: https://www.ostechnix.com/mcfly-a-replacement-to-ctrlr-bash-history-search-feature/publish: https://linux.cn/article-10414-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"历史命令","slug":"历史命令","permalink":"https://fsslc.github.io/tags/%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4/"},{"name":"McFly","slug":"McFly","permalink":"https://fsslc.github.io/tags/McFly/"}]},{"title":"[翻译] 如何在 Linux 中查看已挂载的文件系统类型","date":"2018-11-04T15:00:34.000Z","path":"2018/11/04/Translate-How-To-Find-The-Mounted-Filesystem-Type-In-Linux/","text":"介绍如何在 Linux 中查看已挂载的文件系统类型。 如你所知，Linux 支持非常多的文件系统，例如 ext4、ext3、ext2、sysfs、securityfs、FAT16、FAT32、NTFS 等等，当前被使用最多的文件系统是 ext4。你曾经疑惑过你的 Linux 系统使用的是什么类型的文件系统吗？没有疑惑过？不用担心！我们将帮助你。本指南将解释如何在类 Unix 的操作系统中查看已挂载的文件系统类型。 在 Linux 中查看已挂载的文件系统类型有很多种方法可以在 Linux 中查看已挂载的文件系统类型，下面我将给出 8 种不同的方法。那现在就让我们开始吧！ 方法 1 – 使用 findmnt 命令这是查出文件系统类型最常使用的方法。 findmnt 命令将列出所有已挂载的文件系统或者搜索出某个文件系统。 findmnt 命令能够在 /etc/fstab 、 /etc/mtab 或 /proc/self/mountinfo 这几个文件中进行搜索。 findmnt 预装在大多数的 Linux 发行版中，因为它是 util-linux 包的一部分。如果 findmnt 命令不可用，你可以安装这个软件包。例如，你可以使用下面的命令在基于 Debian 的系统中安装 util-linux 包： $ sudo apt install util-linux 下面让我们继续看看如何使用 findmnt 来找出已挂载的文件系统。 假如你只敲 findmnt 命令而不带任何的参数或选项，它将像下面展示的那样以树状图形式列举出所有已挂载的文件系统。 $ findmnt 示例输出： 正如你看到的那样， findmnt 展示出了目标挂载点（ TARGET ）、源设备（ SOURCE ）、文件系统类型（ FSTYPE ）以及相关的挂载选项（ OPTIONS ），例如文件系统是否是可读可写或者只读的。以我的系统为例，我的根（ / ）文件系统的类型是 EXT4 。 假如你不想以树状图的形式来展示输出，可以使用 -l 选项来以简单平凡的形式来展示输出： $ findmnt -l 你还可以使用 -t 选项来列举出特定类型的文件系统，例如下面展示的 ext4 文件系统类型： $ findmnt -t ext4 TARGET SOURCE FSTYPE OPTIONS / /dev/sda2 ext4 rw,relatime,commit=360 └─/boot /dev/sda1 ext4 rw,relatime,commit=360,data=ordered findmnt 还可以生成 df 类型的输出，使用命令 $ findmnt --df 或 $ findmnt -D 示例输出： SOURCE FSTYPE SIZE USED AVAIL USE% TARGET dev devtmpfs 3.9G 0 3.9G 0% /dev run tmpfs 3.9G 1.1M 3.9G 0% /run /dev/sda2 ext4 456.3G 342.5G 90.6G 75% / tmpfs tmpfs 3.9G 32.2M 3.8G 1% /dev/shm tmpfs tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup bpf bpf 0 0 0 - /sys/fs/bpf tmpfs tmpfs 3.9G 8.4M 3.9G 0% /tmp /dev/loop0 squashfs 82.1M 82.1M 0 100% /var/lib/snapd/snap/core/4327 /dev/sda1 ext4 92.8M 55.7M 30.1M 60% /boot tmpfs tmpfs 788.8M 32K 788.8M 0% /run/user/1000 gvfsd-fuse fuse.gvfsd-fuse 0 0 0 - /run/user/1000/gvfs 你还可以展示某个特定设备或者挂载点的文件系统类型。 查看某个特定的设备： $ findmnt /dev/sda1 TARGET SOURCE FSTYPE OPTIONS /boot /dev/sda1 ext4 rw,relatime,commit=360,data=ordered 查看某个特定的挂载点： $ findmnt / TARGET SOURCE FSTYPE OPTIONS / /dev/sda2 ext4 rw,relatime,commit=360 你甚至还可以查看某个特定标签的文件系统的类型： $ findmnt LABEL=Storage 更多详情，请参考其 man 手册。 $ man findmnt findmnt 命令已足够完成在 Linux 中查看已挂载文件系统类型的任务，这个命令就是为了这个特定任务而生的。然而，还存在其他方法来查看文件系统的类型，假如你感兴趣的话，请接着往下看。 方法 2 – 使用 blkid 命令blkid 命令被用来查找和打印块设备的属性。它也是 util-linux 包的一部分，所以你不必再安装它。 为了使用 blkid 命令来查看某个文件系统的类型，可以运行： $ blkid /dev/sda1 方法 3 – 使用 df 命令在类 Unix 的操作系统中， df 命令被用来报告文件系统的磁盘空间使用情况。为了查看所有已挂载文件系统的类型，只需要运行： $ df -T 示例输出： 关于 df 命令的更多细节，可以参考下面的指南。 针对新手的 df 命令教程 同样也可以参考其 man 手册： $ man df 方法 4 – 使用 file 命令file 命令可以判读出某个特定文件的类型，即便该文件没有文件后缀名也同样适用。 运行下面的命令来找出某个特定分区的文件系统类型： $ sudo file -sL /dev/sda1 [sudo] password for sk: /dev/sda1: Linux rev 1.0 ext4 filesystem data, UUID=83a1dbbf-1e15-4b45-94fe-134d3872af96 (needs journal recovery) (extents) (large files) (huge files) 查看其 man 手册可以知晓更多细节： $ man file 方法 5 – 使用 fsck 命令fsck 命令被用来检查某个文件系统是否健全或者修复它。你可以像下面那样通过将分区名字作为 fsck 的参数来查看该分区的文件系统类型： $ fsck -N /dev/sda1 fsck from util-linux 2.32 [/usr/bin/fsck.ext4 (1) -- /boot] fsck.ext4 /dev/sda1 如果想知道更多的内容，请查看其 man 手册： $ man fsck 方法 6 – 使用 fstab 命令fstab 是一个包含文件系统静态信息的文件。这个文件通常包含了挂载点、文件系统类型和挂载选项等信息。 要查看某个文件系统的类型，只需要运行： $ cat /etc/fstab 更多详情，请查看其 man 手册： $ man fstab 方法 7 – 使用 lsblk 命令lsblk 命令可以展示设备的信息。 要展示已挂载文件系统的信息，只需运行： $ lsblk -f NAME FSTYPE LABEL UUID MOUNTPOINT loop0 squashfs /var/lib/snapd/snap/core/4327 sda ├─sda1 ext4 83a1dbbf-1e15-4b45-94fe-134d3872af96 /boot ├─sda2 ext4 4d25ddb0-5b20-40b4-ae35-ef96376d6594 / └─sda3 swap 1f8f5e2e-7c17-4f35-97e6-8bce7a4849cb [SWAP] sr0 更多细节，可以参考它的 man 手册： $ man lsblk 方法 8 – 使用 mount 命令mount 被用来在类 Unix 系统中挂载本地或远程的文件系统。 要使用 mount 命令查看文件系统的类型，可以像下面这样做： $ mount | grep &quot;^/dev&quot; /dev/sda2 on / type ext4 (rw,relatime,commit=360) /dev/sda1 on /boot type ext4 (rw,relatime,commit=360,data=ordered) 更多详情，请参考其 man 手册的内容： $ man mount 好了，上面便是今天的全部内容了。现在你知道了 8 种不同的 Linux 命令来查看已挂载的 Linux 文件系统的类型。假如你知道其他的命令来完成同样的任务，请在下面的评论部分让我们知晓，我将确认并相应地升级本教程。 更过精彩内容即将呈现，请保持关注！ via: https://www.ostechnix.com/how-to-find-the-mounted-filesystem-type-in-linux/publish: https://linux.cn/article-10194-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出 [1]:data:image/gif; base64, R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"挂载文件系统","slug":"挂载文件系统","permalink":"https://fsslc.github.io/tags/%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"[翻译] Gifski：一个跨平台的高质量 GIF 编码器","date":"2018-11-02T13:11:44.000Z","path":"2018/11/02/Translate-A-Cross-platform-High-quality-GIF-Encoder/","text":"介绍一个 GIF 制作工具 Gifski 作为一名文字工作者，我需要在我的文章中添加图片。有时为了更容易讲清楚某个概念，我还会添加视频或者 gif 动图，相比于文字，通过视频或者 gif 格式的输出，读者可以更容易地理解我的指导。前些天，我已经写了篇文章来介绍针对 Linux 的功能丰富的强大截屏工具 Flameshot。今天，我将向你展示如何从一段视频或者一些图片来制作高质量的 gif 动图。这个工具就是 Gifski，一个跨平台、开源、基于 Pngquant 的高质量命令行 GIF 编码器。 对于那些好奇 pngquant 是什么的读者，简单来说 pngquant 是一个针对 PNG 图片的无损压缩命令行工具。相信我，pngquant 是我使用过的最好的 PNG 无损压缩工具。它可以将 PNG 图片最高压缩 70% 而不会损失图片的原有质量并保存了所有的阿尔法透明度。经过压缩的图片可以在所有的网络浏览器和系统中使用。而 Gifski 是基于 Pngquant 的，它使用 pngquant 的功能来创建高质量的 GIF 动图。Gifski 能够创建每帧包含上千种颜色的 GIF 动图。Gifski 也需要 ffmpeg 来将视频转换为 PNG 图片。 安装 Gifski首先需要确保你安装了 FFMpeg 和 Pngquant。 FFmpeg 在大多数的 Linux 发行版的默认软件仓库中都可以获取到，所以你可以使用默认的包管理器来安装它。具体的安装过程，请参考下面链接中的指导。 在 Linux 中如何安装 FFmpeg Pngquant 可以从 AUR 中获取到。要在基于 Arch 的系统安装它，使用任意一个 AUR 帮助程序即可，例如下面示例中的 Yay： $ yay -S pngquant 在基于 Debian 的系统中，运行： $ sudo apt install pngquant 假如在你使用的发行版中没有 pngquant，你可以从源码编译并安装它。为此你还需要安装 libpng-dev 包。 $ git clone --recursive https://github.com/kornelski/pngquant.git $ make $ sudo make install 安装完上述依赖后，再安装 Gifski。假如你已经安装了 Rust 编程语言，你可以使用 cargo 来安装它： $ cargo install gifski 另外，你还可以使用 Linuxbrew 包管理器来安装它： $ brew install gifski 假如你不想安装 cargo 或 Linuxbrew，可以从它的 发布页面 下载最新的二进制程序，或者手动从源码编译并安装 gifski 。 使用 Gifski 来创建高质量的 GIF 动图进入你保存 PNG 图片的目录，然后运行下面的命令来从这些图片创建 GIF 动图： $ gifski -o file.gif *.png 上面的 file.gif 为最后输出的 gif 动图。 Gifski 还有其他的特性，例如： 创建特定大小的 GIF 动图 在每秒钟展示特定数目的动图 以特定的质量编码 更快速度的编码 以给定顺序来编码图片，而不是以排序的结果来编码 为了创建特定大小的 GIF 动图，例如宽为 800，高为 400，可以使用下面的命令： $ gifski -o file.gif -W 800 -H 400 *.png 你可以设定 GIF 动图在每秒钟展示多少帧，默认值是 20。为此，可以运行下面的命令： $ gifski -o file.gif --fps 1 *.png 在上面的例子中，我指定每秒钟展示 1 帧。 我们还能够以特定质量（1-100 范围内）来编码。显然，更低的质量将生成更小的文件，更高的质量将生成更大的 GIF 动图文件。 $ gifski -o file.gif --quality 50 *.png 当需要编码大量图片时，Gifski 将会花费更多时间。如果想要编码过程加快到通常速度的 3 倍左右，可以运行： $ gifski -o file.gif --fast *.png 请注意上面的命令产生的 GIF 动图文件将减少 10% 的质量，并且文件大小也会更大。 如果想让图片以某个给定的顺序（而不是通过排序）精确地被编码，可以使用 --nosort 选项。 $ gifski -o file.gif --nosort *.png 假如你不想让 GIF 循环播放，只需要使用 --once 选项即可： $ gifski -o file.gif --once *.png 从视频创建 GIF 动图有时或许你想从一个视频创建 GIF 动图。这也是可以做到的，这时候 FFmpeg 便能提供帮助。首先像下面这样，将视频转换成一系列的 PNG 图片： $ ffmpeg -i video.mp4 frame%04d.png 上面的命令将会从 video.mp4 这个视频文件创建名为 “frame0001.png”、“frame0002.png”、“frame0003.png” 等等形式的图片（其中的 %04d 代表帧数），然后将这些图片保存在当前的工作目录。 转换好图片后，只需要运行下面的命令便可以制作 GIF 动图了： $ gifski -o file.gif *.png 想知晓更多的细节，请参考它的帮助部分： $ gifski -h 下面是使用 Gifski 创建的示例 GIF 动图文件。 正如你看到的那样，GIF 动图的质量看起来是非常好的。 好了，这就是全部内容了。希望这篇指南对你有所帮助。更多精彩内容即将呈现，请保持关注！ 干杯吧！ via: https://www.ostechnix.com/gifski-a-cross-platform-high-quality-gif-encoder/publish: https://linux.cn/article-10186-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Gif","slug":"Gif","permalink":"https://fsslc.github.io/tags/Gif/"},{"name":"Gifski","slug":"Gifski","permalink":"https://fsslc.github.io/tags/Gifski/"}]},{"title":"[翻译] Flameshot：一个简洁但功能丰富的截图工具","date":"2018-11-01T05:19:09.000Z","path":"2018/11/01/Translate-Flameshot-A-Simple-Yet-Powerful-Feature-rich-Screenshot-Tool/","text":"介绍一款截图软件 Flameshot。 截图是我工作的一部分，我先前使用深度截图工具来截图，深度截图是一个简单、轻量级且非常简洁的截图工具。它自带许多功能例如窗口识别、快捷键支持、图片编辑、延时截图、社交分享、智能存储以及图片清晰度调整等功能。今天我碰巧发现了另一个具备多种功能的截图工具，它就是 Flameshot ，一个简单但功能丰富的针对类 Unix 系统的截图工具。它简单易用，可定制并且有选项可以支持上传截图到在线图片分享网站 imgur 上。同时 Flameshot 有一个 CLI 版本，所以你也可以从命令行来进行截图。Flameshot 是一个完全免费且开源的工具。在本教程中，我们将看到如何安装 Flameshot 以及如何使用它来截图。 安装 Flameshot在 Arch Linux 上： Flameshot 可以从 Arch LInux 的 [community] 仓库中获取。确保你已经启用了 community 仓库，然后就可以像下面展示的那样使用 pacman 来安装 Flameshot ： $ sudo pacman -S flameshot 它也可以从 AUR 中获取，所以你还可以使用任意一个 AUR 帮助程序（例如 Yay）来在基于 Arch 的系统中安装它： $ yay -S flameshot-git 在 Fedora 中： $ sudo dnf install flameshot 在 Debian 10+ 和 Ubuntu 18.04+ 中，可以使用 APT 包管理器来安装它： $ sudo apt install flameshot 在 openSUSE 上： $ sudo zypper install flameshot 在其他的 Linux 发行版中，可以从源代码编译并安装它。编译过程中需要 Qt version 5.3 以及 GCC 4.9.2 或者它们的更高版本。 使用可以从菜单或者应用启动器中启动 Flameshot。在 MATE 桌面环境，它通常可以在 “Applications -&gt; Graphics” 下找到。 一旦打开了它，你就可以在系统面板中看到 Flameshot 的托盘图标。 注意： 假如你使用 Gnome 桌面环境，为了能够看到系统托盘图标，你需要安装 TopIcons 扩展。 在 Flameshot 托盘图标上右击，你便会看到几个菜单项，例如打开配置窗口、信息窗口以及退出该应用。 要进行截图，只需要点击托盘图标就可以了。接着你将看到如何使用 Flameshot 的帮助窗口。选择一个截图区域，然后敲回车键便可以截屏了，点击右键便可以看到颜色拾取器，再敲空格键便可以查看屏幕侧边的面板。你可以使用鼠标的滚轮来增加或者减少指针的宽度。 Flameshot 自带一系列非常好的功能，例如： 可以进行手写 可以划直线 可以画长方形或者圆形框 可以进行长方形区域选择 可以画箭头 可以对要点进行标注 可以添加文本 可以对图片或者文字进行模糊处理 可以展示图片的尺寸大小 在编辑图片是可以进行撤销和重做操作 可以将选择的东西复制到剪贴板 可以保存选区 可以离开截屏 可以选择另一个 app 来打开图片 可以上传图片到 imgur 网站 可以将图片固定到桌面上 下面是一个示例的视频： http://www.ostechnix.com/wp-content/uploads/2018/09/Flameshot-demo.mp4 快捷键Frameshot 也支持快捷键。在 Flameshot 的托盘图标上右击并点击 “Information” 窗口便可以看到在 GUI 模式下所有可用的快捷键。下面是在 GUI 模式下可用的快捷键清单： 快捷键 描述 ←、↓、↑、→ 移动选择区域 1px Shift + ←、↓、↑、→ 将选择区域大小更改 1px Esc 退出截图 Ctrl + C 复制到粘贴板 Ctrl + S 将选择区域保存为文件 Ctrl + Z 撤销最近的一次操作 鼠标右键 展示颜色拾取器 鼠标滚轮 改变工具的宽度 边按住 Shift 键并拖动选择区域的其中一个控制点将会对它相反方向的控制点做类似的拖放操作。 命令行选项Flameshot 也支持一系列的命令行选项来延时截图和保存图片到自定义的路径。 要使用 Flameshot GUI 模式，运行： $ flameshot gui 要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行： $ flameshot gui -p ~/myStuff/captures 要延时 2 秒后打开 GUI 模式可以使用： $ flameshot gui -d 2000 要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用： $ flameshot full -p ~/myStuff/captures -d 2000 要截图全屏并保存到自定义的路径和粘贴板中使用： $ flameshot full -c -p ~/myStuff/captures 要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用： $ flameshot screen -r 要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行： $ flameshot screen -n 1 -c 你还需要什么功能呢？Flameshot 拥有几乎截屏的所有功能：添加注释、编辑图片、模糊处理或者对要点做高亮等等功能。我想：在我找到它的最佳替代品之前，我将一直使用 Flameshot 来作为我当前的截图工具。请尝试一下它，你不会失望的。 好了，这就是今天的全部内容了。后续将有更多精彩内容，请保持关注！ Cheers! via: https://www.ostechnix.com/flameshot-a-simple-yet-powerful-feature-rich-screenshot-tool/publish: https://linux.cn/article-10180-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"截图， Flameshot","slug":"截图，-Flameshot","permalink":"https://fsslc.github.io/tags/%E6%88%AA%E5%9B%BE%EF%BC%8C-Flameshot/"}]},{"title":"[翻译] 如何在 Linux 下锁住键盘和鼠标而不锁屏","date":"2018-10-15T15:00:05.000Z","path":"2018/10/15/Translate-How-To-Lock-The-Keyboard-And-Mouse-But-Not-The-Screen-In-Linux/","text":"介绍使用 xtrlock 来锁住键盘和鼠标，同时不锁屏。 我四岁的侄女是个好奇的孩子，她非常喜爱“阿凡达”电影，当阿凡达电影在播放时，她是如此的专注，好似眼睛粘在了屏幕上。但问题是当她观看电影时，她经常会碰到键盘上的某个键或者移动了鼠标，又或者是点击了鼠标的按钮。有时她非常意外地按了键盘上的某个键，从而将电影关闭或者暂停了。所以我就想找个方法来将键盘和鼠标都锁住，但屏幕不会被锁住。幸运的是，我在 Ubuntu 论坛上找到了一个完美的解决方法。假如在你正看着屏幕上的某些重要的事情时，你不想让你的小猫或者小狗在你的键盘上行走，或者让你的孩子在键盘上瞎搞一气，那我建议你试试 xtrlock 这个工具。它很简单但非常实用，你可以锁定屏幕的显示直到用户在键盘上输入自己设定的密码（LCTT 译注：就是用户自己的密码，例如用来打开屏保的那个密码，不需要单独设定）。在这篇简单的教程中，我将为你展示如何在 Linux 下锁住键盘和鼠标，而不锁掉屏幕。这个技巧几乎可以在所有的 Linux 操作系统中生效。 安装 xtrlockxtrlock 软件包在大多数 Linux 操作系统的默认软件仓库中都可以获取到。所以你可以使用你安装的发行版的包管理器来安装它。 在 Arch Linux 及其衍生发行版中，运行下面的命令来安装它： $ sudo pacman -S xtrlock 在 Fedora 上使用： $ sudo dnf install xtrlock 在 RHEL、CentOS 上使用： $ sudo yum install xtrlock 在 SUSE/openSUSE 上使用： $ sudo zypper install xtrlock 在 Debian、Ubuntu、Linux Mint 上使用： $ sudo apt-get install xtrlock 使用 xtrlock 锁住键盘和鼠标但不锁屏安装好 xtrlock 后，你需要根据你的选择来创建一个快捷键，通过这个快捷键来锁住键盘和鼠标。 （LCTT 译注：译者在自己的系统（Arch + Deepin）中发现这里的到下面创建快捷键的部分可以不必做，依然生效。） 在 /usr/local/bin 目录下创建一个名为 lockkbmouse 的新文件： $ sudo vi /usr/local/bin/lockkbmouse 然后将下面的命令添加到这个文件中： #!/bin/bash sleep 1 &amp;&amp; xtrlock 保存并关闭这个文件。 然后使用下面的命令来使得它可以被执行： $ sudo chmod a+x /usr/local/bin/lockkbmouse 接着，我们就需要创建快捷键了。 创建快捷键在 Arch Linux MATE 桌面中 依次点击 “System -&gt; Preferences -&gt; Hardware -&gt; keyboard Shortcuts” 然后点击 “Add” 来创建快捷键。 首先键入你的这个快捷键的名称，然后将下面的命令填入命令框中，最后点击 “Apply” 按钮。 bash -c &quot;sleep 1 &amp;&amp; xtrlock&quot; 为了能够给这个快捷键赋予快捷方式，需要选中它或者双击它然后输入你选定的快捷键组合，例如我使用 Alt+k 这组快捷键。 如果要清除这个快捷键组合，按住 BACKSPACE 键就可以了。完成后，关闭键盘设定窗口。 在 Ubuntu GNOME 桌面中 依次进入 “System Settings -&gt; Devices -&gt; Keyboard”，然后点击 “+” 这个符号。 键入你快捷键的名称并将下面的命令加到命令框里面，然后点击 “Add” 按钮。 bash -c &quot;sleep 1 &amp;&amp; xtrlock&quot; 接下来为这个新建的快捷键赋予快捷方式。我们只需要选择或者双击 “Set shortcut” 这个按钮就可以了。 然后你将看到下面的一屏。 输入你选定的快捷键组合，例如我使用 Alt+k 。 如果要清除这个快捷键组合，则可以按 BACKSPACE 这个键。这样快捷键便设定好了，完成这个后，关闭键盘设定窗口。 从现在起，每当你输入刚才设定的快捷键（在我们的示例中是 ATL+K ），鼠标的指针便会变成一个挂锁的模样。现在，键盘和鼠标便被锁定了，这时你便可以自在地观看你的电影或者做其他你想做的事儿。即便是你的孩子或者宠物碰了键盘上的某些键或者点击了鼠标，这些操作都不会起作用。 因为 xtrlock 已经在工作了。 你看到了那个小的锁按钮了吗？它意味着键盘和鼠标已经被锁定了。即便你移动这个锁按钮，也不会发生任何事情。后台的任务在一直执行，直到你将屏幕解除，然后手动停掉运行中的任务。 将键盘和鼠标解锁要将键盘和鼠标解锁，只需要输入你的密码然后敲击回车键就可以了，在输入的过程中你将看不到密码。只需要输入然后敲回车键就可以了。在你输入了正确的密码后，鼠标和键盘就可以再工作了。假如你输入了一个错误的密码，你将听到警告声。按 ESC 来清除输入的错误密码，然后重新输入正确的密码。要去掉未完全输入完的密码中的一个字符，只需要按 BACKSPACE 或者 DELETE 键就可以了。 要是我被永久地锁住了怎么办？以防你被永久地锁定了屏幕，切换至一个 TTY（例如 CTRL+ALT+F2 ）然后运行： $ sudo killall xtrlock 或者你还可以使用 chvt 命令来在 TTY 和 X 会话之间切换。 例如，如果要切换到 TTY1，则运行： $ sudo chvt 1 要切换回 X 会话，则键入： $ sudo chvt 7 不同的发行版使用了不同的快捷键组合来在不同的 TTY 间切换。请参考你安装的对应发行版的官方网站了解更多详情。 如果想知道更多 xtrlock 的信息，请参考 man 页： $ man xtrlock 那么这就是全部了。希望这个指南可以帮到你。假如你发现这个指南很有用，请花点时间将这个指南共享到你的朋友圈并支持我们（OSTechNix）。 资源： Ubuntu 论坛 via: https://www.ostechnix.com/lock-keyboard-mouse-not-screen-linux/publish: https://linux.cn/article-10119-1.html 作者：SK选题：lujun9972译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"锁键盘鼠标","slug":"锁键盘鼠标","permalink":"https://fsslc.github.io/tags/%E9%94%81%E9%94%AE%E7%9B%98%E9%BC%A0%E6%A0%87/"}]},{"title":"linux 下使用 matlab 的几个小提示","date":"2018-07-31T09:39:30.000Z","path":"2018/07/31/Tips-for-using-matlab-in-linux/","text":"linux 下使用 matlab 的几个小提示 MATLAB LOGO 嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。 在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。 安装大部分都是直接使用桌面版本来安装 matlab 的。所以先说说这种方法。 安装无外乎以下几步： 下载到 iso 镜像：这个不用多说，自己找资源。 挂载或者解压：挂载使用 mount 命令即可。 使用命令行安装：运行目录里面的 install 脚本后就会出来图形界面，接下来的安装过程与 windows 下的安装过程没有什么区别了。 激活：参考资源内的说明文档。 如果需要在没有桌面的 linux 中安装 matlab，则需要编辑压缩包里面的 installer_input.txt 和 activate.ini 这两个文件，具体的安装过程请参考这篇文章。 终端使用 matlab一般启动 MATLAB 使用如下命令： matlab -nodesktop -nodisplay 跟启动相关的命令主要有如下几个： -nodesktop: 启动 jvm (Jave Virtual Machine)，不启动 desktop， 但 help 界面，preferences 界面等仍可通过 cmdline 调出，即 jvm 启动但不启动 desktop，可以启动其他显示； 但是 matlab 不会在 cmd history 记录本次执行的命令。 -nodisplay: 启动 jvm，不启动 desktop，不启动任何显示相关，忽略任何 DISPLAY 环境变量； 即 jvm 启动但不能显示。 -nojvm: 不启动 jvm，则与之相关的一切活动将无法进行，包括图形界面显示，help 界面，preferences界面等，即 jvm 不启动故不能显示。 -nosplash: 只是不显示启动时的log画面，jvm，desktop等正常启动 如果想在让在终端中实现画图，一般需要做以下两步： 使用 matlab -nodesktop 来启动 matlab； 在脚本中添加 figure(&#39;Visible&#39;,&#39;off&#39;); 这样的句子来抑制画图窗口的弹出。 可以使用 print 来保存图片。例如如下的命令： print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-dpng&#39;); print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-depsc&#39;); 记得要提前使用 mkdir 创建好在上级目录，图片名称的次级目录如果不存在，matlab 会自动创建。 matlab 使用 gpumatlab 里面对 gpu 的使用做了封装，如果需要使用 NVIDIA 的 gpu ， 一般需要安装 Bumblebee， 然后使用 optirun 来运行。具体可以参考如下几个链接：1.https://wiki.archlinux.org/index.php/NVIDIA_Optimus2.https://wiki.archlinux.org/index.php/Bumblebee matlab 里面可以通过 opengl info 来查看使用了什么 gpu。 几个常见问题下面的几个问题常常与 matlab 自带的几个动态链接库有关。一般把这些库备份后，将系统中安装的对应包链接到 matlab 里面就可以了。具体的问题见下面的详细解释 帮助系统没有 CSS 渲染效果字体问题常常与 libfreetype.so 这个动态链接库有关。所以解决办法无非以下几步： sudo mv /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6.BAK # 备份 sudo ln -sf /usr/lib64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 # 链接 libGL error for MATLAB解决办法： ln -sf /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /opt/MATLAB/XXXXX(R2014b)/sys/os/glnxa64/libstdc++.so.6 # 或者执行 cd MATLAB_ROOT/sys/os/glnxa64/ sudo mv libstdc++.so.6 libstdc++.so.6.old 无法使用并行工具箱解决办法同上，链接系统的 libstdc++.so.6 这个动态库。 matlab 无法使用系统中文字体参考： https://bbs.archlinux.org/viewtopic.php?id=231299 cd /usr/local/MATLAB/R2017b # Matlab directory cd bin/glnxa64 mkdir exclude mv libfreetype* exclude cd ../../sys/os/glnxa64 mkdir exclude mv libstdc++.so.6* exclude 或者跟上面的解决方法类似，备份文件后做链接。","tags":[{"name":"matlab","slug":"matlab","permalink":"https://fsslc.github.io/tags/matlab/"},{"name":"linux","slug":"linux","permalink":"https://fsslc.github.io/tags/linux/"}]},{"title":"[翻译] 递归：梦中梦","date":"2018-05-06T15:24:21.000Z","path":"2018/05/06/Translate-Recursion--dream-within-a-dream/","text":"“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》 递归是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。 我们来看一下这个经典的递归阶乘： #include &lt;stdio.h&gt; int factorial(int n) { int previous = 0xdeadbeef; if (n == 0 || n == 1) { return 1; } previous = factorial(n-1); return n * previous; } int main(int argc) { int answer = factorial(5); printf(&quot;%d\\n&quot;, answer); } 递归阶乘 - factorial.c 函数调用自身的这个观点在一开始是让人很难理解的。为了让这个过程更形象具体，下图展示的是当调用 factorial(5) 并且达到 n == 1这行代码 时，栈上 端点的情况： 每次调用 factorial 都生成一个新的 栈帧。这些栈帧的创建和 销毁 是使得递归版本的阶乘慢于其相应的迭代版本的原因。在调用返回之前，累积的这些栈帧可能会耗尽栈空间，进而使你的程序崩溃。 而这些担心经常是存在于理论上的。例如，对于每个 factorial 的栈帧占用 16 字节（这可能取决于栈排列以及其它因素）。如果在你的电脑上运行着现代的 x86 的 Linux 内核，一般情况下你拥有 8 GB 的栈空间，因此，factorial 程序中的 n 最多可以达到 512,000 左右。这是一个 巨大无比的结果，它将花费 8,971,833 比特来表示这个结果，因此，栈空间根本就不是什么问题：一个极小的整数 —— 甚至是一个 64 位的整数 —— 在我们的栈空间被耗尽之前就早已经溢出了成千上万次了。 过一会儿我们再去看 CPU 的使用，现在，我们先从比特和字节回退一步，把递归看作一种通用技术。我们的阶乘算法可归结为：将整数 N、N-1、 … 1 推入到一个栈，然后将它们按相反的顺序相乘。实际上我们使用了程序调用栈来实现这一点，这是它的细节：我们在堆上分配一个栈并使用它。虽然调用栈具有特殊的特性，但是它也只是又一种数据结构而已，你可以随意使用。我希望这个示意图可以让你明白这一点。 当你将栈调用视为一种数据结构，有些事情将变得更加清晰明了：将那些整数堆积起来，然后再将它们相乘，这并不是一个好的想法。那是一种有缺陷的实现：就像你拿螺丝刀去钉钉子一样。相对更合理的是使用一个迭代过程去计算阶乘。 但是，螺丝钉太多了，我们只能挑一个。有一个经典的面试题，在迷宫里有一只老鼠，你必须帮助这只老鼠找到一个奶酪。假设老鼠能够在迷宫中向左或者向右转弯。你该怎么去建模来解决这个问题？ 就像现实生活中的很多问题一样，你可以将这个老鼠找奶酪的问题简化为一个图，一个二叉树的每个结点代表在迷宫中的一个位置。然后你可以让老鼠在任何可能的地方都左转，而当它进入一个死胡同时，再回溯回去，再右转。这是一个老鼠行走的 迷宫示例: 每到边缘（线）都让老鼠左转或者右转来到达一个新的位置。如果向哪边转都被拦住，说明相关的边缘不存在。现在，我们来讨论一下！这个过程无论你是调用栈还是其它数据结构，它都离不开一个递归的过程。而使用调用栈是非常容易的： #include &lt;stdio.h&gt; #include &quot;maze.h&quot; int explore(maze_t *node) { int found = 0; if (node == NULL) { return 0; } if (node-&gt;hasCheese){ return 1;// found cheese } found = explore(node-&gt;left) || explore(node-&gt;right); return found; } int main(int argc) { int found = explore(&amp;maze); } 递归迷宫求解 下载 当我们在 maze.c:13 中找到奶酪时，栈的情况如下图所示。你也可以在 GDB 输出 中看到更详细的数据，它是使用 命令 采集的数据。 它展示了递归的良好表现，因为这是一个适合使用递归的问题。而且这并不奇怪：当涉及到算法时，递归是规则，而不是例外。它出现在如下情景中——进行搜索时、进行遍历树和其它数据结构时、进行解析时、需要排序时——它无处不在。正如众所周知的 pi 或者 e，它们在数学中像“神”一样的存在，因为它们是宇宙万物的基础，而递归也和它们一样：只是它存在于计算结构中。 Steven Skienna 的优秀著作 算法设计指南 的精彩之处在于，他通过 “战争故事” 作为手段来诠释工作，以此来展示解决现实世界中的问题背后的算法。这是我所知道的拓展你的算法知识的最佳资源。另一个读物是 McCarthy 的 关于 LISP 实现的的原创论文。递归在语言中既是它的名字也是它的基本原理。这篇论文既可读又有趣，在工作中能看到大师的作品是件让人兴奋的事情。 回到迷宫问题上。虽然它在这里很难离开递归，但是并不意味着必须通过调用栈的方式来实现。你可以使用像 RRLL 这样的字符串去跟踪转向，然后，依据这个字符串去决定老鼠下一步的动作。或者你可以分配一些其它的东西来记录追寻奶酪的整个状态。你仍然是实现了一个递归的过程，只是需要你实现一个自己的数据结构。 那样似乎更复杂一些，因为栈调用更合适。每个栈帧记录的不仅是当前节点，也记录那个节点上的计算状态（在这个案例中，我们是否只让它走左边，或者已经尝试向右）。因此，代码已经变得不重要了。然而，有时候我们因为害怕溢出和期望中的性能而放弃这种优秀的算法。那是很愚蠢的！ 正如我们所见，栈空间是非常大的，在耗尽栈空间之前往往会遇到其它的限制。一方面可以通过检查问题大小来确保它能够被安全地处理。而对 CPU 的担心是由两个广为流传的有问题的示例所导致的：哑阶乘dumb factorial和可怕的无记忆的 O( 2^n ) Fibonacci 递归。它们并不是栈递归算法的正确代表。 事实上栈操作是非常快的。通常，栈对数据的偏移是非常准确的，它在 缓存 中是热数据，并且是由专门的指令来操作它的。同时，使用你自己定义的在堆上分配的数据结构的相关开销是很大的。经常能看到人们写的一些比栈调用递归更复杂、性能更差的实现方法。最后，现代的 CPU 的性能都是 非常好的 ，并且一般 CPU 不会是性能瓶颈所在。在考虑牺牲程序的简单性时要特别注意，就像经常考虑程序的性能及性能的测量那样。 下一篇文章将是探秘栈系列的最后一篇了，我们将了解尾调用、闭包、以及其它相关概念。然后，我们就该深入我们的老朋友—— Linux 内核了。感谢你的阅读！ via: https://manybutfinite.com/post/recursion/publish: https://linux.cn/article-9609-1.html 作者：Gustavo Duarte译者：qhwdw校对：FSSlc 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"递归","slug":"递归","permalink":"https://fsslc.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"[翻译] 10 款 Linux 平台上最好的 LaTeX 编辑器","date":"2018-01-16T14:13:09.000Z","path":"2018/01/16/Translate-10-Best-LaTeX-Editors-For-Linux/","text":"简介：一旦你克服了 LaTeX 的学习曲线，就没有什么比 LaTeX 更棒了。下面介绍的是针对 Linux 和其他平台的最好的 LaTeX 编辑器。 LaTeX 是什么？LaTeX 是一个文档制作系统。与纯文本编辑器不同，在 LaTeX 编辑器中你不能只写纯文本，为了组织文档的内容，你还必须使用一些 LaTeX 命令。 LaTeX 编辑器一般用在出于学术目的的科学研究文档或书籍的出版，最重要的是，当你需要处理包含众多复杂数学符号的文档时，它能够为你带来方便。当然，使用 LaTeX 编辑器是很有趣的，但它也并非总是很有用，除非你对所要编写的文档有一些特别的需求。 为什么你应当使用 LaTeX?好吧，正如我前面所提到的那样，使用 LaTeX 编辑器便意味着你有着特定的需求。为了捣腾 LaTeX 编辑器，并不需要你有一颗极客的头脑。但对于那些使用一般文本编辑器的用户来说，它并不是一个很有效率的解决方法。 假如你正在寻找一款工具来精心制作一篇文档，同时你对花费时间在格式化文本上没有任何兴趣，那么 LaTeX 编辑器或许正是你所寻找的那款工具。在 LaTeX 编辑器中，你只需要指定文档的类型，它便会相应地为你设置好文档的字体种类和大小尺寸。正是基于这个原因，难怪它会被认为是 给作家的最好开源工具 之一。 但请务必注意： LaTeX 编辑器并不是自动化的工具，你必须首先学会一些 LaTeX 命令来让它能够精确地处理文本的格式。 针对 Linux 平台的 10 款最好 LaTeX 编辑器事先说明一下，以下列表并没有一个明确的先后顺序，序号为 3 的编辑器并不一定比序号为 7 的编辑器优秀。 1、 LyX LyX 是一个开源的 LaTeX 编辑器，即是说它是网络上可获取到的最好的文档处理引擎之一。LyX 帮助你集中于你的文章，并忘记对单词的格式化，而这些正是每个 LaTeX 编辑器应当做的。LyX 能够让你根据文档的不同，管理不同的文档内容。一旦安装了它，你就可以控制文档中的很多东西了，例如页边距、页眉、页脚、空白、缩进、表格等等。 假如你正忙着精心撰写科学类文档、研究论文或类似的文档，你将会很高兴能够体验到 LyX 的公式编辑器，这也是其特色之一。 LyX 还包括一系列的教程来入门，使得入门没有那么多的麻烦。 2、 Texmaker Texmaker 被认为是 GNOME 桌面环境下最好的 LaTeX 编辑器之一。它呈现出一个非常好的用户界面，带来了极好的用户体验。它也被称之为最实用的 LaTeX 编辑器之一。假如你经常进行 PDF 的转换，你将发现 TeXmaker 相比其他编辑器更加快速。在你书写的同时，你也可以预览你的文档最终将是什么样子的。同时，你也可以观察到可以很容易地找到所需要的符号。 Texmaker 也提供一个扩展的快捷键支持。你有什么理由不试着使用它呢？ 3、 TeXstudio 假如你想要一个这样的 LaTeX 编辑器：它既能为你提供相当不错的自定义功能，又带有一个易用的界面，那么 TeXstudio 便是一个完美的选择。它的 UI 确实很简单，但是不粗糙。 TeXstudio 带有语法高亮，自带一个集成的阅读器，可以让你检查参考文献，同时还带有一些其他的辅助工具。 它同时还支持某些酷炫的功能，例如自动补全，链接覆盖，书签，多游标等等，这使得书写 LaTeX 文档变得比以前更加简单。 TeXstudio 的维护很活跃，对于新手或者高级写作者来说，这使得它成为一个引人注目的选择。 4、 Gummi Gummi 是一个非常简单的 LaTeX 编辑器，它基于 GTK+ 工具箱。当然，在这个编辑器中你找不到许多华丽的选项，但如果你只想能够立刻着手写作， 那么 Gummi 便是我们给你的推荐。它支持将文档输出为 PDF 格式，支持语法高亮，并帮助你进行某些基础的错误检查。尽管在 GitHub 上它已经不再被活跃地维护，但它仍然工作地很好。 5、 TeXpen TeXpen 是另一个简洁的 LaTeX 编辑器。它为你提供了自动补全功能。但其用户界面或许不会让你感到印象深刻。假如你对用户界面不在意，又想要一个超级容易的 LaTeX 编辑器，那么 TeXpen 将满足你的需求。同时 TeXpen 还能为你校正或提高在文档中使用的英语语法和表达式。 6、 ShareLaTeX ShareLaTeX 是一款在线 LaTeX 编辑器。假如你想与某人或某组朋友一同协作进行文档的书写，那么这便是你所需要的。 它提供一个免费方案和几种付费方案。甚至来自哈佛大学和牛津大学的学生也都使用它来进行个人的项目。其免费方案还允许你添加一位协作者。 其付费方案允许你与 GitHub 和 Dropbox 进行同步，并且能够记录完整的文档修改历史。你可以为你的每个方案选择多个协作者。对于学生，它还提供单独的计费方案。 7、 Overleaf Overleaf 是另一款在线的 LaTeX 编辑器。它与 ShareLaTeX 类似，它为专家和学生提供了不同的计费方案。它也提供了一个免费方案，使用它你可以与 GitHub 同步，检查你的修订历史，或添加多个合作者。 在每个项目中，它对文件的数目有所限制。所以在大多数情况下如果你对 LaTeX 文件非常熟悉，这并不会为你带来不便。 8、 Authorea Authorea 是一个美妙的在线 LaTeX 编辑器。当然，如果考虑到价格，它可能不是最好的一款。对于免费方案，它有 100 MB 的数据上传限制和每次只能创建一个私有文档。而付费方案则提供更多的额外好处，但如果考虑到价格，它可能不是最便宜的。你应该选择 Authorea 的唯一原因应该是因为其用户界面。假如你喜爱使用一款提供令人印象深刻的用户界面的工具，那就不要错过它。 9、 Papeeria Papeeria 是在网络上你能够找到的最为便宜的 LaTeX 在线编辑器，如果考虑到它和其他的编辑器一样可信赖的话。假如你想免费地使用它，则你不能使用它开展私有项目。但是，如果你更偏爱公共项目，它允许你创建不限数目的项目，添加不限数目的协作者。它的特色功能是有一个非常简便的画图构造器，并且在无需额外费用的情况下使用 Git 同步。假如你偏爱付费方案，它赋予你创建 10 个私有项目的能力。 10、 Kile 位于我们最好 LaTeX 编辑器清单的最后一位是 Kile 编辑器。有些朋友对 Kile 推崇备至，很大程度上是因为其提供某些特色功能。 Kile 不仅仅是一款编辑器，它还是一款类似 Eclipse 的 IDE 工具，提供了针对文档和项目的一整套环境。除了快速编译和预览功能，你还可以使用诸如命令的自动补全 、插入引用，按照章节来组织文档等功能。你真的应该使用 Kile 来见识其潜力。 Kile 在 Linux 和 Windows 平台下都可获取到。 总结所以上面便是我们推荐的 LaTeX 编辑器，你可以在 Ubuntu 或其他 Linux 发行版本中使用它们。 当然，我们可能还遗漏了某些可以在 Linux 上使用并且有趣的 LaTeX 编辑器。如若你正好知道它们，请在下面的评论中让我们知晓。 via: https://itsfoss.com/LaTeX-editors-linux/publish: https://linux.cn/article-9247-1.html 作者：Ankush Das译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://fsslc.github.io/tags/LaTeX/"}]},{"title":"[翻译] LaTeXila 简介：Linux 上的一个多语言 LaTeX 编辑器","date":"2017-03-28T09:05:49.000Z","path":"2017/03/28/Translate-Introduction-to-LaTeXila-a-multi-language-LaTeX-editor-for-Linux/","text":"介绍 LaTeXila 这个 LaTeX 编辑器。 LaTeXila 是一个多语言 LaTeX 编辑器，专为那些偏爱 GTK+ 外观的 Linux 用户设计。这个软件简单，但又足够强大，可定制性良好，所以如果你对 LaTeX 感兴趣，那么你就应该尝试一下这个工具。 在下面的快速指南中，我将展示如何使用 LaTeXila 并介绍其主要功能。但在开始之前你可能要问： 为何选择使用 LaTeX?假如我想创建一个文本文档，为什么我不使用 LibreOffice 或者 Abiword 这些常规的工具呢？原因是相比于常规的文本编辑器，LaTeX 编辑器一般来说都会提供更多功能强大的格式化工具，让你在写作期间专注于文档的内容。LaTeX 是一个文档准备系统，目的是简化大多数常见出版物的处理过程，例如书籍或者科学报告，它们通常都包含很多数学公式，多语言排版元素，交叉引用及引文，参考文献等等需要处理的元素。尽管上面的那些元素也可以用 LibreOffice 来处理，使用 LaTeXila 要相对简单一些，同时处理得当的话你最后得到的会是一份高质量的文档。 在一个新文档上开始工作并设定文章结构首先，我们需要在 LaTeXila 中创建一个新文件，这个可以通过点击位于左上角的 “新建文件” 图标来实现，接着它将打开一个对话框，让我们选择一个模板从而快速地开始写作。 打开 LaTex 编辑器 在这里假设我将写一本书，所以我选择一个书籍模板，像下面的截图那样在相应的括号中添上标题和作者： 打开书籍模板 现在就让我来解释一些关于文章结构的事情。我知道这看起来就像编代码，如果你是一位作家而非程序员，那么像下面那样工作或许很是奇怪，但请先容我讲完，我将对此进行解释。 在第一行和第九行之间，我们已经写好了书写整个文档所需的所有基本要素。例如在第一行中，我们可以通过修改 [a4paper,11pt] 来定义纸张和字体的大小，在这个方括号中，我们可以添加更多的选项，选项之间以英文逗号来分隔。 在第二行和第四行之间，我们可以看到一些条目，它们都以 \\userpackage 打头，紧接着的是用方括号包裹的选项和用括号包裹的命令。这些命令都是一些增强宏包，LaTeXila 默认已经安装它们到我们的系统上了，并且在大多数模板中都将使用它们。需要特别注意的是字体编码，字符编码和字体的类型。 紧接着让我们看看 \\maketitle 这一行，这里我们可以添加一个单独的标题页，且默认情况下标题的内容将被放置在第一页的顶部。类似的，包含 \\tableofcontents 的那行将会自动生成书籍的目录。 最后，我们可以自己命名章节的名称，这可以通过在 \\chapter 后的括号中添加章节名称来实现。第一个章节将会被自动地标记为第一章。你可以在接下来的行中添加内容，一直到下一个以 \\chapter 开头的新行为止，这些都将是这个章节的内容。新的章节将会被自动地标记为第二章，以此类推。 LaTex 的格式 章节之间还可以用命令 \\section 来划分为更小的块，甚至还可以使用 \\subsection 来划分为更小的部分。各个小节和章都将被 \\tableofcontents 自动检测到，并将使用它们的标题和页码来填充目录的内容。看看下面的截图就可以看到章和小节是如何在你的书中被排版的。 LaTex 预览 假如你想浏览结构，你可以将左边的工具栏更换到“结构”Structure选项，并确保所有的结构与预期相符。在这里，你还可以控制各小节中的任意数据表格和图片。 LaTex 结构 讲到这里，有人或许想将表格和图片的位置也包含在目录中。要达到此目的，你需要将下面的两行添加到 \\tableofcontents 之后： \\listoffigures \\listoftables 最后标志着书籍结束的信号是 \\end{document}。你的布局应该总是以此为结尾。 LaTeXila 简单易用，公式齐全LaTeX 是一个基于命令的文档生成系统，它与使用的编辑器没有多少关联。这里需要强调的是 LaTeXila 提供了一系列强大的工具，使得在你书写报告或书籍时能够节省一些时间和精力。例如对于 LaTex 命令，它提供了自动补全功能，这个功能将在你每次开始输入命令时被激活。 LaTeX 中的数学公式 LaTeXila 还集成有基于 gspell 的拼写检测系统，你可以在最上面的“工具”菜单中设定合适的语言。最上面的工具栏里几乎包含了你要用到的所有按钮。从左到右，你可以完成添加章节，交叉引用，调整字符的大小，格式化被选取的部分，添加无序列表和数学函数等等。这些都可以手动地输入，但通过点击相应按钮来完成或许更加方便。 对于生成数学公式，结合侧边栏上的工具栏选项，你只需轻轻一点就可以添加相应的数学符号。点击位于左边的侧边栏中“符号”Symbols框，你就可以看到相关的符号分类，例如“关系运算符”，“希腊字母”，“运算符”等等。下面的截图就是一些符号的示例： 希腊字母和算子符号 这些符号的图形化列表使得公式和数学表达式的生成犹如在公园中散步那样舒适。 将 .tex 文件转换为 .rtf 文件默认情况下，LaTeXila 会将你的文档保存为标准的 .tex 文档，而我们可以使用 .tex 文档来生成一个“富文本”rich text format文档，这些富文本文档可以使用像 LibreOffice 那样的文本编辑器打开。要达到此目的，我们需要安装一个名为 latex2rtf 的工具，它在所有的 Linux 发行版本中都可以被获取到。在文本所在的目录打开虚拟终端， 并输入 latex2rtf 文件名称，如下所示 ： 由 LaTeX 文档生成 RTF 文档 当然 LaTeXila 也提供了它自己的构建工具，这些工具可以在上面的工具栏或者最上面的面板（构建）中看到。但我向你推荐 latex2rtf 是以防它们在其他的操作系统上出现某些意想不到的问题，比如在我的系统上就不能正常工作。 结论假如上面的介绍激发了你探索 LaTeX 的兴趣，那就再好不过了。我写这篇文章的目的是向新手介绍一款简单易用且适合他们写作的工具。要是 LaTeXila 还带有实时预览的双屏模式的话，它就更加完美了… via: https://www.howtoforge.com/tutorial/introduction-to-latexila-latex-editor/ 作者：Bill Toulas译者：FSSlc校对：jasminepeng 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://fsslc.github.io/tags/LaTeX/"}]},{"title":"减小 VBoX 虚拟磁盘大小","date":"2016-12-18T08:28:48.000Z","path":"2016/12/18/Decrease-VBoX-image/","text":"如何使用 VBOX 自带工具减小虚拟磁盘大小 缘由由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ, WPS, MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。 虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。 WPS 终于出了 Linux 版本了，还算良心，就 鹅厂 还一直没有什么进展。。 问题来了，便开始上网搜索方法。在开源中国的一个博客里面找到了方法，下面进行简单的记录。 解决方法根据博主的文章，要达到减小 VBox 虚拟磁盘的大小，主要有两个步骤： 碎片整理首先需要在虚拟机里面的系统下做碎片整理。 对于 Linux 系统，可以使用： sudo dd if=/dev/zero of=/EMPTY bs=1M sudo rm -f /EMPTY 对于 Windows 系统，则需要使用 Sysinternals Suite，点击上面的链接可以到微软的页面下进行下载。下载解压后，通过 CMD ，运行： sdelete -z c: 等待进度完成即可。然后关闭虚拟机。 压缩磁盘如果虚拟磁盘是 Virtual Box 自家的 VDI 格式，则只需要先通过终端到达含有后缀为 .vdi 的文件所在的那个目录，再执行： VBoxManage modifyhd win7.vdi --compact 这样就可以达到压缩磁盘的目的。 如果虚拟磁盘是 VMDK 的格式，则可以使用 vmware 自带的 vmware-vdiskmanager 工具，具体命令如下： vmware-vdiskmanager -k disk.vmdk 参考资料 如何减小VirtualBox虚拟硬盘文件的大小","tags":[{"name":"VBox","slug":"VBox","permalink":"https://fsslc.github.io/tags/VBox/"}]},{"title":"在 Archlinux 中安装 OpenDX","date":"2016-12-15T08:02:31.000Z","path":"2016/12/15/Install-opendx-In-Archlinux/","text":"在 Archlinux 中安装 OpenDX 前面 我说过， OpenDX 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 sudo apt install dx dxsamples 安装这个可视化软件。 现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。 UPDATE现在下面那个久未更新的镜像网站已经不存在了，而我也没有保存那个安装包，所以只好自己想办法了。还好 Debian 还在维护这两个包，所以我就借鉴它的编译脚本来写成适合 Archlinux 编译的脚本。目前通过我自己编写的编译脚本编译这两个软件包基本可以使用，但还是有点小问题： Debian 维护者里面的那个仓库中，包含很多与 Debian 系统相关的补丁，我只清理了一点，有些可能没有清理干净； 有时会占用 100% 的 CPU，到时直接杀掉那个进程即可(PS: htop这个工具非常好用，推荐大家使用 ^_^ )； 在 dx 的窗口中仍然不能直接达到 samples 目录。 自己编译又不想安装那么多的依赖，最后在国内某个久未更新的镜像网站 中找到了别人打包好的二进制文件，下载那个名为 OpenDX-4.4.4-2.pkg.tar.gz 的安装包后，可以直接使用命令 sudo pacman -U OpenDX-4.4.4-2.pkg.tar.gz 进行安装。 现在这个镜像网站好像不能访问了 %&gt;_&lt;%&gt; 这样安装后，可能会有些依赖问题，例如我的系统里面会报 netcdf 和 tiff 的动态链接库找不到，而我已经安装了它们，所以只需要创建一些软链接就可以了。 sudo ln -s /usr/lib/libnetcdf.so.12.0.0 /usr/lib/libnetcdf.so.4 sudo ln -s /usr/lib/libtiff.so.5.2.4 /usr/lib/libtiff.so.3 最后附上我改写的编译脚本和相关的源文件： 链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxt 如果只需要编译这两个包，只需要下载 OpenDX_AUR_build_scripts.zip 这个压缩包就行了。另外的东西是用来编译 AFEPack 的。","tags":[{"name":"OpenDX","slug":"OpenDX","permalink":"https://fsslc.github.io/tags/OpenDX/"},{"name":"Archlinux","slug":"Archlinux","permalink":"https://fsslc.github.io/tags/Archlinux/"}]},{"title":"使用 docker 构建 AFEPack 镜像","date":"2016-12-15T07:24:09.000Z","path":"2016/12/15/Build-AFEPack-docker-image/","text":"使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦 先前写了一篇如何在 Ubuntu 安装 AFEPack 的教程，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在这里。先前也知道 docker 掀起的热潮，但一直没有学习它。 关于 docker 的学习，网上一搜一大堆。我自己买了本 杨保华、戴王剑、曹亚仑 编著的《Docker 技术入门与实践》，利用一个下午学会了基本操作，后面的有些功能自己用不到就没有再深究下去。闲话少说，下面进入正题。 安装 docker首先，要构建 docker 镜像，你需要安装 docker，具体安装过程见官网或者 Google 、Baidu 一下。 编写 Dockerfile要想实现自动构建 Docker 镜像，就需要编写 Dockerfile。只要知道 Dockerfile 编写时需要用的一些指令和编译安装的命令就可以了。 下面是我最后写好的 Dockerfile 。我在下面用中文添加注释，原文件参考我 GitHub 上的项目AFEPackDocker。 FROM ubuntu:16.04 # 以 ubuntu 16.04 作为镜像的基础系统 MAINTAINER FSSlc, liuchang011235 AT gmail DOT com # 维护者的相关信息 # install essential packages RUN \\ # RUN 后面跟上要运行的命令即可 mkdir -p /root/Pkg &amp;&amp; \\ # use aliyun&#39;s mirror for better download speed sed -i &#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&#39; /etc/apt/sources.list &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get install -y make automake autoconf wget build-essential \\ libdeal.ii-dev mpi-default-dev nano # libhypre-dev trilinos-all-dev petsc-dev --no-install-recommends ## set some env varibles # 设置与 AFEPack 相关的环境变量 COPY env.txt /root/Pkg/env.txt ## prepare AFEPack easymesh RUN \\ cd /root/Pkg &amp;&amp; \\ wget http://dsec.pku.edu.cn/~rli/AFEPack-snapshot.tar.gz &amp;&amp; \\ wget http://dsec.pku.edu.cn/~rli/source_code/easymesh.c.gz &amp;&amp; \\ tar -xzf ./AFEPack-snapshot.tar.gz -C /root/Pkg/ &amp;&amp; \\ gunzip easymesh.c.gz &amp;&amp; \\ ## compile and install AFEPack cat /root/Pkg/env.txt &gt;&gt; /root/.bashrc &amp;&amp; . /root/.bashrc &amp;&amp; \\ cd /root/Pkg/AFEPack &amp;&amp; \\ # 将 ubuntu 中安装的 deal.ii 库文件改名 ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.g.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.g.so &amp;&amp; \\ ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.so &amp;&amp; \\ aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; \\ env EXTRA_INCDIR=&quot;-I/usr/include/deal.II/&quot; EXTRA_LIBDIR=&quot;-L/usr/lib/x86_64-linux-gnu/&quot; ./configure &amp;&amp; \\ # make -j8 &amp;&amp; make install # 下面分开编译 AFEPack，直接编译会报错，镜像就编译不下去了 cd ./template/ &amp;&amp; make -j8 &amp;&amp; cd ../library/ &amp;&amp; make -j8 &amp;&amp; make install &amp;&amp; \\ cd ../example/ &amp;&amp; make -j8 &amp;&amp; \\ ## compile and install easymesh cd /root/Pkg/ &amp;&amp; \\ gcc -o easymesh easymesh.c -lm &amp;&amp; \\ mv ./easymesh /usr/local/bin/ &amp;&amp; \\ ## do some clean work # 清理一些不需要的文件，减小镜像大小 rm easymesh.c AFEPack-snapshot.tar.gz env.txt &amp;&amp; \\ rm -rf /var/lib/apt/lists/* CMD [&quot;/bin/bash&quot;] UPDATE为了能够本地编译安装 AFEPack 的镜像，我编写了两个 Dockerfile，一个是直接使用Ubuntu 16.04 里面 8.1 版本的 deal.II，另一个是在 Ubuntu 14.04 里使用源码编译的 deal.II 6.3.1，请自行选择。 UPDATE 20181103好久没有更新了，最近在做 docker 相关的事。了解到 docker 可以进行所谓的多阶段构建了。这个功能可以进一步地减小镜像的大小，所以我今天就尝试了一下，效果还是很明显的。从原来的 1.07GB 减少到现在的 573MB。 另外 AFEPack 的包做了一些更新，居然默认 std=c++14 了！所以原来的 Dockerfile 可能不能使用了，所以我顺便做了更新。从构建的结果看，step-7 这个例子跑不通，这次更新后的 Dockerfile 都有这个问题，它们获取的AFEPack 源码都是今天我从官网下载的。但是我放在 docker Hub 的镜像可以运行。。。 使用 docker build 命令构建镜像编写完 Dockerfile 后，便可以构建镜像了。使用的命令是： sudo docker build -t afepack:v0 . 其中 -t 选项是指定编译后镜像的名称，即所谓的 tag 。 具体使用时，一般运行： docker run -ti -v $HOME/Pkg:/opt afepack:v0 bash 上面的命令将启动一个容器，其中的 -v 选项将把主机中的 $HOME/Pkg 目录挂载到容器中的 /opt 目录，这样我们便可以在 $HOME/Pkg 中让主机和容器之间进行数据交互。","tags":[{"name":"AFEPack","slug":"AFEPack","permalink":"https://fsslc.github.io/tags/AFEPack/"},{"name":"Docker","slug":"Docker","permalink":"https://fsslc.github.io/tags/Docker/"}]},{"title":"[翻译] bc : 一个命令行计算器","date":"2016-08-06T10:22:03.000Z","path":"2016/08/06/Translate-bc-Command-line-calculator/","text":"介绍命令行计算器 bc 。 假如你在一个图形桌面环境中需要一个计算器时，你可能只需要一路进行点击便可以找到一个计算器。例如，Fedora 工作站中就已经包含了一个名为 Calculator 的工具。它有着几种不同的操作模式，例如，你可以进行复杂的数学运算或者金融运算。但是，你知道吗，命令行也提供了一个与之相似的名为 bc 的工具？ bc 工具可以为你提供的功能可以满足你对科学计算器、金融计算器或者是简单计算器的期望。另外，假如需要的话，它还可以从命令行中被脚本化。这使得当你需要做复杂的数学运算时，你可以在 shell 脚本中使用它。 因为 bc 也被用于其他的系统软件，例如 CUPS 打印服务，所以它可能已经在你的 Fedora 系统中被安装了。你可以使用下面这个命令来进行检查： dnf list installed bc 假如因为某些原因你没有在上面命令的输出中看到它，你可以使用下面的这个命令来安装它： sudo dnf install bc 用 bc 做一些简单的数学运算使用 bc 的一种方式是进入它自己的 shell。在那里你可以按行进行许多次计算。当你键入 bc 后，首先出现的是有关这个程序的警告： $ bc bc 1.06.95 Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc. This is free software with ABSOLUTELY NO WARRANTY. For details type `warranty&#39;. 现在你可以按照每行一个输入运算式或者命令了： 1+1 bc 会回答上面计算式的答案是： 2 在这里你还可以执行其他的命令。你可以使用 加（+）、减（-）、乘（*）、除（/）、圆括号、指数符号（\\^） 等等。请注意 bc 同样也遵循所有约定俗成的运算规则，例如运算的先后顺序。你可以试试下面的例子： (4+7)*2 4+7*2 若要退出 bc 可以通过按键组合 Ctrl+D 来发送 “输入结束”信号给 bc 。 使用 bc 的另一种方式是使用 echo 命令来传递运算式或命令。下面这个示例就是计算器中的 “Hello, world” 例子，使用 shell 的管道函数（|） 来将 echo 的输出传入 bc 中： echo &#39;1+1&#39; | bc 使用 shell 的管道，你可以发送不止一个运算操作，你需要使用分号来分隔不同的运算。结果将在不同的行中返回。 echo &#39;1+1; 2+2&#39; | bc 精度在某些计算中，bc 会使用精度的概念，即小数点后面的数字位数。默认的精度是 0。除法操作总是使用精度的设定。所以，如果你没有设置精度，有可能会带来意想不到的答案： echo &#39;3/2&#39; | bc echo &#39;scale=3; 3/2&#39; | bc 乘法使用一个更复杂的精度选择机制： echo &#39;3*2&#39; | bc echo &#39;3*2.0&#39; | bc 同时，加法和减法的相关运算则与之相似： echo &#39;7-4.15&#39; | bc 其他进制系统bc 的另一个有用的功能是可以使用除了十进制以外的其他计数系统。例如，你可以轻松地做十六进制或二进制的数学运算。可以使用 ibase 和 obase 命令来分别设定输入和输出的进制系统。需要记住的是一旦你使用了 ibase ，之后你输入的任何数字都将被认为是在新定义的进制系统中。 要做十六进制数到十进制数的转换或运算，你可以使用类似下面的命令。请注意大于 9 的十六进制数必须是大写的（A-F）： echo &#39;ibase=16; A42F&#39; | bc echo &#39;ibase=16; 5F72+C39B&#39; | bc 若要使得结果是十六进制数，则需要设定 obase ： echo &#39;obase=16; ibase=16; 5F72+C39B&#39; | bc 下面是一个小技巧。假如你在 shell 中做这些十六进制运算，怎样才能使得输入重新为十进制数呢？答案是使用 ibase 命令，但你必须设定它为在当前进制中与十进制中的 10 等价的值。例如，假如 ibase 被设定为十六进制，你需要输入： ibase=A 一旦你执行了上面的命令，所有输入的数字都将是十进制的了，接着你便可以输入 obase=10 来重置输出的进制系统。 结论上面所提到的只是 bc 所能做到的基础。它还允许你为某些复杂的运算和程序定义函数、变量和循环结构。你可以在你的系统中将这些程序保存为文本文件以便你在需要的时候使用。你还可以在网上找到更多的资源，它们提供了更多的例子以及额外的函数库。快乐地计算吧！ via: https://fedoramagazine.org/bc-command-line-calculator/publish: https://linux.cn/article-7653-1.html 作者：Paul W. Frields译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"bc","slug":"bc","permalink":"https://fsslc.github.io/tags/bc/"}]},{"title":"[翻译] awk 系列：如何使用 awk 按模式筛选文本或字符串","date":"2016-07-21T00:02:28.000Z","path":"2016/07/21/Translate-Part-3-How-to-Use-Awk-to-Filter-Text-or-Strings-Using-Pattern-Specific-Actions/","text":"介绍使用 awk 根据模式筛选文本或字符串 作为 awk 命令系列的第三部分，这次我们将看一看如何基于用户定义的特定模式来筛选文本或字符串。 在筛选文本时，有时你可能想根据某个给定的条件或使用一个可被匹配的特定模式，去标记某个文件或数行字符串中的某几行。使用 awk 来完成这个任务是非常容易的，这也正是 awk 中可能对你有所帮助的几个功能之一。 让我们看一看下面这个例子，比方说你有一个写有你想要购买的食物的购物清单，其名称为 food_prices.list，它所含有的食物名称及相应的价格如下所示： $ cat food_prices.list No Item_Name Quantity Price 1 Mangoes 10 $2.45 2 Apples 20 $1.50 3 Bananas 5 $0.90 4 Pineapples 10 $3.46 5 Oranges 10 $0.78 6 Tomatoes 5 $0.55 7 Onions 5 $0.45 然后，你想使用一个 (*) 符号去标记那些单价大于 $2 的食物，那么你可以通过运行下面的命令来达到此目的： $ awk &#39;/ *\\$[2-9]\\.[0-9][0-9] */ { print $1, $2, $3, $4, &quot;*&quot; ; } / *\\$[0-1]\\.[0-9][0-9] */ { print ; }&#39; food_prices.list 打印出单价大于 $2 的项目 从上面的输出你可以看到在含有 芒果（mangoes） 和菠萝（pineapples）的那行末尾都已经有了一个 (*) 标记。假如你检查它们的单价，你可以看到它们的单价的确超过了 $2 。 在这个例子中，我们已经使用了两个模式： 第一个模式: / *\\$[2-9]\\.[0-9][0-9] */ 将会得到那些含有食物单价大于 $2 的行， 第二个模式: /*\\$[0-1]\\.[0-9][0-9] */ 将查找那些食物单价小于 $2 的那些行。 上面的命令具体做了什么呢？这个文件有四个字段，当模式一匹配到含有食物单价大于 $2 的行时，它便会输出所有的四个字段并在该行末尾加上一个 (*) 符号来作为标记。 第二个模式只是简单地输出其他含有食物单价小于 $2 的行，按照它们出现在输入文件 food_prices.list 中的样子。 这样你就可以使用模式来筛选出那些价格超过 $2 的食物项目，尽管上面的输出还有些问题，带有 (*) 符号的那些行并没有像其他行那样被格式化输出，这使得输出显得不够清晰。 我们在 awk 系列的第二部分中也看到了同样的问题，但我们可以使用下面的两种方式来解决： 1、可以像下面这样使用 printf 命令，但这样使用又长又无聊： $ awk &#39;/ *\\$[2-9]\\.[0-9][0-9] */ { printf &quot;%-10s %-10s %-10s %-10s\\n&quot;, $1, $2, $3, $4 &quot;*&quot; ; } / *\\$[0-1]\\.[0-9][0-9] */ { printf &quot;%-10s %-10s %-10s %-10s\\n&quot;, $1, $2, $3, $4; }&#39; food_prices.list 使用 Awk 和 Printf 来筛选和输出项目 2、 使用 $0 字段。Awk 使用变量 0 来存储整个输入行。对于上面的问题，这种方式非常方便，并且它还简单、快速： $ awk &#39;/ *\\$[2-9]\\.[0-9][0-9] */ { print $0 &quot;*&quot; ; } / *\\$[0-1]\\.[0-9][0-9] */ { print ; }&#39; food_prices.list 使用 Awk 和变量来筛选和输出项目 结论这就是全部内容了，使用 awk 命令你便可以通过几种简单的方法去利用模式匹配来筛选文本，帮助你在一个文件中对文本或字符串的某些行做标记。 希望这篇文章对你有所帮助。记得阅读这个系列的下一部分，我们将关注在 awk 工具中使用比较运算符。 via: http://www.tecmint.com/awk-filter-text-or-string-using-patterns/publish: https://linux.cn/article-7599-1.html 作者：Aaron Kili译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Awk","slug":"Awk","permalink":"https://fsslc.github.io/tags/Awk/"}]},{"title":"[翻译] 《道德经》之项目管理","date":"2016-05-24T07:58:06.000Z","path":"2016/05/24/Translate-The-Tao-of-project-management/","text":"道德经，被认为是由圣人老子于公元前六世纪时所编写，是现存最为广泛翻译的经文之一。从宗教到关于约会的有趣电影等方方面面，它都深深地影响着它们，作者们借用它来做隐喻，以解释各种各样的事情（甚至是编程）。 在思考有关开放性组织的项目管理时，我的脑海中便立马浮现出上面的这段文字。 这听起来可能会有点奇怪。若要理解我的这种想法从何而来，你应该读读 《开放性组织：点燃激情提升执行力》 这本书，它是红帽公司总裁、首席执行官 Jim Whitehurst 所写的一本有关企业文化和新领导力范式的宣言。在这本书中，Jim（还有来自其他红帽人的一点帮助）解释了传统组织机构（一种 “自上而下” 的方式，来自高层的决策被传达到员工，而员工通过晋升和薪酬来激励）和开放性组织机构（一种 自下而上 的方式，领导专注于激励和鼓励，员工被充分授权以各尽其能）之间的差异。 在开放性组织中的员工都是被激情、目标和参与感所激励，这个观点正是我认为项目管理者所应该关注的。 要解释这一切，我将从道德经上寻找依据。 不要让工作职衔框住自身 道，可道也，(The tao that can be told) 非恒道也。(is not the eternal Tao) 名，可名也，(The name that can be named) 非恒名也。(is not the eternal Name.) “无”，名天地之始；(The unnameable is the eternally real.) “有”，名万物之母。(Naming is the origin of all particular things.) 1 项目管理到底是什么？作为一个项目管理者应该做些什么呢？ 如您所想，项目管理者的一部分工作就是管理项目：收集需求、与项目相关人员沟通、设置项目优先级、安排任务、帮助团队解决困扰。许多机构都可以教你如何做好项目管理，并且这些技能你值得拥有。 然而，在开放性组织中，字面上的项目管理技能仅仅只是项目管理者需要做到的一小部分，这些组织需要更多其他的东西：即勇气。如果你擅长于管理项目（或者是真的擅长于任何工作），那么你就进入了舒适区。这时候就是需要鼓起勇气开始尝试冒险之时。 您有勇气跨出舒适区吗？向权威人士提出挑战性的问题，可能会引发对方的不快，但也可能会开启一个更好的方法，您有勇气这样做吗？有确定需要做的下一件事，然后真正去完成它的勇气吗？有主动去解决因为交流的鸿沟而遗留下来的问题的勇气吗？有去尝试各种事情的勇气吗？有失败的勇气吗？ 道德经的开篇（上面引用的）就表明词语（words）、标签（labels）、名字（names）这些是有限制的，当然也包括工作职衔。在开放性组织中，项目经理不仅仅是执行管理项目所需的机械任务，而且要帮助团队完成组织的使命，尽管这已经被限定了。 联系起合适的人 三十辐共一轂，(We join spokes together in a wheel, ) 当其无，(but it is the center hole) 有车之用。(that makes the wagon move.) 11 当我过渡到项目管理的工作时，我必须学会的最为困难的一课是：并不是所有解决方案都是可完全地接受，甚至有的连预期都达不到。这对我来说是全新的一页。我喜欢全部都能解决。但作为项目管理者，我的角色更多的是与人沟通—使得那些确实有解决方案的人可以更高效地合作。 这并不是逃避责任或者不负责。这意味着可以很舒适的说，“我不知道，但我会给你找出答案”，然后就可迅速地结束这个循环。 想像一下马车的车轮，如果没有毂中的孔洞所提供的稳定性和方向，辐条便会失去支持，车轮也会散架。在一个开放性的组织中，项目管理者可以通过把合适的人凝聚在一起，培养正确的讨论话题来帮助团队保持持续向前的动力。 信任你的团队 太上，不知有之；(When the Master governs, the people are hardly aware that he exists.) 其次，亲而誉之；(Next best is a leader who is loved.) 其次，畏之；(Next, one who is feared.) 其次，侮之。(The worst is one who is despised.) 信不足焉，(If you don’t trust the people, ) 有不信焉。(you make them untrustworthy.) 悠兮，其贵言。(The Master doesn’t talk, he acts.) 功成事遂，(When his work is done, ) 百姓皆谓：“我自然”。(the people say, “Amazing: we did it, all by ourselves!”)[17] Rebecca Fernandez 曾经告诉我开放性组织的领导与其它组织的领导者最大的不同点在于，我们不是去取得别人的信任，而是信任别人。 开放性组织会雇佣那些非常聪明的，且对公司正在做的事情充满激情的人来做工作。为了能使他们能更好的工作，我们会提供其所需，并尊重他们的工作方式。 至于原因，我认为从道德经中摘出的上面一段就说的很清楚。 顺其自然 上德无为而无以为；(The Master does nothing yet he leaves nothing undone.) 下德为之而有以为。(The ordinary man is always doing things, yet many more are left to be done.)[38] 你认识那类总是极其忙碌的人吗？认识那些因为有太多事情要做而看起来疲倦和压抑的人吗？ 不要成为那样的人。 我知道说比做容易。帮助我没有成为那类人的最重要的东西是：我时刻记着大家都很忙这件事。我没有一个那样无聊的同事。 但总需要有人成为在狂风暴雨中仍保持镇定的人。总需要有人能够宽慰团队告诉他们一切都会好起来，我们将在现实和一天中工作时间有限的情况下，找到方法使得任务能够完成（因为事实就是这样的，而且我们必须这样）。 成为那样的人吧。 对于上面这段道德经所说的，我的理解是那些总是谈论他或她正在做什么的人实际上并没有时间去做他们谈论的事。如果相比于你周围的人，你能把你的工作做的毫不费劲，那就说明你的工作做对了。 做一名文化传教士 上士闻道，(When a superior man hears of the Tao, ) 勤而行之；(he immediately begins to embody it.) 中士闻道，(When an average man hears of the Tao, ) 若存若亡；(he half believes it, half doubts it.) 下士闻道，(When a foolish man hears of the Tao, ) 大笑之。(he laughs out loud.) 不笑不足以為道。(If he didn’t laugh, it wouldn’t be the Tao.) [41] 去年秋天，我和一群联邦雇员参加了一堂 MBA 的商业准则课程。当我开始介绍我们公司的文化、价值和伦理框架时，我得到的直接印象是：我的同学和教授都认为我就像一个天真可爱的小姑娘，做着许多关于公司应该如何运作的甜美白日梦。他们告诉我事情不可能是他们看起来的那样，他们还告诉我应该进一步考察。 所以我照做了。 然而我发现的是：事情恰好是他们看起来的那样。 在开放性组织，关于企业文化，人们应该随着企业的成长而时时维护那些文化，以使它随时精神焕发，充满斗志。我（和其它开源组织的成员）并不想过着如我同学们所描述的那样，“为生活而工作”。我需要有激情、有目标，需要明白自己的日常工作是如何对那些我所坚信的东西做贡献的。 作为一个项目管理者，你可能会认为在你的团队中，你的工作对培养你们公司的企业文化没有多少帮助。然而你的工作正是孕育文化本身。 Kaizen (持续改善) 为学日益，(In pursuit of knowledge, every day something is added.) 为道日损。(In the practice of the Tao, every day something is dropped.) 损之又损，(Less and less do you need to force things, ) 以至于无为。(until finally you arrive at non-action.) 无为而无不为。(When nothing is done, nothing is left undone.) [48] 项目管理的常规领域都太过于专注最新、最强大的的工具，但对于应该使用哪种工具，这个问题的答案总是一致的：“最简单的”。 例如，我将任务列表放在桌面的一个文本文件中，因为它很单纯，不会受到不必要的干扰。您想介绍给团队的，无论是何种工具、流程和程序都应该是能提高效率，排除障碍的，而不是引入额外的复杂性。所以与其专注于工具，还不如专注于要使用这些工具来解决的问题。 作为一个项目经理，我最喜爱的部分是在敏捷世界中，我有自由抛弃那些没有成效的东西的权利。这与 kaizen 的概念相关，或叫 “持续改进”。不要害怕尝试和失败。失败是我们在探索什么能够起作用，什么不能起作用的过程中所用的标签，这是提高的唯一方式。 最好的过程都不是一蹴而就的。作为项目管理者，你应该通过支持他们，而不是强迫他们去做某些事来帮助你的团队。 实践 天下皆谓我”道”大，(Some say that my teaching is nonsense.) 似不肖。(Others call it lofty but impractical.) 夫唯大，(But to those who have looked inside themselves, ) 故似不肖。(this nonsense makes perfect sense.) 若肖，(And to those who put it into practice, ) 久矣其细也夫！(this loftiness has roots that go deep.) [67] 我相信开放性组织正在做的事。开放性组织在管理领域的工作几乎与他们提供的产品和服务一样重要。我们有机会以身作则，激发他人的激情和目的，创造激励和充分授权的工作环境。 我鼓励你们找到办法把这些想法融入到自己的项目和团队中，看看会发生什么。了解你们组织的使命，知晓你的项目是如何为这个使命做贡献的。鼓起勇气，尝试某些看起来没有多少成效的事，同时不要忘记和我们的社区分享你所学到的经验，这样我们就可以继续改进。 via: https://opensource.com/open-organization/16/2/tao-project-managementpublish: https://linux.cn/article-7385-1.html 作者：Allison Matlack译者：runningwater校对：FSSlc 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"项目管理","slug":"项目管理","permalink":"https://fsslc.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"道德经","slug":"道德经","permalink":"https://fsslc.github.io/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"}]},{"title":"[翻译] 如何在 Linux 中根据国家位置来阻断网络流量","date":"2016-01-14T01:12:52.000Z","path":"2016/01/14/Translate-How-to-block-network-traffic-by-country-on-Linux/","text":"根据 IP 地址进行网络流量阻断 source: https://www.needpix.com/photo/download/1790674/network-networking-block-chain-communication-media-connection-business-internet-multimedia 作为一名维护 Linux 生产服务器的系统管理员，你可能会遇到这样一些情形：你需要根据地理位置，选择性地阻断或允许网络流量通过。 例如你正经历一次由注册在某个特定国家的 IP 发起的 DoS 攻击；或者基于安全考虑，你想阻止来自未知国家的 SSH 登录请求；又或者你的公司对某些在线视频有分销权，它要求只能在特定的国家内合法发行；抑或是由于公司的政策，你需要阻止某个本地主机将文件上传至任意一个非美国的远程云端存储。 所有的上述情形都需要设置防火墙，使之具有基于国家位置过滤流量的功能。有几个方法可以做到这一点，其中之一是你可以使用 TCP wrappers 来为某个应用（例如 SSH，NFS， httpd）设置条件阻塞。但其缺点是你想要保护的那个应用必须以支持 TCP wrappers 的方式构建。另外，TCP wrappers 并不总是能够在各个平台中获取到（例如，Arch Linux 放弃了对它的支持）。另一种方式是结合基于国家的 GeoIP 信息，设置 ipset，并将它应用到 iptables 的规则中。后一种方式看起来更有希望一些，因为基于 iptables 的过滤器是与应用无关的，且容易设置。 在本教程中，我将展示 另一个基于 iptables 的 GeoIP 过滤器，它由 xtables-addons 来实现。对于那些不熟悉它的人来说， xtables-addons 是用于 netfilter/iptables 的一系列扩展。一个包含在 xtables-addons 中的名为 xt_geoip 的模块扩展了 netfilter/iptables 的功能，使得它可以根据流量来自或流向的国家来进行过滤，IP 掩蔽（NAT）或丢包。若你想使用 xt_geoip，你不必重新编译内核或 iptables，你只需要使用当前的内核构建环境（/lib/modules/`uname -r`/build）以模块的形式构建 xtables-addons。同时也不需要进行重启。只要你构建并安装了 xtables-addons ， xt_geoip 便能够配合 iptables 使用。 至于 xt_geoip 和 ipset 之间的比较，xtables-addons 的官方网站 上是这么说的： 相比于 ipset，xt_geoip 在内存占用上更胜一筹，但对于匹配速度，基于哈希的 ipset 可能更有优势。 在教程的余下部分，我将展示如何使用 iptables/xt_geoip 来根据流量的来源地或流入的国家阻断网络流量。 在 Linux 中安装 xtables-addons下面介绍如何在各种 Linux 平台中编译和安装 xtables-addons。 为了编译 xtables-addons，首先你需要安装一些依赖软件包。 在 Debian，Ubuntu 或 Linux Mint 中安装依赖$ sudo apt-get install iptables-dev xtables-addons-common libtext-csv-xs-perl pkg-config 在 CentOS，RHEL 或 Fedora 中安装依赖CentOS/RHEL 6 需要事先设置好 EPEL 仓库（为 perl-Text-CSV_XS 所需要）。 $ sudo yum install gcc-c++ make automake kernel-devel-`uname -r` wget unzip iptables-devel perl-Text-CSV_XS 编译并安装 xtables-addons从 xtables-addons 的官方网站 下载源码包，然后按照下面的指令编译安装它。 $ wget http://downloads.sourceforge.net/project/xtables-addons/Xtables-addons/xtables-addons-2.10.tar.xz $ tar xf xtables-addons-2.10.tar.xz $ cd xtables-addons-2.10 $ ./configure $ make $ sudo make install 需要注意的是，对于基于红帽的系统（CentOS、RHEL、Fedora），它们默认开启了 SELinux，所以有必要像下面这样调整 SELinux 的策略。否则，SELinux 将阻止 iptables 加载 xt_geoip 模块。 $ sudo chcon -vR --user=system_u /lib/modules/$(uname -r)/extra/*.ko $ sudo chcon -vR --type=lib_t /lib64/xtables/*.so 为 xtables-addons 安装 GeoIP 数据库下一步是安装 GeoIP 数据库，它将被 xt_geoip 用来查询 IP 地址与国家地区之间的对应关系。方便的是，xtables-addons 的源码包中带有两个帮助脚本，它们被用来从 MaxMind 下载 GeoIP 数据库并将它转化为 xt_geoip 可识别的二进制形式文件；它们可以在源码包中的 geoip 目录下找到。请遵循下面的指导来在你的系统中构建和安装 GeoIP 数据库。 $ cd geoip $ ./xt_geoip_dl $ ./xt_geoip_build GeoIPCountryWhois.csv $ sudo mkdir -p /usr/share/xt_geoip $ sudo cp -r {BE,LE} /usr/share/xt_geoip 根据 MaxMind 的说明,他们的 GeoIP 数据库能够以 99.8% 的准确率识别出 ip 所对应的国家，并且每月这个数据库将进行更新。为了使得本地安装的 GeoIP 数据是最新的，或许你需要设置一个按月执行的 cron job 来时常更新你本地的 GeoIP 数据库。 阻断来自或流向某个国家的网络流量一旦 xt_geoip 模块和 GeoIP 数据库安装好后，你就可以在 iptabels 命令中使用 geoip 的匹配选项。 $ sudo iptables -m geoip --src-cc country[,country...] --dst-cc country[,country...] 你想要阻断流量的那些国家是使用2个字母的 ISO3166 代码 来特别指定的（例如 US（美国）、CN（中国）、IN（印度）、FR（法国））。 例如，假如你想阻断来自也门（YE） 和 赞比亚（ZM）的流量，下面的 iptabels 命令便可以达到此目的。 $ sudo iptables -I INPUT -m geoip --src-cc YE,ZM -j DROP 假如你想阻断流向中国（CN） 的流量，可以运行下面的命令： $ sudo iptables -A OUTPUT -m geoip --dst-cc CN -j DROP 匹配条件也可以通过在 --src-cc 或 --dst-cc 选项前加 ! 来达到相反的目的： 假如你想在你的服务器上阻断来自所有非美国的流量，可以运行： $ sudo iptables -I INPUT -m geoip ! --src-cc US -j DROP 对于使用 Firewall-cmd 的用户某些发行版本例如 CentOS/RHEL7 或 Fedora 已经用 firewalld 替代了 iptables 来作为默认的防火墙服务。在这些系统中，你可以类似使用 xt_geoip 那样，使用 firewall-cmd 来阻断流量。利用 firewall-cmd 命令，上面的三个例子可被重新写为： $ sudo firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -m geoip --src-cc YE,ZM -j DROP $ sudo firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -m geoip --dst-cc CN -j DROP $ sudo firewall-cmd --direct --add-rule ipv4 filter INPUT 0 -m geoip ! --src-cc US -j DROP 总结在本教程中，我展示了使用 iptables/xt_geoip 来根据流量的来源地或流入的国家轻松地阻断网络流量。假如你有这方面的需求，把它部署到你的防火墙系统中可以使之成为一个实用的办法。作为最后的警告，我应该提醒你的是：在你的服务器上通过基于 GeoIP 的流量过滤来禁止特定国家的流量并不总是万无一失的。GeoIP 数据库本身就不是很准确或齐全，且流量的来源或目的地可以轻易地通过使用 VPN、Tor 或其他任意易受攻击的中继主机来达到欺骗的目的。基于地理位置的过滤器甚至可能会阻止本不该阻止的合法网络流量。在你决定把它部署到你的生产环境之前请仔细考虑这个限制。 via: http://xmodulo.com/block-network-traffic-by-country-linux.html 作者：Dan Nanni译者：FSSlc校对：wxy 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"阻断网络","slug":"阻断网络","permalink":"https://fsslc.github.io/tags/%E9%98%BB%E6%96%AD%E7%BD%91%E7%BB%9C/"},{"name":"xtables-addons","slug":"xtables-addons","permalink":"https://fsslc.github.io/tags/xtables-addons/"}]},{"title":"在 Ubuntu 中安装 AFEPack","date":"2015-11-03T06:02:55.000Z","path":"2015/11/03/Install-AFEPack-In-Ubuntu/","text":"在 Ubuntu 中安装 AFEPack Update相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考我的说明进行安装，当然，当时做的时候有些库可能用不了了。。 系统准备我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。） 准备安装包首先，下载好 deal.II、AFEPack、mpich（非必须） 这几个软件的安装包。 其中的 deal.II 和 AFEPack 可以到我的百度网盘去下载，这个是我从我大学同学的未来的师兄那里获得的，而那位师兄的老师正是这个软件包的作者 李若 老师。由于高版本的 deal.II 版本经过了许多的修改，且鉴于 AFEPack 几乎停滞的开发状态，我们采用的是 deal.II 的 6.3.1 版本。而 mpich 则可以到官网去下载最新的稳定版本。 相关软件的下载地址为： deal.II 和 AFEPack : 链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxtmpich : http://www.mpich.org/downloads/ 下载好这些包后，将他们进行解压备用。 安装必要软件接下来，安装一些必要的软件。 首先安装 boost 库。这个可以用命令行，也可以使用 synaptic (新得立) 这个图形化的包管理软件来安装。命令行需要使用的命令为： sudo apt-get install libboost-dbg libboost-all-dev 接着安装自动化产生 makefile 的相关工具。其中 aclocal 已经被包括在 autoconf 里了。 sudo apt-get install autoconf automake 接着安装编译器，由于某些原因，编译 AFEPack 时，用高版本(如 4.8)的 gcc 和 g++ 会出错，所以需要安装对应的低版本的包。这里安装 4.6 版本。 sudo apt-get install gcc-4.6 g++-4.6 gfortran # 降低 gcc，g++ 的版本，可以在后面改回来 cd /usr/bin sudo ln -s gcc-4.6 gcc sudo ln -s g++-4.6 g++ 安装 deal.II根据李若老师的解释，他选用这个包的原因是看上了这个包里面 lac 、 base 中的代码，即关于基础线性代数相关的代码写得很好，所以才采用了 deal.II 。所以我们可以只编译里面的部分文件，当然如果你不在乎占用一点额外的磁盘空间，也可以选择完整安装。 关于安装路径，下面以我的安装位置 /home/lc/Pkg/deal.II 来举例，其中 /home/lc 为我的家目录，可以对应地修改，也可以安装到其他路径，如 /usr/local/deal.II 等。 首先，进入解压后的 deal.II 目录，我的在 /home/lc/Pkg/deal.II 。 然后在终端中依次输入下面的命令，其中 # 后的内容为注释，可以忽略。 cd /home/lc/Pkg/deal.II # 进入解压后的 deal.II 目录 ./configure make -j4 lac base contrib # -j 选项是启用多线程，以此来加快编译的速度，后面的数字最好与你机子的 CPU 的线程数相同或更少 # 或者使用 make all 来完整安装 经过一段时间后(根据你的机器配置而定)，就把需要的文件编译好了。下面需要做一些软链接。在以前安装时，我尝试过直接把 deal.II 编译后产生的相应目录加在系统变量中，然后再安装 AFEPack，结果 AFEPack 不能找到 deal.II 的头文件，所以还是做个链接。具体的原因我也不清楚，可能需要问作者本人。 下面是我做链接时使用的命令，请相应做些修改： cd /usr/local/include sudo ln -s ~/Pkg/deal.II/deal.II/include/ . sudo ln -s ~/Pkg/deal.II/lac/include/lac/ . sudo ln -s ~/Pkg/deal.II/base/include/base/ . sudo ln -s ~/Pkg/deal.II/contrib/tbb/tbb22_20090809oss/include/tbb/ . # 这里的 tbb22_20090809oss 可能会有所不同，但一般这个目录都是以 tbb 开头的，可用 Tab 键来自动补全； # 最后的 `.` 代指当前目录 ，以下类型 cd /usr/local/lib sudo ln -s ~/Pkg/deal.II/lib/lib* . 安装 mpich这个不是必须的，除了 mpich，也可以直接安装OpenMPI。 这个的安装可以根据解压后文件夹中的指示来操作，一般都是如下几个命令： cd /home/lc/Pkg/mpich2/ # 进入 mpich2 解压后的目录，根据你自己的情况调整 ./configure make -j4 sudo make install 这样就安装好了 mpich。 当然，我们也可以直接使用软件源里面的 mpich，这样或许更省事些。 安装 AFEPack现在进行 AFEPack 的安装。首先利用 autotools 套件中的软件(即 aclocal，autoconf，automake 等)来自动生成 configure 文件。使用的命令如下： cd /home/lc/Pkg/AFEPack aclocal autoconf automake --add-missing 然后把 # AFEPack templete export AFEPACK_TEMPLATE_PATH=&quot;/home/lc/Pkg/AFEPack/template/triangle:/home/lc/Pkg/AFEPack/template/rectangle:/home/lc/Pkg/AFEPack/template/interval:/home/lc/Pkg/AFEPack/template/twin_triangle:/home/lc/Pkg/AFEPack/template/tetrahedron:/home/lc/Pkg/AFEPack/template/twin_tetrahedron:/home/lc/Pkg/AFEPack/template/four_tetrahedron&quot; 加到 ～/.bashrc 文件中，然后使用 source ~/.bashrc 来使更改生效。 接着对 AFEPack 进行配置和编译。 ./configure make -j4 编译期间会报错停掉，报 mpi.h 找不到。这时仍然继续，输入： make install 然后进入 AFEPack 目录下的 template 目录，来编译模板。我使用的命令为： cd /home/lc/Pkg/AFEPack/template make 现在来编译关于 mpi 的静态文件。这里需要 MPI 的相关库，这里我们使用的是 mpich。 ~/Pkg/AFEPack/library/mpi make -j4 example 子目录下有一些实用的工具，我们现在来编译它们。 cd ~/Pkg/AFEPack/example make -j4 最后执行下面的命令来使得 ld 能够找到 AFEPack.so 等静态库。 cd ～/Pkg/AFEPack sudo ldconfig 至此， AFEPack 的安装就结束了。 如果你在安装期间有什么问题，可以来询问我，我尽量帮忙。 参考资料 AFEPack 官网 尝试在ubuntu 16.04下安装AFEPack","tags":[{"name":"AFEPack","slug":"AFEPack","permalink":"https://fsslc.github.io/tags/AFEPack/"},{"name":"deal.II","slug":"deal-II","permalink":"https://fsslc.github.io/tags/deal-II/"}]},{"title":"Ubuntu 下 OpenDX Data Explorer 的字体问题","date":"2015-11-03T05:51:25.000Z","path":"2015/11/03/Cannot-convert-string-to-type-FontStruct/","text":"解决在 Ubuntu 下 OpenDX Data Explorer 的字体问题 OpenDX Logo 缘起最近一直在学习使用李若老师的 AFEPack 软件包，其中这个包输出的图形格式一般为 OpenDX，但据网上的一些评论，它基本上处于类似渡渡鸟的境地了。但自己能力有限，还不能更改它输出为 Vtk 等现在主流的图像格式，所以还是先用着吧。 现在读取 OpenDX 格式的软件好像就只有 OpenDX Data Explorer 了。自从 IBM 开源了 OpenDX 后，就没有多少官方的支持，现在它的开发主要由一个名为 Visualization and Imagery Solutions, Inc. 的公司负责。在 Ubuntu 中，可以直接通过软件源安装编译好的 dx 软件。 安装后，可以在终端中使用 dx 命令来启动 OpenDX Data Explorer。但终端始终会出现类似如下的警告： Cannot convert string &quot;-*-helvetica-bold-r-*-*-16-*&quot; to type FontStruct 于是乎，便利用网络来搜索答案。下面是解决办法。 解决方法搜索的过程就不说了，反正还是 Google 强。 最开始说的是先确认下有没有安装这些字体。一般是先建议你安装两个字体包，使用的命令是： sudo apt-get install xfonts-75dpi xfonts-100dpi 它们默认是安装在 /usr/share/fonts/X11/ 目录中。 然后可以使用下面的命令来查看是否安装了上面警告中的字体： xlsfonts -fn &quot;-*-helvetica-bold-r-*-*-10-*-*-*-*-*-*-*&quot; 其中的 * 都是一些匹配。可以类似地修改匹配格式。 但是安装完后还是没有解决问题。于是又搜。 最后在这个网页里面找到了解决办法。 原来，在安装完这些字体后，我们还需要一些设置，具体的命令是： xset +fp /usr/share/fonts/X11/75dpi/ xset +fp /usr/share/fonts/X11/100dpi/ 至于上面的命令具体执行了什么步骤，可以 man xset 。随后问题便解决了。遇到类似的问题（例如某个软件中文乱码，呈现出方框），似乎都可以这样解决。 后话最后说说我对 OpenDX 的看法吧。 刚开始入门的时候，总感觉资料很少，这个软件不太好使用。相比于 ViSit 或 ParaView 等软件，dx 太难用了，什么都要自己定义，而且找到的资料也不是很多；所以对它的印象不好。 现在由于导师分配的任务，我需要使用 AFEPack 来求解方程，最后需要用 dx 来展示结果。通过这几天的摸索，感觉了它的强大。现在基本明白了为什么李若老师喜欢这种数据格式和这个软件的原因了。说到底，还是需要折腾。 至于学习资料。安装好 dx 后，一般可以在 /usr/share/dx/samples 找到示例代码；文档说明的话，可以看 /usr/share/dx/html 里面的东西，这些 html 文件里面包含的内容其实很多的。一步一步的看下去还是有很多收获的。 至于 Visualization and Imagery Solutions, Inc. 公司出的那本名为 OpenDX---Paths to Visualization 的书，我觉得自带的 html 文件内容或许更多一些，当然看看还是不错的。 以前我在这个网站找到了很多关于 OpenDX 的资料，现在仍然推荐去看看那里的东西。 TODO： 通过 Ubuntu 仓库安装 dx 软件有一个问题： 在经过一段时间的使用后， dx 会吃掉 100% 的 CPU。根据我的搜索，现在还没有找到解决办法，自编译的 dx 就好像没有这个问题。后面再搜索一下吧。","tags":[{"name":"Font","slug":"Font","permalink":"https://fsslc.github.io/tags/Font/"},{"name":"OpenDX","slug":"OpenDX","permalink":"https://fsslc.github.io/tags/OpenDX/"}]},{"title":"在 Ubuntu 中安装 FEniCS","date":"2015-10-12T04:32:13.000Z","path":"2015/10/12/Install-FEniCS-in-Ubuntu/","text":"在 Ubuntu 中安装 FEniCS Update 20161212现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看官网的说明。这样就可以少折腾了。 缘由最近导师去开了个会议，从其他人那里打听到有很多人都在 FEniCS 的基础上写代码了。导师她最开始认为，它是用来写 Fortran 代码的一个平台，加之她主要使用的编程语言为 Fortran，所以希望我们能够去学习一下。 第一次看到 FEniCS 这个词，应该可以追溯到我大四做毕业论文的时候。那时想找个软件来书写有限元程序，因为自己从底层开始写起太费事了。通过搜索，找到了许多软件，具体可以看看这个链接。通过试用，左右权衡，最后决定使用 deal.II 来做毕业论文。 当时对于 FEniCS 的认识是： 它是用 Python 写的，自己对 Python 不熟悉，查找到的资料不是很齐全； 当时自己尝试从 PPA 安装了 FEniCS， 但程序运行地不是很顺利； 现在，通过这一两天的使用，觉得这货实在是太简单了，用 Python 根据它自定义的 UFL 语言来自动生成可执行代码，最后使用 OpenGL 和 VTK 来生成图形和 vtu 文件。当然，方便的代价就是编译过程的时间有点长；毕竟鱼和熊掌是不能兼得的。 PS：FEnics 还可以与 C, C++, Fortran, 或 MATLAB 交互，具体可以看这里的文档。 FEniCS 的安装过程安装前的准备首先我的安装平台为 ubuntu 14.04, 64 位，但从自己安装的过程来看，其他系统应该也可以安装，大体步骤是一致的，具体可以看官网的说明。 特别说明：对于使用 Windows 系统的同学，你就别指望能够完美安装和运行 FEniCS 了，官网上说了， Windows 平台的安装包没有更新了。所以还是尽快学习一些 Linux 或 Unix 这类系统的使用方法吧。命令行真的非常好用，包管理器的使用也非常方便。 下面我是通过 Anaconda 这个 Python 集成环境来安装 FEniCS 的，所以你需要安装好 Anaconda。可以到官网的下载页面 去下载相应版本的安装包，这里我们使用的是 Anaconda-2.3.0-Linux-x86_64.sh，至于安装，该页面里有提示，这里不赘述了。 另外，在运行 FEniCS 的程序之前，需要安装好 gcc g++ gfortran 等编译器，不然会出现意想不到的错误。可以使用如下的命令来安装这些软件： sudo apt-get install build-essential gfortran 具体的安装过程根据官网的解释，有如下几种方法可以来进行安装： 直接添加 PPA 来进行下载。 但安装尝试后，会引入许多不必要的安装依赖如 texlive 等，为了不污染系统，所以没有采取这种方法。当然，如果你订阅了他们的 PPA，这种方式能够使你获取到最新的更新。如果你没有‘洁癖’，可以尝试这种方法。 (注： 最近(2015-12) 找到了如何在安装有 Texlive 发型包的情况下，不再引起上面需要安装 texlive 依赖的方法，具体请参考这篇文章的最后一段，但请自己制作 dummy package，因为在安装时，可能会出现一点问题，请根据问题的描述更改相应的配置文件。 ) 通过下载脚本编译。 通过下面的这个脚本来从源文件编译安装 FEniCS。 curl -s http://fenicsproject.org/fenics-install.sh | bash 但在尝试的过程中，总是提示 SSL 认证失败。无果，所以放弃了这种方法。 直接下载虚拟机镜像来运行。 将镜像导入 Vbox 后，大概用了 7G 的空间，镜像里的系统使用的是 Lubuntu，感觉很精简，但没有自己安装的 Ubuntu 体验好。又考虑到空间占用的原因，亦弃之。 通过 Anaconda 来安装 FEniCS。 可以根据这个网页的指导安装。 这个 github 仓库里面用的命令是： conda install fenics mkl --channel juanlu001 而官网里面使用的命令是： conda create --name fenics27 python=2.7 source activate fenics27 conda install fenics --channel juanlu001 我最开始是根据 Github 上的命令来安装的。而再给其他人安装的时候，我特别使用了官网了给出的命令，现在大致知道了它们之间的区别：前者是直接将 FEniCS 安装到 Anaconda 的目录里面，而后者是创建了一个新的环境，单独进行了安装。考虑到简洁性，我推荐第二个命令。 在终端中依次输入上面的命令后，会大概下载 300M 左右的安装包，最后安装完毕会有 4G 左右(加上 Anaconda 原来安装后的文件)。经过一段漫长的等待后，FEniCS 就安装好了。 安装后需要做的事安装完成后，自然需要运行一下 FEniCS 自带的示例程序，它们一般在 ~/anaconda/envs/fenics27/share/dolfin/ 目录下。随便进入某个示例目录，可以有名为 cpp 和 python 的两个目录。先进入 python 这个目录试试效果。 在终端运行： python filename.py # 注意请将这句中的 filename 换为具体的程序名称 然后终端会报错，大致意思是没有找到 dolfin 这个 module。这应该是环境变量的问题，最后通过搜索，参考这里的说明，我们需要将 dolfin.conf 这个文件加到 PYTHONPATH 环境变量中。命令为： source &lt;PATH_TO_YOUR_DOLFIN_INSTALLATION&gt;/share/dolfin/dolfin.conf 对于使用 Anaconda 安装 FEniCS 的情况，dolfin.conf 一般在 ~/anaconda/envs/fenics27/share/dolfin 目录里。 最好是将这个上面这个命令写入你本地的 .bashrc 文件里面，然后用 source ~/.bashrc 更新环境变量。 这个做完后，总该可以运行程序了吧。可惜，还不行。你会看终端里报错，提示说某些 VTK 的动态链接库找不到，根据 Github 里的 issue，需要使用下面的命令将 VTK 的版本降低： conda list vtk conda install &quot;vtk=5.10&quot; 这样就可以运行程序了。在程序执行的开始，你可能会看到有些提示，说 MKL 库有 30 天的试用期限，要你购买。对于这种情况，Anaconda 给学校和科研机构提供有学术版的许可，只要你使用 edu 的邮箱就可以申请到, 申请地址 。 申请后，会得到一个 license 文件，将其放在 ~/.continuum 目录下即可。 另外，我发现我自己申请的 license 同样也可以用在别人的机器上，不知这是不是一个 bug。 安装后软件的学习关于入门，可以直接看官网的文档，例如 tutorial，The FEniCS Book, Manual。 PS： 可以到这里下载到 The FEniCS Book。 关于这两天学习的感受：我是从 tutorial 入门的，看了过后感觉这货居然这么简单，相比于我用 deal.II 写代码，这不知要轻松多少倍。另外，tutorial 里面的例子有些代码不能运行了，应该是 dolfin(或其他组件) 更新的缘故，而文档还没有被更新。下一步继续看文档来学习。 以后深入后，再写点东西来分享。 UPDATE 2018.07.31有几点需要更新的： 偶然发现了这个 网站， 似乎是将 fenics 应用到 HPC 领域中，并且在 edx 中开了一门 MOOC 关于学习资源，可以看看 这个老师的主页，里面课程中有一些 notes。","tags":[{"name":"FEniCS","slug":"FEniCS","permalink":"https://fsslc.github.io/tags/FEniCS/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://fsslc.github.io/tags/Anaconda/"}]},{"title":"在 Ubuntu 中安装设置 deal.II、VisIt 和 ParaView","date":"2015-10-10T04:07:08.000Z","path":"2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/","text":"介绍如何在 Ubuntu 中安装设置 deal.II、VisIt 和 ParaView deal.II 的安装与配置 deal.II 的安装关于安装，有如下几种方式： 到 deal.II 的下载页面去下载打包好的文件： 对于 Ubuntu、Mac、Debain 都已经有编译好的二进制文件，Arch、Gentoo 可以分别通过 AUR 和 Gentoo Science Overlay 来得到； 利用 docker 来生成相关的镜像，具体可以参考这里； 基于源码安装： 官网上推荐 candi，也可以通过 spack来安装。 可以按照官网的指南来进行按照。 下面是我自己的安装过程，算是一个记录吧。 下载好源文件后，进行解压，然后进入解压的目录，具体安装方法可以通过 README.md 这个文件知晓。需要注意的是 deal.II 是一套有限元 C++ 库，所以在 Linux 上面需要进行编译安装。编译时，需要使用 cmake 和 make，所以先将这两个软件安装好。然后依次执行下面的命令来进行编译安装： cmake -DCMAKE_INSTALL_PREFIX=/path/where/deal.II/should/be/intalled/to .. make install # (alternatively $ make -j&lt;N&gt; install) 这里需要注意的是： 如果 deal.II 的安装为一般用户不可写的目录，需要 sudo 命令； 为了加快编译的速度，在第二句中，在 make 后加上 -jN 参数，其中 N 最好不要超过电脑的最大 CPU 数目； 执行完上面的命令后，接着就是漫长的等待了。在我的机子上 (Ubuntu 14.04, x86_64, Intel® Core™ i5-2430M CPU @ 2.40GHz × 4，SSD) 编译安装总共花了将近 40 min；一般的机子大概需要 1 个小时左右。 deal.II 的配置首先是 将 deal.II 的目录加入系统环境变量之中，只需要在 ~/.bashrc 中加入如下几行代码即可： # deal.II 环境变量 export PATH=/opt/deal.II:$PATH DEAL_II_DIR=/opt/deal.II 在具体使用时，主要使用这三个命令： cmake . make # 也可以直接使用 make release, 这样编译出来的出现运行快些 make run 关于 deal.II 的学习，开发者为自学者提供了详尽的文档，可以在 deal.II 的下载页面里找到离线的文档，并且在 deal.II 的安装目录下有文档中的示例代码； 另外，deal.II 的主要开发者 Wolfgan Bangerth 还在他的教学网址上提供了讲义和授课的视频链接(不过视频在 YouTube 上)。 Update 20161210这里只是介绍了最简单的安装，要安装额外的软件库还需要自己去安装。可以参考 这里 中的命令来进行安装。当然，在 Ubuntu 、Debian 、Gentoo 中有官方支持的版本，如果嫌麻烦，可以直接用包管理器安装。 VisIt 的安装和配置 VisIt 的安装安装方面，首先到官网的下载页面里下载相关的包，并在同一页面下载 Visit install script 文件，具体安装过程，可以参考同一页面的 Visit install notes 。 VisIt 的配置关于配置，在 ~/.bashrc 中加入如下几行代码来添加环境变量： # visit 环境变量 export PATH=/opt/visit:$PATH 当然，如果你想和我一样，想为 VisIt 添加一个快捷方式，来达到 在系统的应用里面直接点击图标就启动软件的目的，可以按照下面方法来进行。 首先创建一个名为 visit.desktop 的文件，然后进行编辑，将如下的内容复制到该文件中(当然你可以进行自定义)： [Desktop Entry] Version=2.8.1 Type=Application Name=VisIt GenericName=image viewer Comment=VisIt is an Open Source, interactive, scalable, visualization, animation and analysis tool. Exec=/opt/visit/bin/visit Terminal=false MimeType=image/vtk; Icon=/opt/visit/visit.jpg Categories=Development;Graphics;Viewer; StartupNotify=true Actions=Window;Document; 注意: 上面的 Icon 后面的图片是我从 visit 官网里下载的，当然可以使用其他图片。 最后保持修改的文件，然后将该文件移动到 /usr/share/applications/ 目录中。当然，你也可以直接在这个目录中创建这个文件。这样，你就可以在系统的应用中找到 visit 了，通过点击图标就可以启动 visit。 Paraview 的安装和配置 paraview Logo Paraview 的安装当然，对于各种发行版本，对应的软件仓库里面可能已经有 paraview 的二进制包了，可以直接用相应的包管理器下载安装。 下面介绍的是自己手动安装 paraview 的过程。 首先到官网的下载页面上选择适合自己机子的相应压缩包并下载。然后解压，将解压的文件夹复制到需要安装的位置即可。 Paraview 的配置关于配置，和 visit 基本相似。 首先添加环境变量： # paraview 环境变量 export PATH=/opt/paraview:$PATH 然后制作图标；方法与上面一致，这里只列出 paraview.desktop 文件的内容： [Desktop Entry] Version=4.2 Type=Application Name=Paraview GenericName=image viewer Comment=ParaView is an open-source, multi-platform data analysis and visualization application Exec=/opt/paraview/bin/paraview Terminal=false MimeType=image/vtk; Icon=/opt/paraview/share/icons/hicolor/96x96/apps/paraview.png Categories=Development;Graphics;Viewer; StartupNotify=true Actions=Window;Document; 结语写这个文档的目的主要是为了进行一些纪录，好在遗忘的时候可以查看，也当做是备份。有限元软件当然不止这几个，还有如 gmesh、freefem++、getfem++ 等等，这里就不介绍了。总之学习之路漫漫，吾将上下而求索。","tags":[{"name":"deal.II","slug":"deal-II","permalink":"https://fsslc.github.io/tags/deal-II/"},{"name":"Paraview","slug":"Paraview","permalink":"https://fsslc.github.io/tags/Paraview/"},{"name":"VisIt","slug":"VisIt","permalink":"https://fsslc.github.io/tags/VisIt/"}]},{"title":"[翻译] Autojump：一个可以在 Linux 文件系统快速导航的高级 cd 命令","date":"2015-08-10T02:30:56.000Z","path":"2015/08/10/Translate-Autojump-An-Advanced-cd-Command-to-Quickly-Navigate-Linux-Filesystem/","text":"介绍 Autojump 这个软件。 对于那些主要通过控制台或终端使用 Linux 命令行来工作的 Linux 用户来说，他们真切地感受到了 Linux 的强大。 然而在 Linux 的分层文件系统中进行导航有时或许是一件头疼的事，尤其是对于那些新手来说。 现在，有一个用 Python 写的名为 autojump 的 Linux 命令行实用程序，它是 Linux cd 命令的高级版本。 Autojump 命令 这个应用原本由 Joël Schaerer 编写，现在由 +William Ting 维护。 Autojump 应用可以从用户那里学习并帮助用户在 Linux 命令行中进行更轻松的目录导航。与传统的 cd 命令相比，autojump 能够更加快速地导航至目的目录。 autojump 的特色 自由开源的应用，在 GPL V3 协议下发布。 自主学习的应用，从用户的导航习惯中学习。 更快速地导航。不必包含子目录的名称。 对于大多数的标准 Linux 发行版本，能够在软件仓库中下载得到，它们包括 Debian (testing/unstable), Ubuntu, Mint, Arch, Gentoo, Slackware, CentOS, RedHat 和 Fedora。 也能在其他平台中使用，例如 OS X(使用 Homebrew) 和 Windows (通过 Clink 来实现) 使用 autojump 你可以跳至任何特定的目录或一个子目录。你还可以用文件管理器打开某个目录，并查看你在某个目录中所待时间的统计数据。 前提 版本号不低于 2.6 的 Python 第 1 步: 做一次完整的系统升级1、 以 root 用户的身份，做一次系统更新或升级，以此保证你安装有最新版本的 Python。 # apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade [基于 apt 的系统] # yum update &amp;&amp; yum upgrade [基于 yum 的系统] # dnf update &amp;&amp; dnf upgrade [基于 dnf 的系统] 注 : 这里特别提醒，在基于 yum 或 dnf 的系统中，更新和升级执行相同的行动，大多数时间里它们是通用的，这点与基于 apt 的系统不同。 第 2 步: 下载和安装 Autojump2、 正如前面所言，在大多数的 Linux 发行版本的软件仓库中， autojump 都可获取到。通过包管理器你就可以安装它。但若你想从源代码开始来安装它，你需要克隆源代码并执行 python 脚本，如下面所示： 从源代码安装若没有安装 git，请安装它。我们需要使用它来克隆 git 仓库。 # apt-get install git [基于 APT 的系统] # yum install git [基于 YUM 的系统] # dnf install git [基于 DNF 的系统] 一旦安装完 git，以普通用户身份登录，然后像下面那样来克隆 autojump： $ git clone git://github.com/joelthelion/autojump.git 接着，使用 cd 命令切换到下载目录。 $ cd autojump 下载，赋予安装脚本文件可执行权限，并以 root 用户身份来运行安装脚本。 # chmod 755 install.py # ./install.py 从软件仓库中安装3、 假如你不想麻烦，你可以以 root 用户身份从软件仓库中直接安装它: 在 Debian, Ubuntu, Mint 及类似系统中安装 autojump : # apt-get install autojump 为了在 Fedora, CentOS, RedHat 及类似系统中安装 autojump, 你需要启用 EPEL 软件仓库。 # yum install epel-release # yum install autojump 或 # dnf install autojump 第 3 步: 安装后的配置4、 在 Debian 及其衍生系统 (Ubuntu, Mint, …) 中, 激活 autojump 应用是非常重要的。 为了暂时激活 autojump 应用，即直到你关闭当前会话或打开一个新的会话之前让 autojump 均有效，你需要以常规用户身份运行下面的命令: $ source /usr/share/autojump/autojump.sh on startup 为了使得 autojump 在 BASH shell 中永久有效，你需要运行下面的命令。 $ echo &#39;. /usr/share/autojump/autojump.sh&#39; &gt;&gt; ~/.bashrc 第 4 步: Autojump 的预测试和使用5、 如先前所言， autojump 将只跳到先前 cd 命令到过的目录。所以在我们开始测试之前，我们要使用 cd 切换到一些目录中去，并创建一些目录。下面是我所执行的命令。 $ cd $ cd $ cd Desktop/ $ cd $ cd Documents/ $ cd $ cd Downloads/ $ cd $ cd Music/ $ cd $ cd Pictures/ $ cd $ cd Public/ $ cd $ cd Templates $ cd $ cd /var/www/ $ cd $ mkdir autojump-test/ $ cd $ mkdir autojump-test/a/ &amp;&amp; cd autojump-test/a/ $ cd $ mkdir autojump-test/b/ &amp;&amp; cd autojump-test/b/ $ cd $ mkdir autojump-test/c/ &amp;&amp; cd autojump-test/c/ $ cd 现在，我们已经切换到过上面所列的目录，并为了测试创建了一些目录，一切准备就绪，让我们开始吧。 需要记住的一点 : j 是 autojump 的一个封装，你可以使用 j 来代替 autojump， 相反亦可。 6、 使用 -v 选项查看安装的 autojump 的版本。 $ j -v 或 $ autojump -v 查看 Autojump 的版本 7、 跳到先前到过的目录 ‘/var/www‘。 $ j www 跳到目录 8、 跳到先前到过的子目录‘/home/avi/autojump-test/b‘ 而不键入子目录的全名。 $ jc b 跳到子目录 跳到子目录 9、 使用下面的命令，你就可以从命令行打开一个文件管理器，例如 GNOME Nautilus ，而不是跳到一个目录。 $ jo www 打开目录 在文件管理器中打开目录 你也可以在一个文件管理器中打开一个子目录。 $ jco c 打开子目录 在文件管理器中打开子目录 10、 查看每个文件夹的权重和全部文件夹计算得出的总权重的统计数据。文件夹的权重代表在这个文件夹中所花的总时间。 文件夹权重是该列表中目录的数字。(LCTT 译注: 在这一句中，我觉得原文中的 if 应该为 is) $ j --stat 查看文件夹统计数据 提醒 : autojump 存储其运行日志和错误日志的地方是文件夹 ~/.local/share/autojump/ 。千万不要重写这些文件，否则你将失去你所有的统计状态结果。 $ ls -l ~/.local/share/autojump/ Autojump 的日志 11、 假如需要，你只需运行下面的命令就可以查看帮助 : $ j --help Autojump 的帮助和选项 功能需求和已知的冲突 autojump 只能让你跳到那些你已经用 cd 到过的目录。一旦你用 cd 切换到一个特定的目录，这个行为就会被记录到 autojump 的数据库中，这样 autojump 才能工作。不管怎样，在你设定了 autojump 后，你不能跳到那些你没有用 cd 到过的目录。 你不能跳到名称以破折号 (-) 开头的目录。或许你可以考虑阅读我的有关操作文件或目录 的文章，尤其是有关操作那些以‘-‘ 或其他特殊字符开头的文件和目录的内容。 在 BASH shell 中，autojump 通过修改 $PROMPT_COMMAND 环境变量来跟踪目录的行为，所以强烈建议不要去重写 $PROMPT_COMMAND 这个环境变量。若你需要添加其他的命令到现存的 $PROMPT_COMMAND 环境变量中，请添加到 $PROMPT_COMMAND 环境变量的最后。 结论:假如你是一个命令行用户， autojump 是你必备的实用程序。它可以简化许多事情。它是一个在命令行中导航 Linux 目录的绝佳的程序。请自行尝试它，并在下面的评论框中让我知晓你宝贵的反馈。保持联系，保持分享。喜爱并分享，帮助我们更好地传播。 via: http://www.tecmint.com/autojump-a-quickest-way-to-navigate-linux-filesystem/publish: https://linux.cn/article-5983-1.html 作者：Avishek Kumar译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://fsslc.github.io/tags/Linux/"},{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Autojump","slug":"Autojump","permalink":"https://fsslc.github.io/tags/Autojump/"}]},{"title":"[翻译] LINUX 101: 让你的 SHELL 更强大","date":"2015-07-29T00:00:27.000Z","path":"2015/07/29/Translate-LINUX-101-POWER-UP-YOUR-SHELL/","text":"在我们的关于 shell 基础的指导下, 得到一个更灵活, 功能更强大且多彩的命令行界面 为何要这样做? 使得在 shell 提示符下过得更轻松, 高效 在失去连接后恢复先前的会话 Stop pushing around that fiddly rodent! bash1 这是我的命令行提示符的设置。对于这个小的终端窗口来说，这或许有些长。但你可以根据你的喜好来调整它。 作为一个 Linux 用户, 你可能熟悉 shell (又名为命令行)。 或许你需要时不时的打开终端来完成那些不能在 GUI 下处理的必要任务，抑或是因为你处在一个将窗口铺满桌面的环境中，而 shell 是你与你的 linux 机器交互的主要方式。 在上面那些情况下，你可能正在使用你所使用的发行版本自带的 Bash 配置。 尽管对于大多数的任务而言，它足够好了，但它可以更加强大。 在本教程中，我们将向你展示如何使得你的 shell 提供更多有用信息、更加实用且更适合工作。 我们将对提示符进行自定义，让它比默认情况下提供更好的反馈，并向你展示如何使用炫酷的 tmux 工具来管理会话并同时运行多个程序。 并且，为了让眼睛舒服一点，我们还将关注配色方案。那么，进击吧，少女！ 让提示符更美妙大多数的发行版本配置有一个非常简单的提示符，它们大多向你展示了一些基本信息， 但提示符可以为你提供更多的内容。例如，在 Debian 7 下，默认的提示符是这样的: mike@somebox:~$ 上面的提示符展示出了用户、主机名、当前目录和账户类型符号（假如你切换到 root 账户， $ 会变为 #)。 那这些信息是在哪里存储的呢? 答案是：在 PS1 环境变量中。 假如你键入 echo $PS1 ， 你将会在这个命令的输出字符串的最后有如下的字符： \\u@\\h:\\w$ 这看起来有一些丑陋，并在瞥见它的第一眼时，你可能会开始尖叫，认为它是令人恐惧的正则表达式，但我们不打算用这些复杂的字符来煎熬我们的大脑。这不是正则表达式，这里的斜杠是转义序列，它告诉提示符进行一些特别的处理。 例如，上面的 u 部分，告诉提示符展示用户名， 而 w 则展示工作路径. 下面是一些你可以在提示符中用到的字符的列表: d 当前的日期 h 主机名 n 代表换行的字符 A 当前的时间 (HH: MM) u 当前的用户 w (小写) 整个工作路径的全称 W (大写) 工作路径的简短名称 $ 一个提示符号，对于 root 用户为 # 号 ! 当前命令在 shell 历史记录中的序号 下面解释 w 和 W 选项的区别: 对于前者，你将看到你所在的工作路径的完整地址，（例如 /usr/local/bin），而对于后者， 它则只显示 bin 这一部分。 现在，我们该怎样改变提示符呢? 你需要更改 PS1 环境变量的内容，试试下面这个： export PS1=&quot;I am \\u and it is \\A $&quot; 现在，你的提示符将会像下面这样： I am mike and it is 11:26 $ 从这个例子出发，你就可以按照你的想法来试验一下上面列出的其他转义序列。 但等等 – 当你登出后，你的这些努力都将消失，因为在你每次打开终端时，PS1 环境变量的值都会被重置。解决这个问题的最简单方式是打开 .bashrc 配置文件（在你的家目录下） 并在这个文件的最下方添加上完整的 export 命令。在每次你启动一个新的 shell 会话时，这个 .bashrc 会被 Bash 读取, 所以你的加强的提示符就可以一直出现。你还可以使用额外的颜色来装扮提示符。刚开始，这将有点棘手，因为你必须使用一些相当奇怪的转义序列，但结果是非常漂亮的。 将下面的字符添加到你的 PS1字符串中的某个位置，最终这将把文本变为红色： \\[\\e[31m\\] 你可以将这里的 31 更改为其他的数字来获得不同的颜色: 30 黑色 32 绿色 33 黄色 34 蓝色 35 洋红色 36 青色 37 白色 所以，让我们使用先前看到的转义序列和颜色来创造一个提示符，以此来结束这一小节的内容。深吸一口气, 弯曲你的手指，然后键入下面这只“野兽”： export PS1=&quot;(\\!) \\[\\e[31m\\] \\[\\A\\] \\[\\e[32m\\]\\u@\\h \\[\\e[34m\\]\\w \\[\\e[30m\\]$&quot; 上面的命令提供了一个 Bash 命令历史序号、当前的时间、彩色的用户或主机名组合、以及工作路径。假如你“野心勃勃”，利用一些惊人的组合，你还可以更改提示符的背景色和前景色。非常有用的 Arch wiki 有一个关于颜色代码的完整列表：http://tinyurl.com/3gvz4ec。 Shell 精要 假如你是一个彻底的 Linux 新手并第一次阅读这份杂志，或许你会发觉阅读这些教程有些吃力。 所以这里有一些基础知识来让你熟悉一些 shell。 通常在你的菜单中， shell 指的是 Terminal、 XTerm 或 Konsole， 当你启动它后， 最为实用的命令有这些： ls (列出文件名); cp one.txt two.txt (复制文件); rm file.txt (移除文件); mv old.txt new.txt (移动或重命名文件); cd /some/directory (改变目录); cd .. (回到上级目录); ./program (在当前目录下运行一个程序); ls &gt; list.txt (重定向输出到一个文件)。 几乎每个命令都有一个手册页用来解释其选项（例如 man ls – 按 Q 来退出）。在那里，你可以知晓命令的选项，这样你就知道 ls -la 展示一个详细的列表，其中也列出了隐藏文件， 并且在键入一个文件或目录的名字的一部分后， 可以使用 Tab 键来自动补全。 Tmux: 针对 shell 的窗口管理器在文本模式的环境中使用一个窗口管理器 – 这听起来有点不可思议， 是吧？ 然而，你应该记得当 Web 浏览器第一次实现分页浏览的时候吧？ 在当时， 这是在可用性上的一个重大进步，它减少了桌面任务栏的杂乱无章和繁多的窗口列表。 对于你的浏览器来说，你只需要一个按钮便可以在浏览器中切换到你打开的每个单独网站， 而不是针对每个网站都有一个任务栏或导航图标。 这个功能非常有意义。 若有时你同时运行着几个虚拟终端，你便会遇到相似的情况； 在这些终端之间跳转，或每次在任务栏或窗口列表中找到你所需要的那一个终端，都可能会让你觉得麻烦。 拥有一个文本模式的窗口管理器不仅可以让你像在同一个终端窗口中运行多个 shell 会话，而且你甚至还可以将这些窗口排列在一起。 另外，这样还有另一个好处：可以将这些窗口进行分离和重新连接。想要看看这是如何运行的最好方式是自己尝试一下。在一个终端窗口中，输入 screen （在大多数发行版本中，它已经默认安装了或者可以在软件包仓库中找到）。 某些欢迎的文字将会出现 – 只需敲击 Enter 键这些文字就会消失。 现在运行一个交互式的文本模式的程序，例如 nano ， 并关闭这个终端窗口。 在一个正常的 shell 对话中， 关闭窗口将会终止所有在该终端中运行的进程 – 所以刚才的 Nano 编辑对话也就被终止了， 但对于 screen 来说，并不是这样的。打开一个新的终端并输入如下命令： screen -r 瞧，你刚开打开的 Nano 会话又回来了！ 当刚才你运行 screen 时， 它会创建了一个新的独立的 shell 会话， 它不与某个特定的终端窗口绑定在一起，所以可以在后面被分离并重新连接（即 -r 选项）。 当你正使用 SSH 去连接另一台机器并做着某些工作时， 但并不想因为一个脆弱的连接而影响你的进度，这个方法尤其有用。假如你在一个 screen 会话中做着某些工作，并且你的连接突然中断了（或者你的笔记本没电了，又或者你的电脑报废了——不是这么悲催吧），你只需重新连接或给电脑充电或重新买一台电脑，接着运行 screen -r 来重新连接到远程的电脑，并在刚才掉线的地方接着开始。 现在，我们都一直在讨论 GNU 的 screen，但这个小节的标题提到的是 tmux。 实质上， tmux （terminal multiplexer） 就像是 screen 的一个进阶版本，带有许多有用的额外功能，所以现在我们开始关注 tmux。 某些发行版本默认包含了 tmux； 在其他的发行版本上，通常只需要一个 apt-get、 yum install 或 pacman -S 命令便可以安装它。 一旦你安装了它过后，键入 tmux 来启动它。接着你将注意到，在终端窗口的底部有一条绿色的信息栏，它非常像传统的窗口管理器中的任务栏： 上面显示着一个运行着的程序的列表、机器的主机名、当前时间和日期。 现在运行一个程序，同样以 Nano 为例， 敲击 Ctrl+B 后接着按 C 键， 这将在 tmux 会话中创建一个新的窗口，你便可以在终端的底部的任务栏中看到如下的信息: 0:nano- 1:bash* 每一个窗口都有一个数字，当前呈现的程序被一个星号所标记。 Ctrl+B 是与 tmux 交互的标准方式， 所以若你敲击这个按键组合并带上一个窗口序号， 那么就会切换到对应的那个窗口。你也可以使用 Ctrl+B 再加上 N 或 P 来分别切换到下一个或上一个窗口 – 或者使用 Ctrl+B 加上 L 来在最近使用的两个窗口之间来进行切换（有点类似于桌面中的经典的 Alt+Tab 组合键的效果）。 若需要知道窗口列表，使用 Ctrl+B 再加上 W。 目前为止，一切都还好：现在你可以在一个单独的终端窗口中运行多个程序，避免混乱（尤其是当你经常与同一个远程主机保持多个 SSH 连接时）。 当想同时看两个程序又该怎么办呢？ 针对这种情况， 可以使用 tmux 中的窗格。 敲击 Ctrl+B 再加上 % ， 则当前窗口将分为两个部分：一个在左一个在右。你可以使用 Ctrl+B 再加上 O 来在这两个部分之间切换。 这尤其在你想同时看两个东西时非常实用， – 例如一个窗格看指导手册，另一个窗格里用编辑器看一个配置文件。 有时，你想对一个单独的窗格进行缩放，而这需要一定的技巧。 首先你需要敲击 Ctrl+B 再加上一个 :（冒号），这将使得位于底部的 tmux 栏变为深橙色。 现在，你进入了命令模式，在这里你可以输入命令来操作 tmux。 输入 resize-pane -R 来使当前窗格向右移动一个字符的间距， 或使用 -L 来向左移动。 对于一个简单的操作，这些命令似乎有些长，但请注意，在 tmux 的命令模式（前面提到的一个分号开始的模式）下，可以使用 Tab 键来补全命令。 另外需要提及的是， tmux 同样也有一个命令历史记录，所以若你想重复刚才的缩放操作，可以先敲击 Ctrl+B 再跟上一个分号，并使用向上的箭头来取回刚才输入的命令。 最后，让我们看一下分离和重新连接 - 即我们刚才介绍的 screen 的特色功能。 在 tmux 中，敲击 Ctrl+B 再加上 D 来从当前的终端窗口中分离当前的 tmux 会话。这使得这个会话的一切工作都在后台中运行、使用 tmux a 可以再重新连接到刚才的会话。但若你同时有多个 tmux 会话在运行时，又该怎么办呢? 我们可以使用下面的命令来列出它们： tmux ls 这个命令将为每个会话分配一个序号； 假如你想重新连接到会话 1， 可以使用 tmux a -t 1 .tmux 是可以高度定制的，你可以自定义按键绑定并更改配色方案， 所以一旦你适应了它的主要功能，请钻研指导手册以了解更多的内容。 tmux 上图中， tmux 开启了两个窗格： 左边是 Vim 正在编辑一个配置文件，而右边则展示着指导手册页。 Zsh: 另一个 shell 选择是好的，但标准同样重要。 你要知道几乎每个主流的 Linux 发行版本都默认使用 Bash shell – 尽管还存在其他的 shell。 Bash 为你提供了一个 shell 能够给你提供的几乎任何功能，包括命令历史记录，文件名补全和许多脚本编程的能力。它成熟、可靠并文档丰富 – 但它不是你唯一的选择。 许多高级用户热衷于 Zsh， 即 Z shell。 这是 Bash 的一个替代品并提供了 Bash 的几乎所有功能，另外还提供了一些额外的功能。 例如， 在 Zsh 中，你输入 ls ，并敲击 Tab 键可以得到 ls 可用的各种不同选项的一个大致描述。 而不需要再打开 man page 了！ Zsh 还支持其他强大的自动补全功能： 例如，输入 cd /u/lo/bi 再敲击 Tab 键， 则完整的路径名 /usr/local/bin 就会出现（这里假设没有其他的路径包含 u, lo 和 bi 等字符）。 或者只输入 cd 再跟上 Tab 键，则你将看到着色后的路径名的列表 – 这比 Bash 给出的简单的结果好看得多。 Zsh 在大多数的主要发行版本上都可以得到了； 安装它后并输入 zsh 便可启动它。 要将你的默认 shell 从 Bash 改为 Zsh， 可以使用 chsh 命令。 若需了解更多的信息，请访问 www.zsh.org。 “未来”的终端你或许会好奇为什么包含你的命令行提示符的应用被叫做终端。 这需要追溯到 Unix 的早期， 那时人们一般工作在一个多用户的机器上，这个巨大的电脑主机将占据一座建筑中的一个房间， 人们通过某些线路，使用屏幕和键盘来连接到这个主机， 这些终端机通常被称为“哑终端”， 因为它们不能靠自己做任何重要的执行任务 – 它们只展示通过线路从主机传来的信息，并输送回从键盘的敲击中得到的输入信息。 今天，我们在自己的机器上执行几乎所有的实际操作，所以我们的电脑不是传统意义下的终端，这就是为什么诸如 XTerm、 Gnome Terminal、 Konsole 等程序被称为“终端模拟器” 的原因 – 他们提供了同昔日的物理终端一样的功能。事实上，在许多方面它们并没有改变多少。诚然，现在我们有了反锯齿字体，更好的颜色和点击网址的能力，但总的来说，几十年来我们一直以同样的方式在工作。 所以某些程序员正尝试改变这个状况。 Terminology (http://tinyurl.com/osopjv9)， 它来自于超级时髦的 Enlightenment 窗口管理器背后的团队，旨在让终端步入到 21 世纪，例如带有在线媒体显示功能。你可以在一个充满图片的目录里输入 ls 命令，便可以看到它们的缩略图，或甚至可以直接在你的终端里播放视频。 这使得一个终端有点类似于一个文件管理器，意味着你可以快速地检查媒体文件的内容而不必用另一个应用来打开它们。 接着还有 Xiki (www.xiki.org)，它自身的描述为“命令的革新”。它就像是一个传统的 shell、一个 GUI 和一个 wiki 之间的过渡；你可以在任何地方输入命令，并在后面将它们的输出存储为笔记以作为参考，并可以创建非常强大的自定义命令。用几句话是很能描述它的，所以作者们已经创作了一个视频来展示它的潜力是多么的巨大(请看 Xiki 网站的截屏视频部分)。 并且 Xiki 绝不是那种在几个月之内就消亡的昙花一现的项目，作者们成功地进行了一次 Kickstarter 众筹，在七月底已募集到超过 $84, 000。 是的, 你没有看错 – $84K 来支持一个终端模拟器。这可能是最不寻常的集资活动了，因为某些疯狂的家伙已经决定开始创办它们自己的 Linux 杂志 …… 下一代终端许多命令行和基于文本的程序在功能上与它们的 GUI 程序是相同的，并且常常更加快速和高效。我们的推荐有：Irssi (IRC 客户端); Mutt (mail 客户端); rTorrent (BitTorrent); Ranger (文件管理器); htop (进程监视器)。 若给定在终端的限制下来进行 Web 浏览， Elinks 确实做的很好，并且对于阅读那些以文字为主的网站例如 Wikipedia 来说。它非常实用。 微调配色方案 在《Linux Voice》杂志社中，我们并不迷恋那些养眼的东西，但当你每天花费几个小时盯着屏幕看东西时，我们确实认识到美学的重要性。我们中的许多人都喜欢调整我们的桌面和窗口管理器来达到完美的效果，调整阴影效果、摆弄不同的配色方案，直到我们 100% 的满意（然后出于习惯, 摆弄更多的东西）。 但我们倾向于忽视终端窗口，它理应也获得我们的喜爱，并且在 http://ciembor.github.io/4bit 你将看到一个极其棒的配色方案设计器，对于所有受欢迎的终端模拟器（XTerm, Gnome Terminal, Konsole 和 Xfce4 Terminal 等都是支持的应用。），它可以输出其设定。移动滑块直到你看到配色方案最佳， 然后点击位于该页面右上角的 得到方案 按钮。 相似的，假如你在一个文本编辑器，如 Vim 或 Emacs 上花费了很多的时间，使用一个精心设计的调色板也是非常值得的。 Solarized http://ethanschoonover.com/solarized 是一个卓越的方案，它不仅漂亮，而且因追求最大的可用性而设计，在其背后有着大量的研究和测试。 via: http://www.linuxvoice.com/linux-101-power-up-your-shell-8/publish: https://linux.cn/article-5910-1.html 作者：Ben Everard译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"终端","slug":"终端","permalink":"https://fsslc.github.io/tags/%E7%BB%88%E7%AB%AF/"},{"name":"shell","slug":"shell","permalink":"https://fsslc.github.io/tags/shell/"},{"name":"tmux","slug":"tmux","permalink":"https://fsslc.github.io/tags/tmux/"}]},{"title":"[翻译] 使用这些去重加密工具来备份你的数据","date":"2015-07-26T02:53:47.000Z","path":"2015/07/26/Translate-Backup-with-these-DeDuplicating-Encryption-Tools/","text":"介绍 6 个去重加密备份工具。 无论是体积还是价值，数据都在不断增长。快速而可靠地备份和恢复数据正变得越来越重要。社会已经适应了技术的广泛使用，并懂得了如何依靠电脑和移动设备，但很少有人能够面对丢失重要数据的现实。在遭受数据损失的公司中，30% 的公司将在一年内损失一半市值，70% 的公司将在五年内停止交易。这更加凸显了数据的价值。 随着数据在体积上的增长，提高存储利用率尤为重要。从计算机的角度说，数据去重是一种特别的数据压缩技术，因为它可以消除重复数据的拷贝，所以这个技术可以提高存储利用率。 数据并不仅仅只有其创造者感兴趣。政府、竞争者、犯罪分子、偷窥者可能都热衷于获取你的数据。他们或许想偷取你的数据，从你那里进行敲诈，或看你正在做什么。因此，对于保护你的数据，加密是非常必要的。 所以，解决方法是我们需要一个可以去重的加密备份软件。 对于所有的用户而言，做文件备份是一件非常必要的事，至今为止许多用户还没有采取足够的措施来保护他们的数据。一台电脑不论是工作在一个合作的环境中，还是供私人使用，机器的硬盘可能在没有任何警告的情况下挂掉。另外，有些数据丢失可能是人为的错误所引发的。如果没有做经常性的备份，数据也可能不可避免地丢失，即使请了专业的数据恢复公司来帮忙。 这篇文章将对 6 个去重加密备份工具进行简要的介绍。 AtticAttic 是一个可用于去重、加密，验证完整性的压缩备份程序，它是用 Python 写的。Attic 的主要目标是提供一个高效且安全的方式来备份数据。Attic 使用的数据去重技术使得它适用于每日备份，因为只需存储改变的数据。 其特点有: 易用 可高效利用存储空间，通过检查冗余的数据，对可变块大小的去重可以减少存储所用的空间 可选的数据加密，使用 256 位的 AES 加密算法。数据的完整性和可靠性使用 HMAC-SHA256 来校验 使用 SDSH 来进行离线备份 备份可作为文件系统来挂载 网站: attic-backup.org BorgBorg 是 Attic 的一个分支。它是一个安全的开源备份程序，被设计用来高效地存储那些新的或修改过的数据。 Borg 的主要目标是提供一个高效、安全的方式来存储数据。Borg 使用的数据去重技术使得它适用于每日备份，因为只需存储改变的数据。认证加密使得它适用于存储在不完全可信的位置。 Borg 由 Python 写成。Borg 于 2015 年 5 月被创造出来，是为了解决让新的代码或重大的改变带入 Attic 的困难。 其特点包括: 易用 可高效利用存储空间，通过检查冗余的数据，对可变块大小的去重被用来减少存储所用的空间 可选的数据加密，使用 256 位的 AES 加密算法。数据的完整性和可靠性使用 HMAC-SHA256 来校验 使用 SDSH 来进行离线备份 备份可作为文件系统来挂载 Borg 与 Attic 不兼容。 网站: borgbackup.github.io/borgbackup ObnamObnam (OBligatory NAMe) 是一个易用、安全的基于 Python 的备份程序。备份可被存储在本地硬盘或通过 SSH SFTP 协议存储到网上。若使用了备份服务器，它并不需要任何特殊的软件，只需要使用 SSH 即可。 Obnam 通过将数据分成数据块，并单独存储它们来达到去重的目的，每次通过增量备份来生成备份，每次备份的生成就像是一次新的快照，但事实上是真正的增量备份。Obnam 由 Lars Wirzenius 开发。 其特点有: 易用 快照备份 数据去重，跨文件，然后生成备份 可使用 GnuPG 来加密备份 向一个单独的仓库中备份多个客户端的数据 备份检查点 (创建一个保存点，以每 100MB 或其他容量) 包含多个选项来调整性能，包括调整 lru-size 或 upload-queue-size 支持 MD5 校验算法来识别重复的数据块 通过 SFTP 将备份存储到一个服务器上 同时支持 push(即在客户端上运行) 和 pull(即在服务器上运行) 网站: obnam.org DuplicityDuplicity 以 tar 文件格式增量备份文件和目录，并使用 GnuPG 来进行加密，同时将它们上传到远程(或本地)的文件服务器上。它可以使用 ssh/scp、本地文件获取、rsync、 ftp 和 Amazon S3 等来传递数据。 因为 duplicity 使用了 librsync， 增量存档可以高效地利用存储空间，且只记录自从上次备份依赖改变的那部分文件。由于该软件使用 GnuPG 来加密或对这些归档文件进行进行签名，这使得它们免于服务器的监视或修改。 当前 duplicity 支持备份删除的文件，全部的 unix 权限，目录，符号链接， fifo 等。 duplicity 软件包还包含有 rdiffdir 工具。 Rdiffdir 是 librsync 的 rdiff 针对目录的扩展。它可以用来生成对目录的签名和差异，对普通文件也有效。 其特点有: 使用简单 对归档进行加密和签名(使用 GnuPG) 高效使用带宽和存储空间，使用 rsync 的算法 标准的文件格式 可选择多种远程协议 本地存储 scp/ssh ftp rsync HSI WebDAV Amazon S3 网站: duplicity.nongnu.org ZBackupZBackup 是一个通用的全局去重备份工具。 其特点包括: 对存储数据并行进行 LZMA 或 LZO 压缩，在一个仓库中，你还可以混合使用 LZMA 和 LZO 内置对存储数据的 AES 加密 能够删除旧的备份数据 可以使用 64 位的滚动哈希算法，使得文件冲突的数量几乎为零 仓库中存储的文件是不可修改的，已备份的文件不会被修改。 用 C++ 写成，只需少量的库文件依赖 在生成环境中可以安全使用 可以在不同仓库中进行数据交换而不必再进行压缩 使用 64 位改进型 Rabin-Karp 滚动哈希算法 网站: zbackup.org bupbup 是一个用 Python 写的备份程序，其名称是 “backup” 的缩写。基于 git packfile 文件格式， bup 提供了一个高效的方式来备份一个系统，提供快速的增量备份和全局去重(在文件中或文件里，甚至包括虚拟机镜像)。 bup 在 LGPL 版本 2 协议下发行。 其特点包括: 全局去重 (在文件之间或文件内部，甚至包括虚拟机镜像) 使用一个滚动的校验和算法(类似于 rsync) 来将大文件分为多个数据块 使用来自 git 的 packfile 文件格式 直接写入 packfile 文件，以此提供快速的增量备份 可以使用 “par2” 冗余来恢复冲突的备份 可以作为一个 FUSE 文件系统来挂载你的 bup 仓库 网站: bup.github.io via: http://www.linuxlinks.com/article/20150628060000607/BackupTools.htmlpublish: https://linux.cn/article-5887-1.html 译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"备份工具","slug":"备份工具","permalink":"https://fsslc.github.io/tags/%E5%A4%87%E4%BB%BD%E5%B7%A5%E5%85%B7/"},{"name":"加密","slug":"加密","permalink":"https://fsslc.github.io/tags/%E5%8A%A0%E5%AF%86/"}]},{"title":"[翻译] lolcat ：一个在 Linux 终端中输出彩虹特效的命令行工具","date":"2015-07-13T00:34:55.000Z","path":"2015/07/13/Translate-Lolcat-A-Command-Line-Tool-to-Output-Rainbow-Of-Colors-in-Linux-Terminal/","text":"那些相信 Linux 命令行是单调无聊且没有任何乐趣的人们，你们错了，这里有一些有关 Linux 的文章, 它们展示着 Linux 是如何的有趣和“淘气” 。 Linux命令及Linux终端的20个趣事 终端中的乐趣：6个有趣的Linux命令行工具 Linux终端的乐趣之把玩字词计数 在本文中，我将讨论一个名为“lolcat”的小工具 – 它可以在终端中生成彩虹般的颜色。 为终端生成彩虹般颜色的输出的 Lolcat 命令 何为 lolcat ?Lolcat 是一个针对 Linux，BSD 和 OSX 平台的工具，它类似于 cat 命令，并为 cat 的输出添加彩虹般的色彩。 Lolcat 主要用于在 Linux 终端中为文本添加彩虹般的色彩。 在 Linux 中安装 Lolcat1. Lolcat 工具在许多 Linux 发行版的软件仓库中都可获取到，但可获得的版本都有些陈旧，而你可以通过 git 仓库下载和安装最新版本的 lolcat。 由于 Lolcat 是一个 ruby gem 程序，所以在你的系统中必须安装有最新版本的 RUBY。 # apt-get install ruby [在基于 APT 的系统中] # yum install ruby [在基于 Yum 的系统中] # dnf install ruby [在基于 DNF 的系统中] 一旦 ruby 软件包安装成功，请确保验证安装的 ruby 的版本。 # ruby --version ruby 2.1.5p273 (2014-11-13) [x86_64-linux-gnu] 2. 接着使用下面的命令来从 lolcat 的 git 仓库中下载和安装最新版本的 lolcat。 # wget https://github.com/busyloop/lolcat/archive/master.zip # unzip master.zip # cd lolcat-master/bin # gem install lolcat 一旦 lolcat 安装后，你可以检查它的版本号。 # lolcat --version lolcat 42.0.99 (c)2011 moe@busyloop.net Lolcat 的用法3. 在开始使用 lolcat 之前，使用下面的命令来了解它可用的选项和其帮助文档。 # lolcat -h Lolcat 的帮助文档 4. 接着, 通过管道连接 lolcat 和其他命令，例如 ps, date 和 cal: # ps | lolcat # date | lolcat # cal | lolcat ps 命令的输出 Date 的输出 Calendar 的输出 5. 使用 lolcat 来展示一个脚本文件的代码: # lolcat test.sh 用 lolcat 来展示代码 6. 通过管道连接 lolcat 和 figlet 命令。Figlet 是一个展示由常规的屏幕字符组成的巨大字符串的应用。我们可以通过管道将 figlet 的输出连接到 lolcat 中来展示出如下的多彩输出: # echo I ❤ Tecmint | lolcat # figlet I Love Tecmint | lolcat 多彩的文字 注: 注意， ❤ 是一个 unicode 字符。要安装 figlet，你需要像下面那样使用 yum 和 apt 来得到这个软件包: # apt-get figlet # yum install figlet # dnf install figlet 7. 给文本赋予彩虹颜色的动画: $ echo I ❤ Tecmit | lolcat -a -d 500 动的文本 这里选项 -a 指的是 Animation(动画)， -d 指的是 duration(持续时间)。在上面的例子中，持续 500 次动画。 8. 在彩虹般的颜色下阅读 man 页(例如 man ls ): 动的文本 # man ls | lolcat 多彩地显示文件 9. 通过管道连接 lolcat 和 cowsay。cowsay 是一个可配置的正在思考或说话的奶牛，这个程序也支持其他的动物。 使用下面的命令来安装 cowsay : # apt-get cowsay # yum install cowsay # dnf install cowsay 安装后，使用下面的命令来显示在 cowsay 中的所有动物： # cowsay -l 样例输出 Cow files in /usr/share/cowsay/cows: apt beavis.zen bong bud-frogs bunny calvin cheese cock cower daemon default dragon dragon-and-cow duck elephant elephant-in-snake eyes flaming-sheep ghostbusters gnu head-in hellokitty kiss kitty koala kosh luke-koala mech-and-cow meow milk moofasa moose mutilated pony pony-smaller ren sheep skeleton snowman sodomized-sheep stegosaurus stimpy suse three-eyes turkey turtle tux unipony unipony-smaller vader vader-koala www 通过管道连接 lolcat 和 cowsay 后的输出，并且使用了‘gnu’形象的 cowfile。 # cowsay -f gnu ☛ Tecmint ☚ is the best Linux Resource Available online | lolcat 使用 Lolcat 的 Cowsay 注: 你可以在将 lolcat 和其他任何命令用管道连接起来在终端中得到彩色的输出。 10. 你可以为最常用的命令创建别名来使得命令的输出呈现出彩虹般的色彩。你可以像下面那样为 ‘ls -l‘ 命令创建别名，这个命令输出一个目录中包含内容的列表。 # alias lolls=&quot;ls -l | lolcat&quot; # lolls 多彩的 Alias 命令 你可以像上面建议的那样，为任何命令创建别名。为了使得别名永久生效，你需要添加相关的代码(上面的代码是 ls -l 的别名) 到 ~/.bashrc 文件中，并登出后再重新登录来使得更改生效。 现在就是这些了。我想知道你是否曾经注意过 lolcat 这个工具？你是否喜欢这篇文章？欢迎在下面的评论环节中给出你的建议和反馈。喜欢并分享我们，帮助我们传播。 via: http://www.tecmint.com/lolcat-command-to-output-rainbow-of-colors-in-linux-terminal/publish: https://linux.cn/article-5798-1.html 作者：Avishek Kumar译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://fsslc.github.io/tags/Linux/"},{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"终端","slug":"终端","permalink":"https://fsslc.github.io/tags/%E7%BB%88%E7%AB%AF/"},{"name":"lolcat","slug":"lolcat","permalink":"https://fsslc.github.io/tags/lolcat/"}]},{"title":"[翻译] Sleuth Kit：一个用来分析磁盘映像和恢复文件的开源取证工具","date":"2015-05-30T14:24:23.000Z","path":"2015/05/30/Translate-Sleuth-Kit-Open-Source-Forensic-Tool-to-Analyze-Disk-Images-and-Recover-Files/","text":"SIFT 是一个由 SANS 公司提供的基于 Ubuntu 的取证发行版。它包含许多取证工具，如 Sleuth kit/Autopsy 。但 Sleuth kit/Autopsy 可以直接在 Ubuntu 或 Fedora 发行版本上直接安装，而不必下载 SIFT 的整个发行版本。 Sleuth Kit/Autopsy 是一个开源的电子取证调查工具，它可以用于从磁盘映像中恢复丢失的文件，以及为了特殊事件进行磁盘映像分析。 Autopsy 工具是 sleuth kit 的一个网页接口，支持 sleuth kit 的所有功能。这个工具在 Windows 和 Linux 平台下都可获取到。 安装 Sleuth kit首先，从 sleuthkit 的网站下载 Sleuth kit 软件。使用下面的命令在虚拟终端下使用 wget 命令来下载它，下图展示了这个过程。 # wget http://cznic.dl.sourceforge.net/project/sleuthkit/sleuthkit/4.1.3/sleuthkit-4.1.3.tar.gz 下载 Sleuth Kit 使用下面的命令解压 sleuthkit-4.1.3.tar.gz 并进入解压后的目录： # tar -xvzf sleuthkit-4.1.3.tar.gz 解压过程 在安装 sleuth kit 之前，运行下面的命令来执行所需的检查： #./configure configure 然后使用 Make 命令来编译 sleuth kit ： #make make 最后，使用下面的命令将它安装到 /usr/local 目录下： #make install 安装 安装 Autopsy 工具Sleuth kit 已经安装完毕，现在我们将为它安装 autopsy 界面。从 sleuthkit 的 autopsy 页面下载 Autopsy 软件。使用下面的命令在虚拟终端下使用 wget 命令来下载它，下图展示了这个过程。 # wget http://kaz.dl.sourceforge.net/project/autopsy/autopsy/2.24/autopsy-2.24.tar.gz Autpsy 的下载链接 使用下面的命令解压 autopsy-2.24.tar.gz 并进入解压后的目录： # tar -xvzf autopsy-2.24.tar.gz Autopsy 的解压 autopsy 的配置脚本将询问 NSRL (National Software Reference Library) 和 Evidence_Locker 文件夹的路径。 当弹窗问及 NSRL 时，输入 “n”，并在 /usr/local 目录下创建名为 Evidence_Locker 的文件夹。Autopsy 将在 Evidence_Locker 文件夹下存储配置文件，审计记录和输出文件。 #mkdir /usr/local/Evidence_Locker #cd autopsy-2.24 #./configure ![Autopsy 配置脚本](https://img.linux.net.cn/data/attachment/album/201505/30/222424k55u5ox5oku3hkzk.png 在安装过程中添加完 Evidence_Locker 的安装路径后， autopsy 在那里存储配置文件并展现如下的信息来运行 autopsy 程序。 启动 Autopsy 在虚拟终端中键入 ./autopsy 命令来启动 Sleuth kit 工具的图形界面： Autopsy 在浏览器中键入下面的地址来访问 autopsy 的界面： http://localhost:9999/autopsy 下图展现了 autopsy 插件的主页面： 主页 在 autopsy 工具中，点击 新案例 按钮来开始进行分析。键入案例名称，此次调查的描述和检查人的姓名，下图有具体的展示： 创建新事件 在接下来的网页中，将展示在上一个的网页中键入的详细信息。接着点击 增加主机 按钮来添加有关要分析的机器的详细信息。 增加主机 在下一个网页中键入主机名，相关的描述和要分析的机器的时区设置。 添加主机的详细信息 添加主机后，点击 增加映像 按钮来为取证分析添加映像文件。 添加映像 在接下来的网页中点击 增加映像文件 按钮。它将打开一个新的网页，来询问映像文件的路径和选择映像的类型以及导入的方法。 添加映像文件 正如下图中展示的那样，我们已经键入了 Linux 映像文件的路径。在我们这个例子中，映像文件类型是磁盘分区。 添加映像分区 点击“下一步”按钮并在下一页中选择 计算散列值 的选项，这在下图中有展示。它也将检测所给映像的文件系统类型。 映像和文件系统详情 下面的图片展示了静态分析之前映像文件的 MD5 散列值。 散列值 在下一个网页中， autopsy 展现了有关映像文件的如下信息： 映像的挂载点 映像的名称 所给映像的文件系统类型 点击 详情 按钮来获取更多有关所给映像文件的信息。它还提供了从映像文件的卷中导出未分配的片段和字符串的数据信息，这在下图中有展现。 映像的详细信息 在下图中那样，点击 分析 按钮来开始分析所给映像。它将开启另一个页面，其中包含了映像分析的多个选项。 分析 在映像分析过程中，Autopsy 提供了如下的功能： 文件分析 关键字搜索 文件类型 映像详情 数据单元 下图展示的是在给定的 Linux 分区映像上进行文件分析： 映像的分析 它将从所给映像中提取所有的文件和文件夹。在下图中也展示了已被删除的文件的提取： 已被删除的文件 结论希望这篇文章能够给那些进入磁盘映像静态分析领域的新手提供帮助。Autopsy 是 sleuth kit 的网页界面，提供了在 Windows 和 Linux 磁盘映像中进行诸如字符串提取，恢复被删文件，时间线分析，网络浏览历史，关键字搜索和邮件分析等功能。 via: http://linoxide.com/ubuntu-how-to/autopsy-sleuth-kit-installation-ubuntu/public: https://linux.cn/article-5541-1.html 作者：nido译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"取证工具","slug":"取证工具","permalink":"https://fsslc.github.io/tags/%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7/"}]},{"title":"[翻译] 如何在 Linux 中产生、加密或解密随机密码 ","date":"2015-05-22T05:47:55.000Z","path":"2015/05/22/Translate-How-to-Generate-or-Encrypt-or-Decrypt-Random-Passwords-in-Linux/","text":"介绍几款工具来生成随机密码 我们一直积极地提供有关 Linux 技巧的系列文章，如果你错过了这个系列的最新文章，你或许可以去访问下面的链接。 Linux 中 5 个有趣的命令行技巧 在这篇文章中，我们将分享一些有趣 Linux 技巧，内容是有关如何产生随机密码以及加密或解密这些经过加盐或没有加盐处理的密码。 安全是数字时代中的一个主要话题。在电脑，email，云端，手机，文档和其他的场合中，我们都会使用到密码。众所周知，选择密码的基本原则是 “易记，难猜”。考虑过使用基于机器自动生成的密码吗？相信我，Linux 非常擅长这方面的工作。 1. 使用命令 pwgen 来生成一个长度为 10 个字符的独特的随机密码。假如你还没有安装 pwgen，请使用 Apt 或 YUM 等包管理器来安装它。 $ pwgen 10 1 生成一个独特的随机密码 一口气生成若干组长度为 50 个字符的唯一的随机密码! $ pwgen 50 生成多组随机密码 2. 你还可以使用 makepasswd 来每次生成一个给定长度的独特的随机密码。在你把玩 makepasswd 命令之前，请确保你已经安装了它。如若没有安装它，试试使用 Apt 或 YUM 包管理器来安装 makepasswd 这个软件包。 生成一个长度为 10 个字符的随机密码。该命令产生的密码的长度默认为 10。 $ makepasswd 使用 makepasswd 生成独特的密码 生成一个长度为 50 个字符的随机密码。 $ makepasswd --char 50 生成长度为 50 的密码 生成 7 个长度为 20 个字符的随机密码。 $ makepasswd --char 20 --count 7 3. 使用带“盐”的 Crypt(注：这里应该指的是一个函数，可以参考这里 ) 来加密一个密码。提供手动或自动添加 “盐”。 对于那些不清楚 盐 的意义的人，这里的 “盐” 指的是一个随机数据，它作为密码生成函数的一个额外的输入， 目的是保护密码免受词典攻击。 在执行下面的操作前，请确保你已经安装了 mkpasswd 。 下面的命令将带 “盐” 加密一个密码。“盐” 的值是随机自动生成的。所以每次你运行下面的命令时，都将产生不同的输出，因为它每次接受了随机取值的 “盐”。 $ mkpasswd tecmint 使用 Crypt 来加密密码 现在让我们来手动定义 “盐” 的值。每次它将产生相同的结果。请注意你可以输入任何你想输入的值来作为 “盐” 的值。 $ mkpasswd tecmint -s tt 带“盐”加密密码 另外， mkpasswd 还是交互式的，假如你在命令中没有提供密码，它将主动询问你来输入密码。 4. 使用 aes-256-cbc 加密算法并使用带“盐”的密码(如 “tecmint”) 加密一个字符串(如 “Tecmint-is-a-Linux-Community”)。 # echo Tecmint-is-a-Linux-Community | openssl enc -aes-256-cbc -a -salt -pass pass:tecmint 在 Linux 中加密一个字符串 在上面例子中， echo 命令的输出通过管道传递给了 openssl 命令，使得该输出通过加密编码方式(enc：Encoding with Cipher ) 所加密，这个过程中使用了 aes-256-cbc 加密算法，并附带了密码 (tecmint) 和 “盐” 。 5. 使用 openssl 命令的 -aes-256-cbc 解密选项来解密上面的字符串。 # echo U2FsdGVkX18Zgoc+dfAdpIK58JbcEYFdJBPMINU91DKPeVVrU2k9oXWsgpvpdO/Z | openssl enc -aes-256-cbc -a -d -salt -pass pass:tecmint 在 Linux 中解密字符串 现在就是这些内容了。 保持联系，保持连接，敬请关注。不要忘了在下面的评论中提供给我们您有价值的反馈。 via: http://www.tecmint.com/generate-encrypt-decrypt-random-passwords-in-linux/publish: https://linux.cn/article-5486-1.html 作者：Avishek Kumar译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"密码生成","slug":"密码生成","permalink":"https://fsslc.github.io/tags/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90/"}]},{"title":"[翻译] 一大波你可能不知道的 Linux 网络工具 ","date":"2015-05-12T06:52:49.000Z","path":"2015/05/12/Translate-Bringing-a-Bunch-of-Best-Known-Linux-Network-Tools/","text":"介绍一大波的网络工具 如果要在你的系统上监控网络，那么使用命令行工具是非常实用的，并且对于 Linux 用户来说，有着许许多多现成的工具可以使用，如： nethogs, ntopng, nload, iftop, iptraf, bmon, slurm, tcptrack, cbm, netwatch, collectl, trafshow, cacti, etherape, ipband, jnettop, netspeed 以及 speedometer。 鉴于世上有着许多的 Linux 专家和开发者，显然还存在其他的网络监控工具，但在这篇教程中，我不打算将它们所有包括在内。 上面列出的工具都有着自己的独特之处，但归根结底，它们都做着监控网络流量的工作，只是通过各种不同的方法。例如 nethogs 可以被用来展示每个进程的带宽使用情况，以防你想知道究竟是哪个应用在消耗了你的整个网络资源； iftop 可以被用来展示每个套接字连接的带宽使用情况，而像 nload 这类的工具可以帮助你得到有关整个带宽的信息。 1) nethogsnethogs 是一个免费的工具，当要查找哪个 PID (注：即 process identifier，进程 ID) 给你的网络流量带来了麻烦时，它是非常方便的。它按每个进程来分组带宽，而不是像大多数的工具那样按照每个协议或每个子网来划分流量。它功能丰富，同时支持 IPv4 和 IPv6，并且我认为，若你想在你的 Linux 主机上确定哪个程序正消耗着你的全部带宽，它是来做这件事的最佳的程序。 一个 Linux 用户可以使用 nethogs 来显示每个进程的 TCP 下载和上传速率，可以使用命令 nethogs eth0 来监控一个指定的设备，上面的 eth0 是那个你想获取信息的设备的名称，你还可以得到有关正在传输的数据的传输速率信息。 对我而言， nethogs 是非常容易使用的，或许是因为我非常喜欢它，以至于我总是在我的 Ubuntu 12.04 LTS 机器中使用它来监控我的网络带宽。 例如要想使用混杂模式来嗅探，可以像下面展示的命令那样使用选项 -p： nethogs -p wlan0 假如你想更多地了解 nethogs 并深入探索它，那么请毫不犹豫地阅读我们做的关于这个网络带宽监控工具的整个教程。 （LCTT 译注：关于 nethogs 的更多信息可以参考：https://linux.cn/article-2808-1.html ） 2) nloadnload 是一个控制台应用，可以被用来实时地监控网络流量和带宽使用情况，它还通过提供两个简单易懂的图表来对流量进行可视化。这个绝妙的网络监控工具还可以在监控过程中切换被监控的设备，而这可以通过按左右箭头来完成。 network monitoring tools in linux 正如你在上面的截图中所看到的那样，由 nload 提供的图表是非常容易理解的。nload 提供了有用的信息，也展示了诸如被传输数据的总量和最小/最大网络速率等信息。 而更酷的是你只需要直接运行 nload 这个工具就行，这个命令是非常的短小且易记的： nload 我很确信的是：我们关于如何使用 nload 的详细教程将帮助到新的 Linux 用户，甚至可以帮助那些正寻找关于 nload 信息的老手。 （LCTT 译注：关于 nload 的更新信息可以参考：https://linux.cn/article-5114-1.html ） 3) slurmslurm 是另一个 Linux 网络负载监控工具，它以一个不错的 ASCII 图来显示结果，它还支持许多按键用以交互，例如 c 用来切换到经典模式， s 切换到分图模式， r 用来重绘屏幕， L 用来启用 TX/RX 灯（注：TX，发送流量；RX，接收流量） ，m 用来在经典分图模式和大图模式之间进行切换， q 退出 slurm。 linux network load monitoring tools 在网络负载监控工具 slurm 中，还有许多其它的按键可用，你可以很容易地使用下面的命令在 man 手册中学习它们。 man slurm slurm 在 Ubuntu 和 Debian 的官方软件仓库中可以找到，所以使用这些发行版本的用户可以像下面展示的那样，使用 apt-get 安装命令来轻松地下载它： sudo apt-get install slurm 我们已经在一个教程中对 slurm 的使用做了介绍，不要忘记和其它使用 Linux 的朋友分享这些知识。 4) iftop当你想显示连接到网卡上的各个主机的带宽使用情况时，iftop 是一个非常有用的工具。根据 man 手册，iftop 在一个指定的接口或在它可以找到的第一个接口（假如没有任何特殊情况，它应该是一个对外的接口）上监听网络流量，并且展示出一个表格来显示当前的一对主机间的带宽使用情况。 通过在虚拟终端中使用下面的命令，Ubuntu 和 Debian 用户可以在他们的机器中轻易地安装 iftop： sudo apt-get install iftop 在你的机器上，可以使用下面的命令通过 yum 来安装 iftop： yum -y install iftop （LCTT 译注：关于 nload 的更多信息请参考：https://linux.cn/article-1843-1.html ） 5) collectlcollectl 可以被用来收集描述当前系统状态的数据，并且它支持如下两种模式： 记录模式 回放模式 记录模式 允许从一个正在运行的系统中读取数据，然后将这些数据要么显示在终端中，要么写入一个或多个文件或一个套接字中。 回放模式 根据 man 手册，在这种模式下，数据从一个或多个由记录模式生成的数据文件中读取。 Ubuntu 和 Debian 用户可以在他们的机器上使用他们默认的包管理器来安装 colletcl。下面的命令将为他们做这个工作： sudo apt-get install collectl 还可以使用下面的命令来安装 collectl， 因为对于这些发行版本（注：这里指的是用 yum 作为包管理器的发行版本），在它们官方的软件仓库中也含有 collectl： yum install collectl （LCTT 译注：关于 collectl 的更多信息请参考： https://linux.cn/article-3154-1.html ） 6) NetstatNetstat 是一个用来监控传入和传出的网络数据包统计数据的接口统计数据命令行工具。它会显示 TCP 连接 (包括上传和下行)，路由表，及一系列的网络接口（网卡或者SDN接口）和网络协议统计数据。 Ubuntu 和 Debian 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netsta 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它： sudo apt-get install net-tools CentOS, Fedora, RHEL 用户可以在他们的机器上使用默认的包管理器来安装 netstat。Netstat 软件被包括在 net-tools 软件包中，并可以在 shell 或虚拟终端中运行下面的命令来安装它： yum install net-tools 运行下面的命令使用 Netstat 来轻松地监控网络数据包统计数据： netstat Netstat 更多的关于 netstat 的信息，我们可以简单地在 shell 或终端中键入 man netstat 来了解： man netstat man netstat （LCTT 译注：关于 netstat 的更多信息请参考：https://linux.cn/article-2434-1.html ） 7) Netloadnetload 命令只展示一个关于当前网络荷载和自从程序运行之后传输数据总的字节数目的简要报告，它没有更多的功能。它是 netdiag 软件的一部分。 我们可以在 fedora 中使用 yum 来安装 Netload，因为它在 fedora 的默认软件仓库中。但假如你运行的是 CentOS 或 RHEL，则我们需要安装 rpmforge 软件仓库。 # yum install netdiag Netload 是默认仓库中 netdiag 的一部分，我们可以轻易地使用下面的命令来利用 apt 包管理器安装 netdiag： $ sudo apt-get install netdiag 为了运行 netload，我们需要确保选择了一个正在工作的网络接口的名称，如 eth0, eh1, wlan0, mon0等，然后在 shell 或虚拟终端中运行下面的命令： $ netload wlan2 注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。 8) NagiosNagios 是一个领先且功能强大的开源监控系统，它使得网络或系统管理员可以在服务器的各种问题影响到服务器的主要事务之前，发现并解决这些问题。 有了 Nagios 系统，管理员便可以在一个单一的窗口中监控远程的 Linux 、Windows 系统、交换机、路由器和打印机等。它会显示出重要的警告并指出在你的网络或服务器中是否出现某些故障，这可以间接地帮助你在问题发生前就着手执行补救行动。 Nagios 有一个 web 界面，其中有一个图形化的活动监视器。通过浏览网页 http://localhost/nagios/ 或 http://localhost/nagios3/ 便可以登录到这个 web 界面。假如你在远程的机器上进行操作，请使用你的 IP 地址来替换 localhost，然后键入用户名和密码，我们便会看到如下图所展示的信息： 在 Chromium 浏览器中的 Nagios3 （LCTT 译注：关于 Nagios 的更多信息请参考：https://linux.cn/article-2436-1.html ） 9) EtherApeEtherApe 是一个针对 Unix 的图形化网络监控工具，它仿照了 etherman 软件。它支持链路层、IP 和 TCP 等模式，并支持以太网, FDDI, 令牌环, ISDN, PPP, SLIP 及 WLAN 设备等接口，以及一些封装格式。主机和连接随着流量和协议而改变其尺寸和颜色。它可以过滤要展示的流量，并可从一个文件或运行的网络中读取数据包。 在 CentOS、Fedora、RHEL 等 Linux 发行版本中安装 etherape 是一件容易的事，因为在它们的官方软件仓库中就可以找到 etherape。我们可以像下面展示的命令那样使用 yum 包管理器来安装它： yum install etherape 我们也可以使用下面的命令在 Ubuntu、Debian 及它们的衍生发行版本中使用 apt 包管理器来安装 EtherApe ： sudo apt-get install etherape 在 EtherApe 安装到你的系统之后，我们需要像下面那样以 root 权限来运行 etherape： sudo etherape 然后， etherape 的 图形用户界面 便会被执行。接着，在菜单上面的 捕捉 选项下，我们可以选择 模式(IP，链路层，TCP) 和 接口。一切设定完毕后，我们需要点击 开始 按钮。接着我们便会看到类似下面截图的东西： EtherApe 10) tcpflowtcpflow 是一个命令行工具，它可以捕捉 TCP 连接(流)的部分传输数据，并以一种方便协议分析或除错的方式来存储数据。它重构了实际的数据流并将每个流存储在不同的文件中，以备日后的分析。它能识别 TCP 序列号并可以正确地重构数据流，不管是在重发还是乱序发送状态下。 通过 apt 包管理器在 Ubuntu 、Debian 系统中安装 tcpflow 是很容易的，因为默认情况下在官方软件仓库中可以找到它。 $ sudo apt-get install tcpflow 我们可以使用下面的命令通过 yum 包管理器在 Fedora 、CentOS 、RHEL 及它们的衍生发行版本中安装 tcpflow： # yum install tcpflow 假如在软件仓库中没有找到它或不能通过 yum 包管理器来安装它，则我们需要像下面展示的那样从 http://pkgs.repoforge.org/tcpflow/ 上手动安装它： 假如你运行 64 位的 PC： # yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.x86_64.rpm 假如你运行 32 位的 PC： # yum install --nogpgcheck http://pkgs.repoforge.org/tcpflow/tcpflow-0.21-1.2.el6.rf.i686.rpm 我们可以使用 tcpflow 来捕捉全部或部分 tcp 流量，并以一种简单的方式把它们写到一个可读的文件中。下面的命令就可以完成这个事情，但我们需要在一个空目录中运行下面的命令，因为它将创建诸如 x.x.x.x.y-a.a.a.a.z 格式的文件，运行之后，只需按 Ctrl-C 便可停止这个命令。 $ sudo tcpflow -i eth0 port 8000 注意：请将上面的 eth0 替换为你想捕捉的网卡接口名称。 11) IPTrafIPTraf 是一个针对 Linux 平台的基于控制台的网络统计应用。它生成一系列的图形，如 TCP 连接的包/字节计数、接口信息和活动指示器、 TCP/UDP 流量故障以及局域网内设备的包/字节计数。 在默认的软件仓库中可以找到 IPTraf，所以我们可以使用下面的命令通过 apt 包管理器轻松地安装 IPTraf： $ sudo apt-get install iptraf 我们可以使用下面的命令通过 yum 包管理器轻松地安装 IPTraf： # yum install iptraf 我们需要以管理员权限来运行 IPTraf，并带有一个有效的网络接口名。这里，我们的网络接口名为 wlan2，所以我们使用 wlan2 来作为参数： $ sudo iptraf wlan2 IPTraf 开始通常的网络接口统计，键入： # iptraf -g 查看接口 eth0 的详细统计信息，使用： # iptraf -d eth0 查看接口 eth0 的 TCP 和 UDP 监控信息，使用： # iptraf -z eth0 查看接口 eth0 的包的大小和数目，使用： # iptraf -z eth0 注意: 请将上面的 eth0 替换为你的接口名称。你可以通过运行 ip link show 命令来检查你的接口。 （LCTT 译注：关于 iptraf 的更多详细信息请参考：https://linux.cn/article-5430-1.html ） 12) SpeedometerSpeedometer 是一个小巧且简单的工具，它只用来绘出一幅包含有通过某个给定端口的上行、下行流量的好看的图。 在默认的软件仓库中可以找到 Speedometer ，所以我们可以使用下面的命令通过 yum 包管理器轻松地安装 Speedometer： # yum install speedometer 我们可以使用下面的命令通过 apt 包管理器轻松地安装 Speedometer： $ sudo apt-get install speedometer Speedometer 可以简单地通过在 shell 或虚拟终端中执行下面的命令来运行： $ speedometer -r wlan2 -t wlan2 Speedometer 注：请将上面的 wlan2 替换为你想要使用的网络接口名称。 13) NetwatchNetwatch 是 netdiag 工具集里的一部分，它也显示当前主机和其他远程主机的连接情况，以及在每个连接中数据传输的速率。 我们可以使用 yum 在 fedora 中安装 Netwatch，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL ， 我们需要安装 rpmforge 软件仓库。 # yum install netwatch Netwatch 是 netdiag 的一部分，可以在默认的软件仓库中找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装 netdiag： $ sudo apt-get install netdiag 为了运行 netwatch， 我们需要在虚拟终端或 shell 中执行下面的命令： $ sudo netwatch -e wlan2 -nt Netwatch 注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。 14) TrafshowTrafshow 同 netwatch 和 pktstat 一样，可以报告当前活动的连接里使用的协议和每个连接中数据传输的速率。它可以使用 pcap 类型的过滤器来筛选出特定的连接。 我们可以使用 yum 在 fedora 中安装 trafshow ，因为它在 fedora 的默认软件仓库中。但若你正运行着 CentOS 或 RHEL ， 我们需要安装 rpmforge 软件仓库。 # yum install trafshow Trafshow 在默认仓库中可以找到，所以我们可以轻松地使用下面的命令来利用 apt 包管理器安装它： $ sudo apt-get install trafshow 为了使用 trafshow 来执行监控任务，我们需要在虚拟终端或 shell 中执行下面的命令： $ sudo trafshow -i wlan2 Trafshow 为了专门监控 tcp 连接，如下面一样添加上 tcp 参数： $ sudo trafshow -i wlan2 tcp Trafshow tcp 注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。 15) Vnstat与大多数的其他工具相比，Vnstat 有一点不同。实际上它运行着一个后台服务或守护进程，并时刻记录着传输数据的大小。另外，它可以被用来生成一个网络使用历史记录的报告。 我们需要开启 EPEL 软件仓库，然后运行 yum 包管理器来安装 vnstat。 # yum install vnstat Vnstat 在默认软件仓库中可以找到，所以我们可以使用下面的命令运行 apt 包管理器来安装它： $ sudo apt-get install vnstat 不带有任何选项运行 vnstat 将简单地展示出从该守护进程运行后数据传输的总量。 $ vnstat vnstat 为了实时地监控带宽使用情况，使用 ‘-l’ 选项(live 模式)。然后它将以一种非常精确的方式来展示上行和下行数据所使用的带宽总量，但不会显示任何有关主机连接或进程的内部细节。 $ vnstat -l Vnstat 实时模式 完成了上面的步骤后，按 Ctrl-C 来停止，这将会得到如下类型的输出： Vnstat 实时结果 16) tcptracktcptrack 可以展示 TCP 连接的状态，它在一个给定的网络端口上进行监听。tcptrack 监控它们的状态并展示出排序且不断更新的列表，包括来源/目标地址、带宽使用情况等信息，这与 top 命令的输出非常类似 。 鉴于 tcptrack 在软件仓库中，我们可以轻松地在 Debian、Ubuntu 系统中从软件仓库使用 apt 包管理器来安装 tcptrack。为此，我们需要在 shell 或虚拟终端中执行下面的命令： $ sudo apt-get install tcptrack 我们可以通过 yum 在 fedora 中安装它，因为它在 fedora 的默认软件仓库中。但若你运行着 CentOS 或 RHEL 系统，我们需要安装 rpmforge 软件仓库。为此，我们需要运行下面的命令： # wget http://apt.sw.be/redhat/el6/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm # rpm -Uvh rpmforge-release*rpm # yum install tcptrack 注：这里我们下载了 rpmforge-release 的当前最新版本，即 0.5.3-1，你总是可以从 rpmforge 软件仓库中下载其最新版本，并请在上面的命令中替换为你下载的版本。 tcptrack 需要以 root 权限或超级用户身份来运行。执行 tcptrack 时，我们需要带上要监视的网络接口 TCP 连接状况的接口名称。这里我们的接口名称为 wlan2，所以如下面这样使用： sudo tcptrack -i wlan2 tcptrack 假如你想监控特定的端口，则使用： # tcptrack -i wlan2 port 80 tcptrack port 80 请替换上面的 80 为你想要监控的端口号。注意： 请将上面的 wlan2 替换为你想使用的网络接口名称，假如你想通过扫描了解你的网络接口名称，可以在一个虚拟终端或 shell 中运行 ip link show 命令。 17) CBMCBM （ Color Bandwidth Meter） 可以展示出当前所有网络设备的流量使用情况。这个程序是如此的简单，以至于都可以从它的名称中看出其功能。CBM 的源代码和新版本可以在 http://www.isotton.com/utils/cbm/ 上找到。 鉴于 CBM 已经包含在软件仓库中，我们可以简单地使用 apt 包管理器从 Debian、Ubuntu 的软件仓库中安装 CBM。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令： $ sudo apt-get install cbm 我们只需使用下面展示的命令来在 shell 窗口或虚拟终端中运行 cbm： $ cbm Color Bandwidth Meter 18) bmonBmon （ Bandwidth Monitoring） ，是一个用于调试和实时监控带宽的工具。这个工具能够检索各种输入模块的统计数据。它提供了多种输出方式，包括一个基于 curses 库的界面，轻量级的HTML输出，以及 ASCII 输出格式。 bmon 可以在软件仓库中找到，所以我们可以通过使用 apt 包管理器来在 Debian、Ubuntu 中安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令： $ sudo apt-get install bmon 我们可以使用下面的命令来运行 bmon 以监视我们的网络状态： $ bmon bmon 19) tcpdumpTCPDump 是一个用于网络监控和数据获取的工具。它可以为我们节省很多的时间，并可用来调试网络或服务器的相关问题。它可以打印出在某个网络接口上与布尔表达式相匹配的数据包所包含的内容的一个描述。 tcpdump 可以在 Debian、Ubuntu 的默认软件仓库中找到，我们可以简单地以 sudo 权限使用 apt 包管理器来安装它。为此，我们需要在一个 shell 窗口或虚拟终端中运行下面的命令： $ sudo apt -get install tcpdump tcpdump 也可以在 Fedora、CentOS、RHEL 的软件仓库中找到。我们可以像下面一样通过 yum 包管理器来安装它： # yum install tcpdump tcpdump 需要以 root 权限或超级用户来运行，我们需要带上我们想要监控的 TCP 连接的网络接口名称来执行 tcpdump 。在这里，我们有 wlan2 这个网络接口，所以可以像下面这样使用： $ sudo tcpdump -i wlan2 tcpdump 假如你只想监视一个特定的端口，则可以运行下面的命令。下面是一个针对 80 端口(网络服务器)的例子： $ sudo tcpdump -i wlan2 &#39;port 80&#39; tcpdump port 20) ntopng[ntopng][20] 是 ntop 的下一代版本。它是一个用于展示网络使用情况的网络探头，在一定程度上它与 top 针对进程所做的工作类似。ntopng 基于 libpcap 并且它以可移植的方式被重写，以达到可以在每一个 Unix 平台 、 MacOSX 以及 Win32 上运行的目的。 为了在 Debian，Ubuntu 系统上安装 ntopng，首先我们需要安装 编译 ntopng 所需的依赖软件包。你可以通过在一个 shell 窗口或一个虚拟终端中运行下面的命令来安装它们： $ sudo apt-get install libpcap-dev libglib2.0-dev libgeoip-dev redis-server wget libxml2-dev build-essential checkinstall 现在，我们需要像下面一样针对我们的系统手动编译 ntopng ： $ sudo wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-1.1_6932.tgz/download $ sudo tar zxfv ntopng-1.1_6932.tgz $ sudo cd ntopng-1.1_6932 $ sudo ./configure $ sudo make $ sudo make install 这样，在你的 Debian 或 Ubuntu 系统上应该已经安装上了你编译的 ntopng 。 我们已经有了有关 ntopng 的使用方法的教程，它既可以在命令行也可以在 Web 界面中使用，我们可以前往这些教程来获得有关 ntopng 的知识。 结论在这篇文章中，我们介绍了一些在 Linux 下的网络负载监控工具，这对于系统管理员甚至是新手来说，都是很有帮助的。在这篇文章中介绍的每一个工具都具有其特点，不同的选项等，但最终它们都可以帮助你来监控你的网络流量。 via: http://linoxide.com/monitoring-2/network-monitoring-tools-linux/publish: https://linux.cn/article-5435-1.html 作者：Bobbin Zachariah译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"网络工具","slug":"网络工具","permalink":"https://fsslc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"}]},{"title":"[翻译] 只有几百个字节大小的国际象棋程序 ","date":"2015-04-25T10:40:45.000Z","path":"2015/04/25/Translate-Chess-in-a-Few-Bytes/","text":"介绍几款占用非常小的象棋游戏 当我在这里提到了 ZX81 电脑时，我已经暴露了我的年龄。ZX81 是一个由英国开发者（Sincilair 研究所）生产的家庭电脑，它拥有”高达” 1KB 的内存！上面的 1KB 并不是打印错误，这个家庭电脑确实只配置有 1KB 的板载内存。但这个内存大小上的限制并没有阻止爱好者制作种类繁多的软件。事实上，这个机器引发了一代编程奇才的出现，这让他们掌握了让程序在该机上运行起来的技能。这个机器可以通过一个 16 KB 的内存卡来进行升级，这就提供了更多的编程可能。但未经扩展的 1KB 机器仍然激励着编程者们发布卓越的软件。 1K ZX Chess 我最喜爱的 ZX81 游戏有： 模拟飞行（Flight Simulation）, 3D 版怪物迷宫（3D Monster Maze）, 小蜜蜂（Galaxians）, 以及最重要的 1K ZX Chess。 只有最后一个程序是为未扩展版的 ZX81 电脑设计的。事实上，David Horne 开发的 1K ZX Chess 只使用了仅仅 672 字节的 RAM（LCTT 译注：如果读者有兴趣，可以看看这里对该程序的代码及解释）。尽管如此，该游戏尽力去实现大多数的国际象棋规则，并提供了一个计算机虚拟对手。虽然一些重要的规则被忽略了（如：王车易位，兵的升变，和吃过路兵）（LCTT 译注：参考了这里和这里），但能够和人工智能相对抗，这仍然令人惊讶。这个游戏占据了我逝去的青春里的相当一部分。 1K ZX Chess 保持了在所有计算机上国际象棋的最小实现的地位长达 33 年之久，直到今年由 BootChess 打破了该记录，紧接着由 Toledo AtomChess 打破。这三个程序都没有实现所有的国际象棋规则，所以为了完整性，我介绍了我最喜爱的那些实现了所有国际象棋规则的极小的国际象棋。 Linux 有着一系列极其强大的国际象棋引擎，如 Stockfish, Critter, Togo II, Crafty, GNU Chess 和 Komodo 。 在这篇文章精选的国际象棋程序虽敌不过这些好的国际象棋程序，但它们展示了使用微不足道的代码库究竟可以实现多少东西。 Toledo Atomchess 你可能已经看到了大量有关 BootChess 新闻报道，这个只用 487 字节写就的国际象棋程序，一举打破了先前最小的国际象棋程序 1K ZX Chess 的记录。所以，Óscar Toledo Gutiérrez 挽起袖子自己编写了一个更加紧凑的国际象棋游戏。Toledo Atomchess 是仅有 481 字节的 x86 汇编代码，都能放到引导扇区里。 在难以置信的代码大小下，这个引擎实现了一个可玩的国际象棋游戏。 特点包括: 基本的棋子移动 用 ASCII 文本表现的棋盘 以代数形式来输入移动(注：如 D2D4) 3 层的搜索深度 显然，为了将这个国际象棋程序压缩到 481 字节中，作者必须做出某些牺牲，这些局限包括： 没有兵的升变 没有王车易位 没有吃过路兵 没有移动确认 该作者也使用 C，JavaScript 和 Java 来写这个国际象棋程序，每种实现都非常小。 网站: nanochess.org/chess6.html 开发者: Óscar Toledo Gutiérrez 协议: 非商业用途可免费使用 版本号: - BootChess BootChess 是一个国际象棋的极其小巧的计算机实现。这个程序被塞进到仅仅 487 字节里，并可运行在 Windows, Mac OS X 和 Linux 等操作系统。BootChess 的棋盘和棋子单独用文本表示，其中 P 代表兵， Q 用来代表王后，以及“点”代表空白格子。 特点包括: 象棋棋盘和用户输入的形象的文本表示 引导扇区大小（512 字节）的可玩的象棋游戏 只需 x86 bios 硬件引导程序（没有软件依赖） 所有主要的正规移动包括双兵开局 兵升变为王后(与 1k ZX Chess 相反) 名为 taxiMax &gt; minMax half-ply 的 CPU 人工智能 硬编码的西班牙白子开局 同样，它也存在一些重要的限制。这些遗漏的功能包括： 兵的低升变（升变为非王后的棋子） 吃过路兵 没有王车易位 3 次位置重复和局规则（注：下一步之前，同样的移动出现了两次；可以参考这里） 50 步移动和局规则（注：在连续的50个回合内，双方既没有棋子被吃掉，也没有兵被移动过，则和局；可以参考这里） 没有开放式和封闭式布局 一个或多个 minMAX/negaMax 全层人工智能 网站: www.pouet.net/prod.php?which=64962 开发者: Olivier “Baudsurfer/RSi” Poudade 协议: WTFPL v2 版本号: .02 Micro-Max Micro-Max 是一个用 133 行 C 语言写就的象棋源程序。 作者实现了一个 hash 变换表，该引擎检查输入移动的合法性，以及支持 FIDE（注： World Chess Federation 缩写，参见其官网） 的全部规则，除了低升变。 特点包括: 递归的 negamax 搜索 反夺的静态搜索 反夺规则的扩展 迭代深化 最佳移动优先的 排序 存储分数和最佳移动的 Hash 表 完整的 FIDE 规则（除了低位升变）和移动合法性检查 还有一个 1433个字符的较大版本，但允许你使用完整的 FIDE 规则的低升变。 网站: home.hccnet.nl/h.g.muller/max-src2.html 开发者: Harm Geert Muller 协议: The MIT License 版本号: 3.2 via: http://www.linuxlinks.com/article/20150222033906262/ChessBytes.htmlpublic: https://linux.cn/article-5329-1.html 作者：Frazer Kline译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"游戏","slug":"游戏","permalink":"https://fsslc.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"[翻译] 想找点激烈的游戏？那就试试这 13 款 Roguelike 游戏吧！","date":"2015-04-06T00:25:53.000Z","path":"2015/04/06/Translate-Intense-Gameplay-Try-these-13-Roguelike-games/","text":"介绍 13 款 Roguelike 类游戏 Roguelike 是角色扮演游戏的一个子类。从字面上看，它的意思是 “像 Rogue 的游戏”。Rogue 是一个关于地下城冒险的视频游戏，于 1980 年第一次发行，以极其上瘾而著称。这个游戏的目标是取得深藏于第 26 层的 “Amulet of Yendor”，再返回到顶层逃出生天。 Roguelike 的准确定义并不存在，但这类游戏通常具有下面的特点： 奇幻的叙事背景； 用程序产生关卡。游戏中的绝大多数场景在开始新的游戏时由游戏自动创建。这样做是为了鼓励玩家不断重玩; 回合制的地下城探险和战斗； 随机生成的基于贴片的图形环境； 随机发生战斗； 永久死亡 ：在游戏中，死亡真的存在，一旦你的角色死了，那就真的结束了； 高难度。 这篇文章精心挑选了一些可运行在 Linux 平台下的 roguelike 游戏。假如你喜欢激烈、易上瘾的游戏，可以尝试这 13 款游戏。不要因它们原始的画质而退缩，一旦你沉浸其中，你将很快忘记画面的简陋。所有的这些都可以免费下载，并且几乎所有的游戏都是在开源协议下发行的。 Dungeon Crawl Stone Soup Dungeon Crawl Stone Soup 是一个开源的，单用户角色扮演类的 roguelike 游戏，玩家要在遍布危险而充满敌意的怪兽的地下城中进行探险和寻找宝藏，并在任务中拯救传说中的神秘 Zot 宝珠。 Dungeon Crawl Stone Soup 是 Linley 开发的 Dungeon Crawl 游戏的延续。它是公开开发的，并邀请 Crawl 社区的人员来参与其中。 Dungeon Crawl 有着超棒且深层次的战术游戏环节，创新的魔法和信仰系统，以及数量宏大的和你战斗的怪兽。Crawl 也是最难以攻陷的 roguelike 游戏之一。当你最终在游戏中通关，将胜利宣言张贴在 rec.games.roguelike.misc 时，你才会知道这有多么令人骄傲！ 特点包括: 丰富多彩的、富含深层次战术的 roguelike 游戏； 手绘地图； 无数的金库； 漂亮的界面； 创新的魔法和信仰系统； 各种神灵，角色，物品和聪明的怪兽； 网站: crawl.develz.org 开发者: Stone Soup 开发小组 协议: Crawl General Public License 版本号: 0.15.2 Dwarf Fortress Dwarf Fortress 是一个单人魔幻游戏，与 NetHack 类似。你可以在一个随机生成的持久的世界中，控制一个矮人哨兵或一个冒险者。 这个游戏的特色有：三种游戏模式(矮人要塞，冒险者，传说模式)，一个独特的随机生成的世界(由地形，野生生物和传奇生物等组成)， 阴森的战斗机制以及各种邪恶鱼群。 特点包括： 在这个世界里，你想玩多久都可以。可以经历许多次游戏，记录历史事件，对更改进行跟踪等； 当你扮演的矮人在山群中寻找宝藏时，你可以对他们下达命令 用各种材料来手工制作珍宝、物品，并可以用贵重金属、宝石等来改进它们； 通过各种手段保护你自己，防御来自敌对文明的袭击； 支持贵族，他们会管理你的民众 让你的矮人高兴起来，了解他们工作和休闲时的想法； 不同的 Z 坐标可以使你在多个层级上建造你的堡垒。建立塔台或征服地下深处； 建立水闸来灌溉作物或用水淹没你的对手； 扮演一个探险者并进行探索，为荣誉而战或复仇 与以前的游戏中的对手相遇； 在你经过的旅途中营救小城里的人们； 没有繁琐的情节，只需要探索； 无缝连接的漫游游戏世界-总共达到 197376 x 197376 平方 -可以在区域地图上更快速地穿行； 接受小镇或文明社会的领导所委托的任务； 可以找到你以前的角色，以一个新的角色带上他们来一场新的冒险，或者直接重新激活并使用他们； 通过 Z 轴使得你可以在各个地下城的不同层级间和结构间平滑的上下移动来和对手战斗； 战斗模式是通过技巧、身体部位、搏斗、在不同区域间蓄势和躲避，体验流血、疼痛，恶心及其他感受； 一个动态的天气模型跟踪风，湿度及空气流动，以创造冷暖气流锋面、风、暴风雨雪； 超过 200 种岩石和矿物类型被引入到了游戏世界，它们被放置在合适的地理环境中； 通过可更改的文本文件来添加生物，武器，植物，金属和其他对象； 以 16 色(包括黑色)渲染的扩展 ASCII 字符集，以及 8 种背景颜色(包括黑色); 网站: www.bay12games.com/dwarves/ 开发者: Tarn Adams 协议: 免费软件 版本号: 0.40.19 Ancient Domains of Mystery Ancient Domains of Mystery (ADOM) 是一个 rogue-like 游戏，从 1994 年至今一直在不断开发。 它是一个包含复杂地下城的单用户游戏。你控制一个用种族、类别、属性、技巧和装备等描述的虚构角色。这个虚构角色正尝试着达到一个特定的目标（参考下面的介绍）并在一个困难的任务中取胜。为了完成任务，你必须在以前没有发现的隧道和地下城中探险，和丑陋的怪兽战斗，解开一系列遗忘的秘密，并找到宝藏。 在游戏期间，你在每次游戏时随机生成的各层地下城中探索。你也可能遇到某个特定的关卡，其中有着特定的挑战或者围绕某个特定主题而生成。 特点包括: 拥有上百个地点的巨大游戏世界，例如城堡、随机生成的地下城、主题寺庙、墓地、古代遗迹、塔台和其他名胜； 各种各样的种族（矮人、drakeling、雾精灵、hurthling、兽人、巨魔、ratling 等等）（LCTT注：种族信息可以参考这里 和丰富的职业（战士、 元素法师、 刺客、 混沌骑士，决斗士等等）带来无限的游戏乐趣； 上百个怪兽和物品，其中的许多带有随机的增强特性； 迫使你在对力量的欲望和对诅咒的恐惧之间进行权衡的腐败体系； 法术、祈祷、思想技艺、炼金术、手工艺和更多； 多样的任务和分支故事主线； 许多完全不同的结局，可能改变现实本身。 网站: www.adom.de 开发者: Thomas Biskup 协议: Postcardware 版本号: 1.20 Prelease 20 Tales of Maj’Eyal (ToME) Tales of Maj’Eyal (ToME) (注：中文译名为 马基埃亚尔的传说) 是一个免费、开源的 roguelike 角色扮演游戏，包含特色的战术回合制战役和先进角色构建。它作为运行在 T-Engine 4.0 中的一个模块而被创造。 现在处于王权世纪(Age of Ascendancy)，在长达一万年的冲突痛苦和混乱之后，我们所知的世界终于进入了一个相对和平的时期。 “魔法大爆裂（Spellblaze）” 留下的影响已经大为减缓, 大地的伤痕也慢慢地开始愈合。在薪火世纪（Age of Pyre）之后，各个文明也纷纷开始重建家园。(注：翻译来源于 这里) 特点包括: 适合于那些没有 rogueline 体验的玩家； 同时支持图形界面和 ASCII 模式； 某些角色拥有多达 40 种的能力； 天赋系统； 战役引擎； 在线的持久状态/成就追踪； IRC 聊天客户端； 可扩展，可修改； 充满激情的音乐； 可解锁新的种族，类别，起始点，游戏模式和特点等； 网站: te4.org 开发者: ToME 开发团队 协议: GNU GPL v3.0 版本号: 1.2.5 Cataclysm Dark Days Ahead Cataclysm 是一个开源的 “后末世” roguelike 游戏，背景设定在由怪兽和僵尸带来的毁灭性的瘟疫后虚构的新英格兰(New England) 乡村。它是 Whale 开发的原有 Cataclysm 的继续，拓展了更多新的生物，建筑，游戏机制和其他特点。 尽管有些人描述它为一个 “僵尸游戏”，但 Cataclysm 远比一个“僵尸游戏”包含更多内容。玩家要在一个由程序生成的严酷、持久的世界中艰难生存下去。在一个死寂的文明世界中搜寻剩下的食物和装备，或者假如你足够幸运，搞到一辆装满汽油的汽车逃离 Dodge —这个如地狱一般的地方。从僵尸到巨型昆虫或机器人杀手以及更加奇怪和致命的东西，你要通过战斗来击败它们或逃离，以及和那些想要抢夺你的东西的那些同你一样的人战斗。 在许多方面上， Cataclysm 与大多数的 roguelike 游戏不同。它被设定在一个没有边界的三维世界里，而不是设定在一个垂直、线性的地下城中。这意味着相比于大多数的 roguel 游戏，探险将占一个更大的比重，而且这个游戏将具有更大的自由度。由于地图是如此的巨大，在每次游戏之间，它可以完全保持原样。假如你死了，并以一个新的角色开始，你的新游戏将会设定在同你最近呆过的游戏世界相同的世界里。同许多 roguelike 游戏一样，你可以获得先前角色的战利品；而与大多数 roguelike 不同的是，你也可以重新踏上先前角色的轨迹，并且对世界做出的任何戏剧性改变将会维持到你的下一次游戏。 特点包括: 详细的角色创建，提供了数量众多的特性来选择； 防御模式，这是一个有着快节奏作战的休息模式； Bionics；类似于在许多其他游戏里的魔法系统； 基因突变, 有好的和坏的变化； 无界的，完全随机的世界地图，可以在角色交替时保持不变； 创造物品 新的制作方法可能需要通过练习或从书本中获得来磨练你的知识； 逼真的火、烟和其他动态的地图特效； 昼/夜循环，需要睡觉。假如你必须的话，可以使用咖啡因来保持更长时间的清醒，但这不健康； 超过 300 种物品类型，包括众多的现实世界的枪支，药品和工具； 许多药品是上瘾的，并需要持续使用来避免负面效果； 通过修补门、窗、建造陷阱和巩固你的家的基石来防止一个僵尸的突然造访； 能够构建你自己的木屋，包括墙和屋顶； 可以驾驶在“后末世”发现的汽车兜风； 这个可以根据你的需求来修改，或甚至你可以自己制造一辆； 温度系统，太冷或太热都非常危险； 初步支持贴片界面； 根据选项生成世界，以及各种编辑方式； 网站: en.cataclysmdda.com 作者: Kevin Granade 及其他 协议: Creative Commons Attribution-ShareAlike 3.0 Unported License 版本号: 0. B Goblin Hack Goblin Hack 是一个开源 roguelike 游戏，基于 OpenGL 的平滑滚动的ASCII 图形界面。这个游戏受 NetHack 外观的启发，但更加快速且使用更少的按键。 Goblin Hack 有一个简洁的界面，在今天这个过度强调渲染的游戏世界中，似乎它对所有年龄段的玩家都有吸引力，并启发了这些玩家的想象力。 在被投进一个随机的正在生成的地下城之前，玩家可以从几个角色类别中选择一个角色。 特点包括: 令人印象深刻的界面(相比于许多其他的 roguelike 游戏)； 简洁的界面； 在被投进一个随机的正在生成的第一层地下城之前，玩家可以从几个角色类别中选择一个角色； 手动保存游戏； 网站: goblinhack.sourceforge.net, github.com/goblinhack/goblinhack 作者: Neil McGill 协议: GNU GPL v2 版本号: 1.19 SLASH’EM Super Lotsa Added Stuff Hack - Extended Magic (SLASH’EM) 是一个角色扮演游戏，在其中你控制一个单独的角色。SLASH’EM 是 NetHack 的一个变种。它拥有一个和 Rogue、ADOM、Anghand 及 NetHack 相似的界面和游戏玩法。你通过键盘来控制角色的动作，以一个俯视的视角来查看这个世界。 背景： Amulet of Yendor 已被偷走，不仅如此，偷走 amulet 的 Wizard of Yendor（坏蛋）似乎深藏于 Dungeons of Doom（危险的地方）。 特点包括: 提供额外的特色、怪兽和项目； 新颖的特点包括僧人职业和类似推箱子的关卡； 主地下城比在 NetHack 中的要大很多； 网站: www.slashem.org 开发者: Slash’EM 开发团队 协议: MIT License, NetHack General Public License 版本号: 0.0.7E7F3 NetHack NetHack 是一个极简，但又非常吸引人的具有地下城与龙风格的冒险游戏。“net”元素指的是它的发展已经根据网络进行了调整，“hack”元素指的是角色扮演游戏的一种类型，以乱砍、猛砍著称，着眼于战斗。 在 NetHack 中，你扮演凶猛的战士、巫师或许多其他职业中的一种，一路战斗着，为你的神灵获取 Amulet of Yendor（可以说这是一个倒退!）。在这个过程中，你可能会遇到一个或两个 quantum mechanic（LCTT 译注：从这里得知，这指的是一种怪兽），或者可能遇到一个小型的太空舰队，抑或是 —— 假如你足够幸运会遇到 —— Ravenous Bugblatter Beast of Traal。（LCTT 译注：我参考了这里）。 特点包括: 45-50 个关卡, 其中的大多数随机生成； 各种各样的物品：武器、盔甲、卷轴、药水、戒指、宝石和各种各样的工具，如钥匙和灯； 祝福和诅咒； 永久死亡: 若没有对当前的保存文件进行备份，失效的角色就找不回来了； 界面： 文本模式； 图形化界面， 使用 X、Qt 工具集或 GNOME 库； 网站: www.nethack.org 开发者: NetHack 开发团队 协议: NetHack 通用公共许可证 版本号: 3.4.3 Ascii Sector Ascii Sector 是一个免费的太空战斗/探险/交易游戏，它基于经典的电脑游戏 Wing Commander: Privateer ，后者由 Origine Systems 公司于 1993 年发布。 在 Ascii Sector 中，刚开始你将驾驶一艘简易的飞船，然后可以通过接受任务或者贩卖物品来挣得足够多的钱以升级你的飞船或重新再买一艘。不管是在太空中，还是在地面上，抑或是在飞船上，你可以专注于致命的战斗；并且通过使用 Ascii Sector 的脚本语言，你还可以为游戏创造自己的任务或享受其他玩家创造的任务。 特点包括: 使用 ANSI 字符集生成图形界面； 真正的深入到游戏中； 提供各种基地，任务，商品和飞船； 飞船型号包括: Broadsword, Centurion, Demon, Dralthi, Drayman, Galaxy, Gladius, Gothri, Kamekh, Nexus, Orion, Paradign, Stileto, Talon, Tarsus 和 Ulysses； 四个象限: Alizarin, Crimson, Mauve, 和 Viridian； 可下载的任务； 任务可用脚本编辑； Ascii Sector 任务语言，在 Ascii Sector 宇宙中创造你自己的故事； 可以袭击或抢劫星球上的 NPC（非玩家控制角色）； 可以到处移动的持久性舰队、可以改变系统的控制、引来敌人的舰队、回基地修复或重建； 可以登录系统受损的飞船； 可下载高质量的音乐文件； 网站: www.asciisector.net 开发者: Christian Knudsen 协议: 免费软件 版本号: 0.7.1.4 Angband Angband 是一个免费、单用户、使用 ASCII 字符图形化的地下城探险游戏，在其中你将以一个冒险者的角色探索一个深深的地下城，与怪兽战斗，获得你能取得的最好武器，准备着与黑暗之主 Morgoth 的最后决战。从上世纪九十年代开始，它一直在持续地开发着。 Angband 沿袭了 Rogue 和 NetHack 的风格路线。它由 Moria 和 Umoria 游戏衍生而来，基于 Rogue 回合制。它经常被描述为一个 “roguelike”游戏，因为它的外观和游戏体验与 Rogue 非常相似。很多游戏中的新生物、物品都来自 J. R. R Tolkien 的画作，尽管有些野兽直接来源于经典的神话、龙与地下城、Rolemaster，或 Angband 的原开发者的脑海中。 特点包括: 100 层地下城； 随机产生的新关卡； 可以选择成为人类、半精灵、精灵、霍比特人、地精、矮人，半兽人，半巨魔， 登丹人 ，高等精灵，或者狗头人； 神器； 施法； 怪物； 怪物坑； 怪物巢穴； 网站: rephial.org 开发者: Angband 开发小组 协议: GNU GPL v2 版本号: 3.5.0 UnNetHack UnNetHack 是 NetHack 的一个分支版本。NetHack 最开始于 1987 年发行，并且许多游戏玩家认为它是计算机世界所能提供的最好游戏体验的游戏之一。 特点包括： 增加了许多针对 NetHack 的增强，如额外的怪兽、更多的关卡、许多新的元素、更多的危险、更具挑战性的游戏，以及最重要的，相比普通的 NetHack，它更具娱乐性； 帮助新手开始的教程； 网站: sourceforge.net/apps/trac/unnethack 作者: Patric Mueller 协议: Nethack General Public License 版本号: 5.1.0 Hydra Slayer Hydra Slayer 是一个专注于杀死九头蛇的开源 Roguelike 游戏。它受到了希腊神话、地下城探险、MathRL seven day roguelike ，和一些关于勇者杀死多头野兽的数字谜题等启发。 特点如下: 独特的游戏机制； 混合希腊神话和数字迷宫的主题； 传统的 roguelike ASCII 字符界面或贴片/3D 界面； 5 种人物角色，具有极为不同的战术、力量及弱点； 28 种敌人类型: 10 种基本的九头蛇类型（每种类型都有两种变种）； 8 种特殊类型的敌人； 可用作战术工具的无害蘑菇； 28 种装备（并包括材料和装备的大小/力量的变种）； 15 种武器材料； 18 种非装备物品； 3 种可供选择的地图； 8 种关卡拓扑结构（包括莫比乌斯带和克莱因瓶）； 11 个关卡生成器； 2 种结局； 网站: www.roguetemple.com/z/hydra 开发者: Zeno Rogue 协议: GNU GPL v2 版本号: 16.1 Brogue Brogue 是一个开源的 Roguelike 游戏，它可以运行在 Mac OS X, Windows, Linux, iOS 和 Android 等平台下。 Brogue 是 Rogue 的一个直系分支，后者是一个最早由 Michael Toy 和 Glenn Wichman 于 1980 年左右开发的地下城探险视频游戏。与其他受欢迎的现代 Roguelike 游戏不同， Brogue 追求简单而不是复杂性，同时尽力确保游戏的不同组成之间的联系是有趣且纷繁多彩。 这个游戏的目标是取得深藏于地下第 26 层的 “Amulet of Yendor”，再返回到地面逃出生天。对于那些技术娴熟且想进一步探险的人来说，位于 26 层之下的每层均包含 3 颗 lumenstone （流明石）(LCTT 译注：此处与我在这里看到的有些出入），获得它们，将在胜利的基础上被授予额外的得分。 Brogue 是一个富有挑战性的游戏，但玩起来非常有趣。尽量不要因游戏的高难度而灰心；试玩一段时间之后，你会发现它变得非常吸引人。 特点如下: 追求简单而非复杂； 对用户友好； 相比于 Rogue， Brogue 关卡生成更加复杂； 移除了 XP 和 水平系统 ； 陷阱，防护性物品； 额外的怪兽类型和魔法物品； 网站: sites.google.com/site/broguegame 作者: Brian Walker 协议: GNU Affero GPL 版本号: 1.7.3 via: http://www.linuxlinks.com/article/201412031524381/RoguelikeGames.htmlpublic: https://linux.cn/article-5200-1.html 作者：Frazer Kline译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"游戏","slug":"游戏","permalink":"https://fsslc.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Roguelike","slug":"Roguelike","permalink":"https://fsslc.github.io/tags/Roguelike/"}]},{"title":"[翻译] 怎样在 Linux 中限制网络带宽使用","date":"2015-03-27T06:58:03.000Z","path":"2015/03/27/Translate-How-to-limit-network-bandwidth-on-Linux/","text":"介绍如何在 Linux 中限制网络带宽使用 假如你经常在 Linux 桌面上运行多个网络应用，或在家中让多台电脑共享带宽；那么你可能想更好地控制带宽的使用。否则，当你使用下载器下载一个大文件时，交互式 SSH 会话可能会变得缓慢以至不可用；或者当你通过 Dropbox 来同步一个大文件夹时，你的室友可能会抱怨在她的电脑上，视频流变得断断续续。 在本教程中，我将为你描述两种在 Linux 中限制网络流量速率的不同方法。 在 Linux 中限制一个应用的速率限制网络流量速率的一种方法是通过一个名为trickle的命令行工具。通过在程序运行时，预先加载一个速率限制 socket 库 的方法，trickle 命令允许你改变任意一个特定程序的流量。 trickle 命令有一个很好的特性是它仅在用户空间中运行，这意味着，你不必需要 root 权限就可以限制一个程序的带宽使用。要能使用 trickle 程序控制程序的带宽，这个程序就必须使用非静态链接库的套接字接口。当你想对一个不具有内置带宽控制功能的程序进行速率限制时，trickle 可以帮得上忙。 在 Ubuntu，Debian 及其衍生发行版中安装 trickle ： $ sudo apt-get install trickle 在 Fdora 或 CentOS/RHEL (带有 EPEL 软件仓库)： $ sudo yum install trickle trickle 的基本使用方法如下。仅需简单地把 trickle 命令（及速率参数）放在你想运行的命令之前。 $ trickle -d &lt;download-rate&gt; -u &lt;upload-rate&gt; &lt;command&gt; 这就可以将 &lt;command&gt; 的下载和上传速率限定为特定值（单位 KBytes/s）。 例如，将你的 scp 会话的最大上传带宽设定为 100 KB/s： $ trickle -u 100 scp backup.tgz alice@remote_host.com: 如若你想，你可以通过创建一个自定义启动器的方式，使用下面的命令为你的 Firefox 浏览器设定最大下载速率（例如， 300 KB/s）。 trickle -d 300 firefox %u 最后， trickle 也可以以守护进程模式运行，在该模式下，它将会限制所有通过 trickle 启动且正在运行的程序的总带宽之和。 启动 trickle 使其作为一个守护进程（例如， trickled）： $ sudo trickled -d 1000 一旦 trickled 守护进程在后台运行，你便可以通过 trickle 命令来启动其他程序。假如你通过 trickle 启动一个程序，那么这个程序的最大下载速率将是 1000 KB/s， 假如你再通过 trickle 启动了另一个程序，则每个程序的(下载)速率极限将会被限制为 500 KB/s，等等。 在 Linux 中限制一个网络接口的速率另一种控制你的带宽资源的方式是在每一个接口上限制带宽。这在你与其他人分享你的网络连接的上行带宽时尤为实用。同其他一样，Linux 有一个工具来为你做这件事。wondershaper就是干这个的。 wondershaper 实际上是一个 shell 脚本，它使用 tc 来定义流量调整命令，使用 QoS 来处理特定的网络接口。外发流量通过放在不同优先级的队列中，达到限制传出流量速率的目的；而传入流量通过丢包的方式来达到速率限制的目的。 事实上， wondershaper 的既定目标不仅仅是对一个接口增加其带宽上限；当批量下载或上传正在进行时，wondershaper 还试图去保持互动性会话如 SSH 的低延迟。同样的，它还会控制批量上传(例如， Dropbox 的同步)不会使得下载“窒息”，反之亦然。 在 Ubuntu Debian 及其衍生发行版本 中安装 wondershaper： $ sudo apt-get install wondershaper 在 Fdora 或 CentOS/RHEL (带有 EPEL 软件仓库) 中安装 wondershaper： $ sudo yum install wondershaper wondershaper 的基本使用如下： $ sudo wondershaper &lt;interface&gt; &lt;download-rate&gt; &lt;upload-rate&gt; 举个例子， 将 eth0 的最大下载/上传带宽分别设定为 1000Kbit/s 和 500Kbit/s: $ sudo wondershaper eth0 1000 500 你也可以通过运行下面的命令将速率限制进行消除： $ sudo wondershaper clear eth0 假如你对 wondershaper 的运行原理感兴趣，你可以阅读其 shell 脚本源文件(/sbin/wondershaper)。 总结在本教程中，我介绍了两种不同的方法，来达到如何在 Linux 桌面环境中，控制每个应用或每个接口的带宽使用的目的。 这些工具的使用都很简单，都为用户提供了一个快速且容易的方式来调整或限制流量。 对于那些想更多地了解如何在 Linux 中进行速率控制的读者，请参考 the Linux bible. via: http://xmodulo.com/limit-network-bandwidth-linux.htmlpublish: https://linux.cn/article-5129-1.html 作者：Dan Nanni译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"限制带宽","slug":"限制带宽","permalink":"https://fsslc.github.io/tags/%E9%99%90%E5%88%B6%E5%B8%A6%E5%AE%BD/"}]},{"title":"[翻译] Linux 下最为人熟知的归档/压缩工具","date":"2015-03-27T01:27:05.000Z","path":"2015/03/27/Translate-Best-Known-Linux-Archive-or-Compress-Tools/","text":"介绍 Linux 下常用的归档压缩工具 很多时候，通过互联网发送或接收大文件和图片是一件令人头疼的事。压缩及解压缩工具正好可以应对这个问题。下面让我们快速浏览一些可以使得我们的工作更加轻松的开源工具。 Tar Tar 由 ‘Tape archiver（磁带归档器）’ 衍生而来，最初被用来在磁带上归档和存储文件。Tar 是一个 GNU 软件，它可以压缩一组文件（归档），或提取它们以及对已有的归档文件进行相关操作。在存储、备份以及传输文件方面，它是很有用的。在创建归档文件时，Tar 可以保持原有文件和目录结构不变。通过 Tar 归档的文件的后缀名为 ‘.tar’。 基本用法如下： a) 创建归档 (c / —create)tar --create --verbose --file=archive.tar file1 file2 file3 或 tar cvf archive.tar file1 file2 file3 创建一个归档 b) 列出归档文件内容 ( t / —list)tar --list archive.tar 列出归档中包含的文件 c) 提取归档 (x / —extract)tar xvf archive.tar tar xvf archive.tar --wildcards &#39;*.c&#39; # 从归档中提取后缀名为 *.c 的文件。 提取文件 只提取需要的文件 d) 对归档文件进行更新 ( u / —update)tar uvf archive.tar newfile.c # 假如归档的newfile.c 要比先前已经归档的新，则添加更新的 newfile.c 到归档里面. 更新一个归档 e) 从归档中删除文件 (—delete)tar --delete -f archive.tar file1.c # 从压缩包&#39;archive.tar&#39; 中删除文件&#39;file1.c&#39; 删除文件 更加具体的使用方法请参考tar 主页。 Gzip / Gunzip Gzip 即 GNU zip，它是一个被广泛用于 Linux 操作系统中的压缩应用，被其压缩的文件的后缀名为’*.gz’ 。 基本用法如下： a) 压缩文件gzip file(s) 每个文件将被单独压缩。 压缩文件 通常在压缩完成后，它会将原来的文件删除。我们可以使用 -c 选项来保留原来的文件。 gzip -c file &gt; file.gz 压缩后保留原有文件 我们也可以将一组文件压缩到一个单独的文件中 cat file1 file2 file3 | gzip &gt; archieve.gz 压缩一组文件 b) 检查压缩比被压缩文件的压缩比可以使用 ‘-l’ 选项来进行检验。 gzip -l archieve.gz 检查压缩率 c) 解压文件Gunzip 用来解压文件，在这里，原有的（压缩）文件在被解压后同样会被删除。使用 -c 选项来保留原始文件。 gunzip -c archieve.gz 解压文件 gzip 加上’-d’选项 和 gunzip 对压缩文件有同样的效果。 更多细节可以从 gzip 主页 得到。 Bzip2 / Bunzip2 同 gzip 一样，Bzip2 也是一个压缩工具，与其他传统的工具相比，它可以将文件压缩到更小，但其缺点为：运行速度比 gzip 慢。 基本用法如下： a) 压缩文件一般情况下，针对压缩而言，Bzip2 不用什么选项，将被压缩的文件被传递为它的参数。每个文件被单独压缩，且压缩文件以 ‘bz2’ 为后缀名。 bzip2 file1 file2 file3 文件压缩 使用 ‘-k’ 选项可以使得在压缩或解压缩之后保留原有的文件。 在压缩后保留原有文件 b) 解压‘-d’ 选项被用来解压缩。 使用 -d 选项解压缩文件 也可以使用 bunzip2 来解压缩。 bunzip2 filename 解压文件 bunzip2 可以解压后缀名为 bz2, bz, tbz2 和 tbz 的文件。带有 tbz2 和 tbz 的文件在压缩后，后缀名将变为’.tar’ 。 bzip2 -dc # 执行解压文件到标准输出的功能。 7-zip 7-zip 是另一个开源压缩软件。它使用 7z 这种新的压缩格式，并支持高压缩比。因此，它被认为是比先前提及的压缩工具更好的软件。在 Linux 下，可以通过 p7zip 软件包得到，该软件包里包含 3 个二进制文件： 7z, 7za 和 7zr，读者可以参考 p7zip wiki 来了解这三个二进制文件之间的不同。在本篇中，我们将使用 7zr 来解释 7-zip 的用法。归档文件以 ‘.7z’ 为后缀名。 基本用法如下： a) 创建归档7zr a archive-name.7z file-name(s) / directory-name(s) 创建一个归档文件 b) 列出归档包含文件7zr l archive-name.7z 列出归档中包含的文件 c) 提取归档文件7zr e archive-name.7z 提取归档 d) 更新归档文件7zr u archive-name.7z new-file 更新一个归档文件 e) 从归档文件中删除文件7zr d archive-name.7z file-to-be-deleted 删除文件 确认文件删除 via: http://linoxide.com/tools/linux-compress-decompress-tools/publish: https://linux.cn/article-5131-1.html 作者：B N Poornima译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"压缩归档工具","slug":"压缩归档工具","permalink":"https://fsslc.github.io/tags/%E5%8E%8B%E7%BC%A9%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7/"}]},{"title":"[翻译] 如何在 Linux 中使用类似智能手机外观的 Conky 天气插件","date":"2015-03-26T00:02:20.000Z","path":"2015/03/26/Translate-How-To-Use-Smartphones-Like-Weather-Conky-In-Linux/","text":"介绍使用 Conky 来显示天气预报 智能手机都拥有一些平滑地融入手机外观的天气小插件，现在幸亏有了 Flair Weather Conky，你便可以在你的 Linux 桌面中拥有像智能手机一样的天气外观。我们将使用一个 GUI 工具Conky Manager 在 Linux 中轻松地管理 Conky。那就先让我们看看如何在 Ubuntu 14.10，14.04、Linux Mint 17 及其他 Linux 发行版本中安装 Conky Manager 吧。 安装 Conky Manager打开一个终端并使用下面的命令： sudo add-apt-repository ppa:teejee2008/ppa sudo apt-get update sudo apt-get install conky-manager 你可以阅读这篇关于如何在 Linux 中使用 Conky Manager 的文章。 确保 curl 已被安装请确保 curl 已被安装。如果没有安装它，可以使用下面的命令来安装： sudo apt-get install curl 下载 Flair Weather Conky从下面的链接下载 Flair Weather Conky 的脚本： 下载 Flair Weather Conky 的脚本 在 Conky Manager 中使用 Flair Weather Conky 脚本步骤 1:同你在 Ubuntu 14.04 中安装主题一样，在你的家目录中应该有一个 .conky 目录。假如你使用命令行，我想我不需要告诉你如何找到这个目录。对于新手，请用文件管理器切换到你的家目录下，并按 Ctrl+H 来 在 Ubuntu 中显示隐藏文件。在这里查找 .conky 文件夹，假如没有这个文件夹，则创建一个。 步骤 2:在 .conky 目录中，解压下载到的 Flair Weather 文件。请注意在默认情况下它会自动解压到一个名为 .conky 目录下。所以请进入这个目录，将其中的 Flair Weather 文件夹从中取出，然后将它粘贴到真正的 .conky 目录下。 步骤 3:Flair Weather 使用 Yahoo 的天气服务，但它不能自动地识别你的位置。你需要手动地编辑它。到Yahoo 天气 网页，然后通过键入你的城市/Pin 码来得到你所在城市的位置 ID号。你可以从网页地址栏中取得位置 ID 号。 步骤 4:打开 Conky Manager，它应该能够读取新安装的 Conky 脚本。这里有两款样式可用，黑色主题或亮丽主题。你可以选择你偏爱的那一款。当你选择后，你就可以在桌面上看到 conky 的显示了。 在 Flair Weather 中，默认位置被设定为 Melbourne。你必须手动编辑 conky 文件来修改。 步骤 5:在上面的截图中，你可以看到有一个编辑选定 conky 脚本的选项，在打开的编辑器中，查找 location 或 WOEID ，更换它为你在 步骤 3 中得到的位置 ID 号。然后重启 Conky。 在上面查找的相同位置，假如你将u=c 替换为u=f，则温度的单位将从摄氏温标改为华氏温标 。不要忘了重启 Conky 来查看已经做出的修改。 可能的故障排除在 Ubuntu 14.04 和 Ubuntu 14.10 中，假如你发现 Conky 展示的时间有重叠现象，则请编辑 conky 脚本。查找下面的这些行： ## cairo-compmgr own_window_type override own_window_argb_visual no 然后将内容更换为下面的这些行： ## cairo-compmgr own_window_type dock own_window_argb_visual no 保存更改并重启 conky。这就应该解决了这个问题。感谢 Jesse(这个 Conky 脚本的开发者)给我们提供了这个解决方法和为其他相关问题给予的支持。 尝试一下在这篇文章中，我们实际上学到了不少东西。我们见证了如何轻松地使用任何 Conky 脚本，如何编辑脚本以及如何使用 Conky Manager 来达到不同的目的。我希望这些对你有用。 需要留心的是，Ubuntu 14.10 用户可能会看到重叠的时间数字。请在开发者 Jesse 绝妙的Google + 主页 中报告任何相关的问题。 我已经向你展示了在我的系统上 Flair Weather conky 外观的截图。现在是该你尝试它并炫耀你的桌面的时间了。 via: http://itsfoss.com/weather-conky-linux/publish: https://linux.cn/article-5122-1.html 作者：Abhishek译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Conky","slug":"Conky","permalink":"https://fsslc.github.io/tags/Conky/"},{"name":"天气","slug":"天气","permalink":"https://fsslc.github.io/tags/%E5%A4%A9%E6%B0%94/"}]},{"title":"[翻译] 如何在 Linux 上使用 BackupPC 来架设跨平台的备份服务器","date":"2015-03-23T01:46:00.000Z","path":"2015/03/23/Translate-How-to-set-up-a-cross-platform-backup-server-on-Linux-with-BackupPC/","text":"介绍如何在 Linux 上使用 BackupPC 来架设跨平台的备份服务器 也许你没有从我先前关于 backupninja 和 backup-manager 的两篇文章中发现，我是一个超级备“粉”。当提到备份，我宁愿备份的太多而不希望备份不足，因为如果我们有需要的话，你将会感激你为重要数据生成额外的拷贝所付出的时间和精力。 在这篇文章中，我将向你介绍 BackupPC，一个跨平台的备份服务器软件，它可以通过网络为 Linux，Windows 和 MacOS 等系统上的客户端主机拉取备份。BackupPC 添加了一系列的特点使得管理备份变为一件快乐的事。 BackupPC 的特点BackupPC 自带有一个健壮的 Web 界面，允许你以集中化的方式来收集和管理其他远程客户端主机上的备份。通过使用它的 Web 界面，你可以检查日志和配置文件、为其他远程主机启动/取消/安排备份任务以及可视化备份任务的当前状态。你也可以非常容易地浏览归档的文件以及从备份的归档中恢复单个文件或整个备份。要恢复单个文件，你可以直接通过 Web 界面来下载任何先前备份的文件。不仅如此，客户端主机并不需要安装特别的客户端软件。在 Windows 客户端上， 使用的是原生的 SMB 协议，而对于 *nix 客户端，你将使用 rsync 或 通过 SSH, RSH 或 NFS 来使用 tar 。 安装 BackupPC在 Debian，Ubuntu 和它们的衍生版本上，运行下面的命令： # aptitude install backuppc 在 Fedora上， 使用 yum 命令。请注意软件包名字对大小写敏感。 在 CentOS/RHEL 6 上，首先要启用 EPEL 软件仓库。在 CentOS/RHEL 7 上，请替代启用 Nux Dextop 软件仓库。然后接着使用 yum 命令： # yum install BackupPC 同往常一样，这两种包管理系统都会自动解决依赖问题。另外，作为安装过程中的一部分，你可能需要新配置或修改配置用于图形用户界面的 Web 服务器。下面的截图来自于 Debian 系统： 通过空格键来确定你的选择，然后使用 tab 键移动到 Ok 选项并敲回车键。 接着类似于下面的截屏将会呈现在你眼前，通知你创建了一个用来管理 BackupPC 的名为 ‘backuppc’的管理员用户以及相应的密码（如果你需要，这个密码以后可以更改）。这里需要注意的是：这里创建了同样名为 ‘backuppc’的 HTTP 账户和常规的 Linux 账户，它们使用相同的密码。需要前者的目的是来访问受保护的 BackupPC 的 Web 界面，而后者则是为了通过 SSH 来使用 rsync 来执行备份任务。 你可以使用下面的命令来更改 HTTP 账户 ‘backuppc’ 的默认密码： # htpasswd /path/to/hash/file backuppc 至于常规的 ‘backuppc’ Linux账户，可以使用 passwd命令来更改它的默认密码： # passwd backuppc 需要提及的是：安装过程中会自动创建 Web 和程序的配置文件。 启动 BackupPC 并设置备份首先，打开一个浏览器窗口并指向 http://\\&lt;服务器名称或 IP 地址&gt;/backuppc/ 。当弹出提示框时，输入先前向你创建的默认 HTTP 用户凭据（注：即用户名 backuppc 和相应的默认密码）。假如认证成功，你就会被带入到 Web 界面的主页： 你想做的第一件事最有可能是通过新增一个客户端主机来备份。进入任务窗格中的 “编辑主机”选项。我们将添加两个客户端主机： Host #1: CentOS 7 [IP 192.168.0.17] Host #2: Windows 7 [IP 192.168.0.103] 我们将通过 SSH 使用 rsync来备份 CentOS 主机，使用 SMB 来备份 Windows 主机。在执行备份之前，我们需要向我们的 CentOS 主机设置 基于密钥认证 以及在我们的 Windows 主机中设置一个共享目录。 下面是关于如何为一个远程 CentOS 主机设置基于密钥认证的指导。我们创建 ‘backuppc’ 用户的 RSA 密钥对，并将其公钥传输给 CentOS 主机上的 root 账户。 # usermod -s /bin/bash backuppc # su - backuppc # ssh-keygen -t rsa # ssh-copy-id root@192.168.0.17 当弹出提示框时，键入 yes 并为 192.168.0.17 键入 root 用户的密码： 你需要一个远程的 CentOS 主机的 root 权限，以获得在该主机中的文件系统中写权限，以防要恢复的备份文件或目录的所有者为 root 账户。 一旦 CentOS 和 Windows 主机都准备完毕，使用 Web 界面将它们添加到 BackupPC： 下一步更改每个主机的备份设置： 接下来的图片展示了 Windows 主机的备份设置： 而接着的截图展示了 CentOS 主机的备份设置： 开始一个备份任务为了开始备份，到每个主机的设定选项，然后点击“开始全备份”： 在任何时候，你都可以通过点击如上图展示的每个主机的备份主页来查看备份任务的状态。假如因为某些原因备份失败，在主机菜单中将会出现一个指向包含错误信息的网页的链接。当一个备份任务成功完成后，在服务器的 /var/lib/backuppc/pc 目录下会创建一个命名为主机名或 IP 地址的目录。 我们也可以随意地在命令行中浏览这个目录中的文件，但存在一个更加简单的方式来查找和恢复这些文件。 恢复备份要浏览这些保存的文件，进入每个主机的主菜单下的 “浏览备份”选项，你可以一目了然地看到目录和文件，并选择那些你想恢复的文件。另外，你还可以通过点击文件来使用默认程序打开文件或右击文件并选择“另存为”来下载该文件到你当前的机器上： 如若你想，你可以下载一个包含所有你想备份的内容的 zip 或 tar 文件： 或只是恢复文件： 总结有句俗话说，”越简单，越好”，而这正是 BackupPC 所提供的东西。在 BackupPC 中，你将不仅找到了一个备份工具，而且还找到了一个无需任何客户端应用来在几个不同的操作系统中管理你的备份的方法。我相信这就有足够的理由让你去尝试一下。 欢迎使用下面的评论框来留下你的评论和问题，假如你有的话。我总是乐于听取读者想说的话！ via: http://xmodulo.com/backuppc-cross-platform-backup-server-linux.htmlpublish: https://linux.cn/article-5097-1.html 作者：Gabriel Cánepa译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"BackupPC","slug":"BackupPC","permalink":"https://fsslc.github.io/tags/BackupPC/"},{"name":"备份服务器","slug":"备份服务器","permalink":"https://fsslc.github.io/tags/%E5%A4%87%E4%BB%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"[翻译] 如何使用 backupninja 来备份 Debian 系统","date":"2015-03-21T02:03:44.000Z","path":"2015/03/21/Translate-How-to-back-up-a-Debian-system-using-backupninja/","text":"介绍使用 backupninja 来备份 Debian 系统 题图来自：blogspot.com 小心谨慎或灾难体验会让每一个系统管理都认识到频繁的系统备份的重要性。你可以通过编写管用的旧式 shell 脚本，或使用一个（或几个）适合这项工作的备份工具来完成备份任务。因此，当你要实施一个备份解决方案时，你了解的备份工具越多，你做出的决策就会越明智。 在这篇文章中，我们将为你介绍 backupninja ，这是一个轻量且易于配置的系统备份工具。在诸如 rdiff-backup, duplicity, mysqlhotcopy 和 mysqldump 等程序的帮助下， Backupninja 可以提供常用的备份功能，如执行远程的、安全的和增量式的文件系统备份，加密备份以及 MySQL/MariaDB 数据库备份。你可以选择性地开启使用 Email 状态报告功能，也可以对一般的硬件和系统的信息进行备份。 backupninja 的一个关键功能是它拥有一个内建的基于控制台的向导程序（被称为 ninjahelper），而后者允许你为不同的备份情景轻松地创建配置文件。 如果非要说的话，backupninja 的缺点是：为了充分使用其所有的功能，它要求安装一些其他“助手”程序。尽管 backupninja 有针对基于 Red Hat（红帽）的发行版本的 RPM 安装包，但 backupninja 针对 Debian 及其衍生发行版本的依赖进行了优化。所以不建议在基于 Red Hat 的系统上尝试 backupninja 。 在这篇教程中，我们将介绍如何在基于 Debian 的发行版本上安装 backupninja 。 安装 Backupninja以 root 账户来运行下面的命令： # aptitude install backupninja 在安装的过程中，有几个文件和目录将被创建： /usr/sbin/backupninja 是个 bash shell 的主脚本； /etc/cron.d/backupninja， 默认情况下，设置 cron 任务来每隔一个小时运行上面的主脚本； /etc/logrotate.d/backupninja 截断由 backupninja 程序产生的日志； /etc/backup.d/ 是备份操作的配置文件驻留的目录； /etc/backupninja.conf 是包含一般选项的主配置文件。这个文件带有良好的注释且详细解释了每个选项的含义； /usr/share/backupninja 是那些 backupninja 所使用的脚本所处的目录。这些脚本文件负责执行实际的工作。在这个目录中，你还可以找到 .helper 文件，它们可以被用来配置和设定 ninjahelper 的菜单； /usr/share/doc/backupninja/examples 含有操作配置文件（即通过 ninjahelper 产生的文件）的模板。 首次运行 Ninjahelper当我们尝试启动 ninjahelper 时，我们可以看到可能需要一个内部依赖程序。假如系统进行了提示，请输入 “yes” 并敲下回车键来安装 dialog（一个用于从 shell 脚本中显示友好对话框的工具）。 当你在键入 yes 后再敲回车键时，backupninja 将会安装 dialog，一旦安装完成，将呈现出下面的截屏： 案例 1: 备份硬件和系统信息在启动了 ninjahelper 之后，我们将创建一个新的备份操作： 如果必要的助手程序没有被安装，下面的截屏将会呈现在我们眼前。假如这些软件包已经在你的系统上安装了，请跳过这一步。 接下来的一步需要你选取相关条目来作为此次备份任务的一部分。前四个条目已经默认被选上了，但你可以通过在条目上按空格键来撤消选择。 一旦你完成了上面的步骤，按 OK 选项来继续。接着你将能够选择是愿意使用默认的配置文件(/etc/backup.d/10.sys)来完成这次备份操作，还是创建一个新的配置文件。若为后者，一个含有与默认配置文件内容相同的文件将会在相同的目录下被创建，但它被命名为 11.sys，后续的备份操作将会创建类似的文件（注：只不过命名的序号不同）。需要说明的是一旦这个新的配置文件被创建，你便可以使用你喜爱的文本编辑器来编辑该文件。 案例 2: 一个远程目录的增量式 Rsync 拉取备份正如你最有可能知道的那样， rsync 被广泛地用于通过网络同步文件或文件夹。在接下来的例子中，我们将讨论一个使用硬链接来为一个远程目录做增量式拉取备份的方法，它被用来保存历史数据以及在我们本地的文件服务器中恢复这些历史数据。这个方法将帮助我们节省空间并增强位于服务器端的安全性。 步骤 1：编写一个带有如下内容的自定义脚本，放在 /etc/backup.d，并将它的权限设置为 600 。需要说明的是，除了一般的配置文件，这个目录可能还包含当 backupninja 执行时你想运行的一些脚本文件，它们可以发挥出位于主配置文件中的变量的优势。 # REMOTE USER user=root # REMOTE HOST host=dev1 # REMOTE DIRECTORY remotedir=/home/gacanepa/ # LOCAL DIRECTORY localdir=/home/gacanepa/backup.0 # LOCAL DIRECTORY WHERE PREVIOUS BACKUP WAS STORED localdirold=/home/gacanepa/backup.1 mv $localdir $localdirold # RSYNC rsync -av --delete --recursive --link-dest=$localdirold $user@$host:$remotedir $localdir 在上面的配置中， rsync 的 ‘—link-dest’ 选项的作用是为位于 $localdir-old 目录中那些没有改变的文件(包含所有属性) 硬链接到目标目录（$localdir）。 步骤 2：在 backupninja 第一次运行之前，上层目录（这个例子中指的是 /home/gacanepa） 是空的。第一次我们执行下面的命令： # backupninja -n backup.0 目录就被创建了，并在接下来的过程中，它的名称将会被更改为 backup.1。 当我们第二次运行 backupninja 时， backup.0 将会被重新创建，而 backup.1 保持不动。 步骤 3： 确保 backup.1 里面的文件硬链接到 backup.0 里的文件，我们可以通过比较文件的 inode（i 节点）数和目录的大小来达到此目的。 总结Backupninja 不仅是一个经典的备份工具，它也是一个易于配置的实用程序。你可以通过编写你自己的控制脚本，用放在 /etc.backup.d 中的不同的配置文件来运行 backupninja 。甚至你还可以为 ninjahelper 编写助手程序，并将其包括在 ninjahelper 的主界面上。 例如，假如你在 /usr/share/backupninja目录中创建了一个名为 xmodulo 的控制脚本，它将自动运行那些位于 /etc/backup.d 目录中以 .xmodulo 为后缀的每个文件。如果你决定添加你的 xmodulo 控制脚本到 ninjahelper 中， 你可以编写相应的助手程序，即 xmodulo.helper 。另外，假如你想 让 backupninja 运行其它的脚本，只需把它添加到 /etc/backup.d 目录中就可以了。 欢迎使用下面的评论框来留下你的评论、问题或建议。听到你的回应将会使我们很高兴。 via: http://xmodulo.com/backup-debian-system-backupninja.htmlpublish: https://linux.cn/article-5096-1.html 作者：Gabriel Cánepa译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"backupninja","slug":"backupninja","permalink":"https://fsslc.github.io/tags/backupninja/"},{"name":"备份","slug":"备份","permalink":"https://fsslc.github.io/tags/%E5%A4%87%E4%BB%BD/"}]},{"title":"[翻译] 让你玩转 Ubuntu 桌面的十一件武器","date":"2015-03-11T01:00:00.000Z","path":"2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/","text":"介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能 无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。 从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你调整 Ubuntu ，随时满足你的需求。 注意： Ubuntu 总是配备了‘合理的默认设置’（即工作良好的选项），以达到开箱即用，这些默认设置适合大多数人，并且它们都是经过了测试、采用及推荐等过程的。 但一个尺码并不适合所有人。对于我们当中的能工巧匠和实验主义者来说，默认设置只是他们定制系统的起点。 所以，无需更多的唠叨， 这里有 11 个极好的实用工具可以帮助你增强 Ubuntu 使用体验。 Unity Tweak Tool 我将以这个列表中最重要的一个工具: Unity Tweak Tool 来开始这次的介绍。融汇了各种定制选项，Unity Tweak Tool 提供了一系列针对 Ubuntu 和 Unity 桌面的系统综合调整功能。 它被各种开关、切换和控制器塞得满满的，使得你可以任意设置从 Unity 桌面的外观到 Unity 的行为之类的任何东西。你可以使用它快速简便地改变 GTK 主题和图标集、设置热区、调整启动器图标尺寸、增加或移除工作区，以及 —-特别地—-开启 Unity 桌面中被巧妙隐藏的“通过点击最小化”的功能。 它是免费的，可直接从 Ubuntu 软件中心里找到， Unity Tweak Tool 是非常值得保留在你的口袋里的工具之一。 Unity 隐私指示器 隐私是一个非常、非常重要的事，事实也恰恰如此，但这个话题要比二进制还难以说明白。让一些数据或习惯，比如说你经常打开的应用，在本地被记录下来，这或许会让你感到高兴，但对于你在 Dash 中的搜索数据被发送到第三方服务机构(尽管这些数据或许是匿名的)这类事情，你就高兴不起来了。 隐私指示器 是一个帮助你时刻跟踪 Ubuntu桌面系统中有哪些文件、目录和服务正被获取、记录及搜索的实用工具。 通过快速的点击被添加到桌面面板上的‘眼睛’图标，你可以： 开启或关闭在线搜索结果，使用 Zeitgeist 记录系统活动，存储 HUD 使用记录和启用 Ubuntu GeoIP 服务 快速清理 Zeitgeist 日志、 ALT-F2 历史、最近访问文件等等的记录数据 展示或隐藏桌面图标及面板上显示的用户名 上述的最后一条的功能似乎不应该出现在这个应用程序中，但对于那些要分享截图或截屏的人来说，这将会泄露更少的隐私。 从这里下载隐私指示器 (.deb) Unity 橱窗 Android, iOS, OS X, Chrome OS, 和 GNOME Shell 都有应用橱窗, 借助一个极好的第三方应用，Unity 也可以实现类似功能。 “Unity 橱窗” 允许你将 Unity 启动器中的应用分组到实用的橱窗中，—- 如游戏，办公，社交等。不必打开 Dash，你就可以快速启动你喜爱的应用，这非常适合你的工作流。 每一个 ‘橱窗’其实上是一个打开在图标附近的应用窗口，但总体效果看上去就像是一个 OS X 风格的“堆栈”或 Android 的分组框。 橱窗的图标可以自定义或根据橱窗内的应用来自动生成。已有的橱窗可以修改和重新组织、重命名以及如下的更多选择： 根据你的喜好创建任意多的橱窗 选择自定义或自动生成橱窗图标 可选择 3 种橱窗样式 为添加到橱窗中的应用设定自定义图标 编辑现有橱窗 Unity 橱窗的网址 咖啡因（Caffeine）对于我们中的许多人来说，咖啡因是必需品，而不仅仅是饮料。而这里的“咖啡因”则提供了一个快速，温和的方式来避免屏保/锁屏占据屏幕。它的有用程度将取决于你的环境(即你系统的怪癖)，并且尽管它不像以前那样好用，它仍然值得你尝试一下。 下载咖啡因（Caffeine） 系统监控指示器 假如你是一个状态迷，即一个喜欢密切关注程序，进程和硬件的状态的人， Linux 很容易满足你的需求。从 Conky 的配置到终端命令，并不缺少监视你的 CPU 使用情况、网络流量或 GPU 温度的方法。 但至今为止，我最喜爱的应用是系统监控指示器（也被叫做多负载指示器），它可从 Ubuntu 软件中心获得。它也有着大量的配置选项。 点击这个链接，在 Ubuntu 中下载 ‘系统监控指示器’ 针对 Linux 笔记本电脑的省电工具 TLP当提到便携式设备上的电池使用效率时，Linux 发行版的声誉并不算好。 如果你的 Linux 笔记本在重新充电前，电池只够让你从沙发走到厨房的话，那么这里有几个你可以试试的工具。 TLP 是最受欢迎的确保延长 Linux 笔记本的电池寿命的自动化后台工具之一，它是通过调整系统进程和硬件的设置及行为来达成省电的，例如 启动 Wi-Fi 省电模式， PCI 总线设备的实时电量管理和处理器的降频调整。 在 Ubuntu 14.04 LTS 以及后续发行版本中可以使用 TLP 专用的 PPA 来安装它，通过它的‘一下搞定’的设置就能用起来。在我们之中的高级用户可以潜心研究并根据你自己的硬件来调整设置，一个关于 TLP 的完整指导 wiki 使得设置更加容易。 Laptop Mode Tools假如 TLP 听起来有一点复杂，这也并没有什么可羞耻的，这里有一个更简单的替代品： Laptop Mode Tools。 这个软件包可从 Ubuntu 软件中心直接安装，且本身设置好了一系列合理的默认设置(Wi-Fi,蓝牙等等)。 切记，Laptop Mode Tools 不能和 TLP 同时被安装在电脑中。 Ubuntu 软件中心里的 Laptop Mode Tools Intel 显卡驱动安装工具 对于那些运行 Intel 显卡硬件，并想使得这些硬件发挥出最佳性能的人来说，Intel 显卡安装工具是必须拥有的。 它使得查找并安装最新的 Intel GPU 驱动变得不再是一件痛苦和大费周折的事，因为这无需 PPA 或任何的终端使用知识。 下载针对 Linux平台的 Intel 显卡驱动安装器 0.7 版本 硬件信息 假如你计划升级你的 PC 或想替换一个坏掉的零部件，你需要知道一些特定的硬件信息，例如 RAM 类型，CPU插座类型 或查看哪个 PCI 槽是可用的等信息。 I-Nex可以使得找出这些以及其他的系统具体配置变得更加容易。使用它来查找你的主板型号、S.M.A.R.T.(注：为 Self-Monitoring, Analysis and Reporting Technology 的缩写，经常写为 SMART ) 状态，以及你想的出的很多东西！ 可从 Launchpad 了解到更多关于 I-Nex 的信息 磁盘空间可视化程序 在这个硬盘以 TB 计数的时代，我们或许不必同以前一样对硬盘空间的使用三思而后行。但对于那些使用小容量的 SSD，分成多个分区或在一个拥有固定大小的虚拟磁盘的虚拟机上工作的人来说，总有“应该释放一些额外空间是必要的”这种想法的时候。 GNOME Disks，在 Ubuntu 中被默认安装，使得查找占用最大磁盘空间的罪魁祸首变得容易。对于定位隐藏的日志、缓存和视频文件，它是非常完美的工具。 BleachBit (Cruft Cleaner) Windows 用户可能对像 CCleaner 之类的应用很熟悉，它可以扫描并清理垃圾文件、空白文件夹、臃肿的缓存以及陈旧的软件包。在 Ubuntu 上，一个相似的快速且毫不费力的一键式清理方法可以试试 BleachBit 。 它是一个强大的工具，所以一定要注意你正在清理什么。不要漫无目的地确认每个选项框；不是所有的东西它都可以清理。所以请合理地使用它，当你对某个选项有疑问时，就跳过它。 从 Ubuntu 软件中心里安装 BleachBit 你已经有了自己最喜欢的系统实用工具了吗？可以在下面的评论中让其他人知晓它。 via: http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-thempublish: https://linux.cn/article-5025-1.html 作者：Joey-Elijah Sneddon译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://fsslc.github.io/tags/Ubuntu/"},{"name":"桌面","slug":"桌面","permalink":"https://fsslc.github.io/tags/%E6%A1%8C%E9%9D%A2/"}]},{"title":"[翻译] dupeGuru - 直接从硬盘中查找并移除重复文件","date":"2015-03-05T03:38:00.000Z","path":"2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/","text":"介绍使用 dupeGuru 来查找并删除重复文件 简介对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 dupeGuru 可能会帮助到你。 dupeGuru 团队也开发了名为 dupeGuru 音乐版 的应用来移除重复的音乐文件，和名为 dupeGuru 图片版 的应用来移除重复的图片文件。 1. dupeGuru (标准版)需要告诉那些不熟悉 dupeGuru 的人，它是一个免费、开源、跨平台的应用，其用途是在系统中查找和移除重复文件。它可以在 Linux, Windows, 和 Mac OS X 等平台下使用。通过使用一个快速的模糊匹配算法，它可以在几分钟内找到重复文件。同时，你还可以调整 dupeGuru 使它去精确查找特定文件类型的重复文件，以及从你想删除的文件中，清除某种文件。它支持英语、 法语、 德语、 中文 （简体）、 捷克语、 意大利语、亚美尼亚语、俄语、乌克兰语、巴西语和越南语。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGurudupeGuru 开发者已经构建了一个 Ubuntu PPA (Personal Package Archives)来简化安装过程。想要安装 dupeGuru，依次在终端中键入以下命令： sudo apt-add-repository ppa:hsoft/ppa sudo apt-get update sudo apt-get install dupeguru-se 使用使用非常简单，可从 Unity 面板或菜单中启动 dupeGuru。 点击位于底部的 + 按钮来添加你想扫描的文件目录。点击 扫描 按钮开始查找重复文件。 一旦所选目录中含有重复文件，那么它将在窗口中展示重复文件。正如你所看到的，在下面的截图中，我的下载目录中有一个重复文件。 现在，你可以决定下一步如何操作。你可以删除这个重复的文件，或者对它进行重命名，抑或是 复制/移动 到另一个位置。为此，选定该重复文件，或在菜单栏中选定写有“仅显示重复”选项 ，如果你选择了“仅显示重复”选项，则只有重复文件在窗口中可见，这样你便可以轻松选择并删除这些文件。点击“操作”下拉菜单，最后选择你将执行的操作。在这里，我只想删除重复文件，所以我选择了“移动标记文件到垃圾箱”这个选项。 接着，点击“继续”选项来移除重复文件。 2. dupeGuru 音乐版dupeGuru 音乐版 或简称 dupeGuru ME，它的功能与 dupeGuru 类似。它拥有 dupeGuru 的所有功能，但它包含更多的信息列 （如比特率，持续时间，标签等）和更多的扫描类型（如带有字段的文件名，标签以及音频内容）。和 dupeGuru 一样，dupeGuru ME 也运行在 Linux、Windows 和 Mac OS X 中。 它支持众多的格式，诸如 MP3、WMA、AAC (iTunes 格式)、OGG、FLAC，以及失真率较少的 AAC 和 WMA 格式等。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME现在，我们不必再添加任何 PPA，因为在前面的步骤中，我们已经进行了添加。所以在终端中键入以下命令来安装它： sudo apt-get install dupeguru-me 使用你可以从 Unity 面板或菜单中启动它。dupeGuru ME 的使用方法、操作界面以及外观和正常的 dupeGuru 类似。添加你想扫描的目录并选择你想执行的操作。重复的音乐文件就会被删除。 3. dupeGuru 图片版dupeGuru 图片版,或简称为 duepGuru PE，是一个在你的电脑中查找重复图片的工具。它和 dupeGuru 类似，但独具匹配重复图片的功能。dupeGuru PE 可运行在 Linux、Windows 和 Mac OS X 中。 dupeGuru PE 支持 JPG、PNG、TIFF、GIF 和 BMP 等图片格式。所有的这些格式可以被同时比较。Mac OS X 版的 dupeGuru PE 还支持 PSD 和 RAW (CR2 和 NEF) 格式。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE由于我们已经添加了 PPA，我们也不必为 dupeGuru PE 再次添加。只需运行如下命令来安装它。 sudo apt-get install dupeguru-pe 使用就使用方法，操作界面和外观而言，它与 dupeGuru，dupeGuru ME 类似。我就纳闷为什么开发者为不同的类别开发了不同的版本。我想如果开发一个结合以上三个版本功能的应用，或许会更好。 启动它，添加你想扫描的目录，并选择你想执行的操作。就这样，你的重复文件将被清除。 如果因为任何的安全问题而不能移除某些重复文件，请记下这些文件的位置，通过终端或文件管理器来手动删除它们。 欢呼吧！ via: http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/publish: https://linux.cn/article-4992-1.html 作者：SK译者：FSSlc校对：Caroline 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"重复文件","slug":"重复文件","permalink":"https://fsslc.github.io/tags/%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/"},{"name":"dupeGuru","slug":"dupeGuru","permalink":"https://fsslc.github.io/tags/dupeGuru/"}]},{"title":"[翻译] 怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号","date":"2015-02-28T12:53:00.000Z","path":"2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/","text":"通过 GitHub 将它们嵌入到网页和其他项目中 Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。 现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近开源了他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。 但这需要一点体力活。 Unicode 已经识别甚至标准化了 emoji 字母表， 然而 emoji 仍然不能完全与所有的网络浏览器相兼容，这意味着大多数情况下，它们将呈现为 “豆腐块”或“空白盒子”。当 Twitter 想使得 emoji 到处可用时，这家社交网络联合了一家名为Icon Factory的公司来渲染浏览器以模仿文本信息符号的效果。Twiter 认为人们对他们的 emoji 库有很大的需求。 现在， 你可以从 GitHub 上克隆 Twitter 的整个库，从而在你的开发项目中使用它们。 下面将为你介绍如何达到上面的目的以及如何使得 emoji 更容易被使用。 为 Emoji 得到 Unicode 支持Unicode 是国际编码标准，它为任意的符号、字母或人们想在网络上使用的数字配置了一串编码。换句话说，它是你如何在计算机上阅读文本与计算机如何读取文本之间的缺失环节。例如，对于你正看到的位于这些句子中的空格（LCTT 译注：英文分词中间的空格），计算机读取为 “&amp;nbsp”。 Unicode 甚至拥有其自己的原始 emoji，它们可以在没有你的任何努力的情况下在浏览器中被阅读。例如，当你看到了 一个 ❤ 符号，你的计算机正在解码字符串 “2665” 。 要在大多数情况下使用 Twitter 的 emoji 库，你只需在你的 HTML 网页中的 &lt;head&gt;块中添加如下脚本： &lt;script src=&quot;//twemoji.maxcdn.com/twemoji.min.js&quot;&gt;&lt;/script&gt; 这样就使得你的项目可以访问包含有已经在 Twitter 中可使用的数以百计的 Emoji 符号的 JavaScript 库。然而，创建一个仅仅包含这个脚本的文档并不能使得在你的网站中呈现出 emoji 符号，实际上，你仍需要嵌入这些 emoji 符号！ 在 &lt;body&gt;块中，粘贴一些可以在 Twitter 的preview.html 文件源代码 中找到的 emoji 字符串。我使用了 &#x1F3B9; 和 &amp;#x1F3C1，当然我并不知道在浏览器窗口中它们的样子。是的，你必须粘贴并猜测它们。你已经看出了问题，我们将在第二小节中予以解决。 无论如何，通过一些尝试，你可以将一个如下图的原始 HTML 文件 显示为如下图的网页： 将 Emoji 转换为可阅读的语言对于一个网站或应用，Twitter 的解决方案是非常适用的。但如果你想通过 HTML 轻易地插入你喜爱的 emoji 符号，你需要一个更易实现的解决方案，而不是记住所有代表 emoji 的 Unicode 字符串。 那正是程序员 Elle Kasai 的 Twemoji Awesome 样式大展身手的地方。 通过向任意网页中添加 Elle 的开源样式表，你可以适用 英语单词来理解你正插入的 emoji 符号的意义。所以如若你想展示一个 心形 emoji 符号，你可以简单地输入： &lt;i class=&quot;twa twa-heart&quot;&gt;&lt;/i&gt; 为了实现上面的目的，让我们下载 Elle 的项目，通过点击在 GitHub 上 “Download ZIP” 按钮。 接着，我们在桌面上新建一个文件夹，然后进入该文件夹，并将 emoji.html—-我先前向你展示的 HTML 源文件—- 和 Elle 的 twemoji-awesome.css 一同放进去。 我们还需要 HTML 文件识别这个 CSS 文件，所以在 html 网页中的 &lt;head&gt; 块中，为 CSS 文件添加一个链接： &lt;link rel=&quot;stylesheet&quot; href=&quot;twemoji-awesome.css&quot;&gt; 一旦你将上面的代码添加了进去，你便可以删除先前添加的 Twitter 的脚本链接。 现在，找到 body 块部分的代码，然后添加一些 emoji 符号。我使用了 &lt;i class=&quot;twa twa-sparkling-heart&quot;&gt;&lt;/i&gt;, &lt;i class=&quot;twa twa-exclamation&quot;&gt;&lt;/i&gt;, &lt;i class=&quot;twa twa-lg twa-sparkles&quot;&gt;&lt;/i&gt; 和 &lt;i class=&quot;twa twa-beer&quot;&gt;&lt;/i&gt;。 最终，你将得到如下的代码： 保存并在浏览器中查看上面的文件： Duang！这样你不仅得到了一个可以在浏览器中支持 emoji 符号的基本网页，而且还知道了如何简单地实现它。你可以随意的在我的 GitHub 中查看这个教程，并且可以克隆这些实际的文件而不只是看看这些截图。 题图来自于得到 Emoji； Lauren Orsini 截图。 via: http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-windowpublish: https://linux.cn/article-4961-1.html 作者：Lauren Orsini译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Emoji","slug":"Emoji","permalink":"https://fsslc.github.io/tags/Emoji/"}]},{"title":"[翻译] 怎样在 Linux 系统中恢复已删除文件","date":"2015-02-25T04:51:50.000Z","path":"2015/02/25/Translate-Undelete-Files-on-Linux-Systems/","text":"介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件 当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。 这里将解释它是如何工作的。在一个文件系统中，有一个叫做 文件分配表 的东西，这个表跟踪文件在存储单元（如硬盘， MicroSD 卡，闪存驱动器等等）中的位置。当一个文件被删除，文件系统将会在文件分配表中执行以下两个任务之一：这个文件在文件分配表上的条目被标记为 “自由空间” 或删除文件分配表里这个文件的条目，且将相应的空间被标记为自由空间 。现在，如果有一个新的文件需要被放置在一个存储单元上，操作系统将会把这个文件放置到标记为空位的地方。在新文件被写入到这个空位后，被删除的文件就彻底消失了。当需要恢复一个已经删除的文件时，用户绝对不能再对任何文件进行操作，因为假如该文件对应的“空位”被占用，这个文件就永远也不能恢复了。 恢复软件是如何工作的？大多数的文件系统（在删除文件时）只是标记空间为空白。在这些文件系统下，恢复软件查看文件分配表这个文件，然后复制被删除的文件到另外的存储单元中。假如该文件被复制到其它需要恢复的被删除的存储单元中，那么用户将有可能会失去那个所需的删除文件。 文件系统很少会擦除文件分配表中的条目。假如文件系统真的这样做了， 这便是恢复软件在恢复文件了。恢复软件在存储单元中扫描文件头，所有文件都拥有一个特殊的编码字符串，它们位于文件的最前面，也被叫做 魔法数字。例如，一个编译的 JAVA 类文件的魔法数字在十六进制中是“CAFEBABE”。所以，假如要恢复该类型的文件，恢复软件会查找 “CAFEBABE” 然后复制文件到另一个存储单元。一些恢复软件可以查找某种特殊的文件类型。若用户想恢复一个 PDF 文件，则恢复软件将会查找十六进制的魔法数字 “25504446”，这恰恰是 ASCII 编码中的 “%PDF”。恢复软件将会查找所有的魔法数字，然后用户可以选择恢复哪个已删除的文件。 假如一个文件的部分被覆写了，则整个文件就会被损坏。通常这个文件可以被恢复，但是其中的内容可能已经没有什么用处。例如，恢复一个已损坏的 JPEG 文件将会是无意义的，因为图片查看器不能从这个损坏的文件产生一幅图片。因此，即使用户拥有了这个文件，该文件也将毫无用处。 设备的位置：在我们继续之前，下面的一些信息将会对指引恢复软件找到正确的存储单元起到一定的帮助。所有的设备均挂载在 /dev/ 目录下。操作系统赋予每个设备的名称（并不是管理员给予每个分区或设备的名称）遵循一定的命名规律。 第一个 SATA 硬盘的第二个分区的名称将会是 sda2。名称的第一个字母暗示了存储类型，在这里指的是 SATA，但字母 “s” 也可能指的是 SCSI、 FireWire（火线端口）或 USB。第二个字母 “d” 指的是 disk(硬盘)。第三个字母指的是设备序数，即字母 “a” 指的是第一个 SATA 而 “b” 指的是第二个。最后的数字代表分区。没有分区数字的设备名代表该设置的所有分区。对于上面的例子，对应的名称为 sda 。作为命名的第一个字母还可能是 “h” ，这对应 PATA 硬盘（IDE）。 以下为命名规律的一些例子。假如一个用户有一个 SATA 硬盘（sda），这个设备有 4 个分区- sda1、 sda2、 sda3 和 sda4 。该用户删除了第三个分区，但直到格式化第四个分区之前，第四个分区名 sda4 都将保留不变。然后该用户插入了一个带有一个分区 - 即sdb1- 的 usb 存储卡（sdb），又增加了一个带有一个分区 -hda1- 的 IDE 硬盘 ，接着该用户又增加了一个 SCSI 硬盘 - sdc1 。接着用户移除了 USB 存储卡（sdb）。现在，SCSI 硬盘的名称仍然为 sdc，但如果这个 SCSI 被移除接着再被插入，则它的名称将变为 sdb。虽然还有其他的存储设备存在， 那个 IDE 硬盘的名称仍会有一个 “a”， 因为它是第一个 IDE 硬盘，IDE 设备的命名与 SCSI、 SATA、 FireWire 和 USB 设备要分开计数。 使用 TestDisk 进行恢复：每个恢复软件有其不同的功能，特征及支持的不同文件系统。下面是一些关于 使用 TestDisk 在各种文件系统中恢复文件的指南。 FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4：TestDisk 是一个运行在 Linux、 *BSD、 SunOS、 Mac OS X、 DOS 和 Windows 等操作系统下的开源的自由软件。 TestDisk 可以从下面的链接中找到 ：http://www.cgsecurity.org/wiki/TestDisk。TestDisk 也可以通过键入 sudo apt-get install testdisk 来安装。TestDisk 有着许多的功能，但这篇文章将只关注恢复文件这个功能。 使用 root 权限从终端中打开 TestDisk 可以通过键入 sudo testdisk 命令。 现在， TestDisk 命令行应用将会被执行。终端的显示将会改变。TestDisk 询问用户它是否可以保留日志，这完全由用户决定。假如一个用户正从系统存储中恢复文件，则不必保留日志。可选择的选项有“生成”、 “追加” 和 “无日志”。假如用户想保留日志，则日志将会保留在该用户的主目录。 在接着的屏幕中，存储设备以 /dev/*的方式被罗列出来。对于我的系统，系统的存储单元为 /dev/sda，这意味着我的存储单元为 一个 SATA硬盘（sd）且它是第一个硬盘（a）。每个存储单元的容量以 Gigabyte（千兆字节）为单位显示的。使用上下键来选择一个存储设备然后点击进入。 下一屏显示出一个列有分区表（也叫做分区映射表）的清单。正如文件有文件配置表，分区有着分区表。分区是存储设备上的分段。例如在几乎所有的 Linux 系统中，至少存在两种分区类型 - EXT3/4 和 Swap 。每一个分区表将会在下面被简要地描述。TestDisk 并不支持所有类型的分区表，所以这并不是完整的列表。 Intel - 这类分区表在 Windows 系统和许多的 Linux 系统中非常普遍，它也常常称作 MBR 分区表。 EFI GPT - 这种类型的分区表通常用在 Linux 系统中。对于 Linux 系统，这种分区表是最为推荐的， 因为逻辑分区或扩展分区的概念并不适用于 GPT (GUID Partition Table) 分区表。 这意味着，如果每个分区中有一个 Linux 系统，一个 Linux 用户可以从多种类型的 Linux 系统中进行多重启动。当然使用 GPT 分区表还有其他的优势，但那些已超出了本文的讨论范围。 Humax - Humax 分区映射表适用于韩国公司 Humax 生产的设备。 Mac - Apple 分区映射表 (APM) 适用于 Apple 的设备。 None - 某些设备并没有分区表。例如，许多 Subor 游戏控制台不使用分区映射表。如果一个用户试图以其它分区表类型从这类设备中恢复文件，用户就会困扰 TestDisk 为何找卟到任何的文件系统或者文件。 Sun - Sun 分区表适用于 Sun 系统。 Xbox -Xbox 适用于使用 Xbox 分区映射表的存储设备。 假如用户选择了 “Xbox” ，尽管他的系统使用了 GPT 分区表， 那么 TestDisk 将不能找到任何分区或文件系统。假如 TestDisk 按照用户的选择执行，则它可能猜测错误。（下面的图片显示的是当分区表类型错误时的输出） 当用户为他们的设备选择了正确的选项，则在下一屏中，选择 “高级” 选项。 现在，用户将看到一个列有用户存储设备中所有的文件系统或分区的列表。假如用户选择了错误的分区映射表，则在这一步中用户就将会知道他们做出了错误的选择。假如没有错误，通过移动文字光标来高亮选择含有被删除文件的分区。使用 左右键来高亮位于终端底部的 “列表”。接着，按下回车确认。 新的一屏便会呈现出列有文件和目录的列表。那些白色的文件名就是未被删除的文件，而红色的文件名是那些已被删除的文件。最右边的一列是文件的名称，从右到左方向的接着一列是文件的创建日期，再往左的一列是文件的大小（以 byte/ 比特为单位），最左边带有“-”，“d” ,“r”, “w” 和”x”的一列则代表的是文件的权限情况。“d” 表示该文件为一个目录，其他的权限术语与本文关系不大。在列表的最顶端以“.”代表的一项表示当前目录，第二行以”..”代表的一项表示当前目录的上级目录，所以用户可以通过选择目录所在行到达该目录。 举个例子，我想进入”Xaiml_Dataset” 目录，该目录基本上由被删除的文件组成。通过按键盘上的 “c”键，我将恢复文件 “computers.xaiml”，接着我被询问选择一个目标目录，当然，我应该放置该文件到另一个分区中。现在，当我在我的家目录时，按下了“c”键。（选择目标目录时）哪个目录被高亮并没有什么影响，当前目录就是目标目录，在屏幕的上方，将会显示“复制完成”的消息。在我的家目录中便会有一个名为”Xaiml_Dataset”的目录，里面里有一个 Xaiml 文件。 假如我在更多的已删除文件上按“c” 键，则这些文件将会被放置到新的文件夹中而无需再向我询问目标目录。 当这些步骤完成后，重复按“q”键直到看到正常的终端模样。目录”Xaiml_Dataset” 只能被 root 用户访问。为了解决这个问题，使用 root 权限改变该目录及其子目录的权限。做完这些后，文件便被恢复了且用户可以访问它们。 特别的 ReiserFS：为了从 ReiserFS 文件系统中恢复一个文件，首先需将分区中的所有文件做一个备份。因为如果发生某些错误， 这个方法可能会引起文件丢失。接着执行下面的命令，其中 DEVICE指的是那些以 sda2 形式命名的设备。一些文件将被放入 lost+found 目录而其他则会保存到原先被删除的位置。 reiserfsck --rebuild-tree --scan-whole-partition /dev/DEVICE 恢复被某个程序打开的删除文件：假设用户意外地删除了一个文件，且该文件被某个程序打开。虽然在硬盘中该文件被删除了，但这个程序正使用着位于 RAM 中的该文件的副本。幸好，我们有两种简单的解决方法来恢复该文件。 假如这个软件有保存功能，如文本编辑器，则用户可以重新保存该文件，这样，文本编辑器可以将该文件写入硬盘中。 假设在音乐播放器中有一个 MP3 文件，而该音乐播放器并不能保存该 MP3 文件，则这种情形下需要比先前花更多的时间来恢复文件。不幸的是，这种方法并不能保证在所有的系统和应用中有效。首先，键入下面的命令。 lsof -c smplayer | grep mp3 上面的命令会列出所有由 smplayer 使用的文件，这个列表由 grep 命令通过管道搜索 mp3 。命令的输入类似于下面： smplayer 10037 collier mp3 169r 8,1 676376 1704294 /usr/bin/smplayer 现在，键入下面的命令来直接从 RAM（在 Linux 系统中，/proc/映射到 RAM）中恢复文件，并复制该文件到选定的文件夹中。其中 cp 指的是复制命令，输出中的数字 10037 来自于进程数，输出中的数字 169 指的是文件描述符，”~/Music/“为目标目录，最后的 “music.mp3” 为用户想恢复的文件的名称。 cp /proc/10037/fd/169 ~/Music/music.mp3 真正的删除：为确保一个文件不能被恢复，可以使用一个命令来 “擦除” 硬盘。擦除硬盘实际上是向硬盘中写入无意义的数据。例如，许多擦除程序向硬盘中写入零，随机字母或随机数据。不会有空间被占用或丢失，擦除程序只是对空位进行重写覆盖。假如存储单元被文件占满而没有空余空间，则所有先前被删除的文件将会消失而不能恢复。 擦除硬盘的目的是确保隐私数据不被他人看见。举个例子，一个公司可能预订了一些新的电脑，总经理决定将旧的电脑卖掉，然而，新的电脑拥有者可能会看到公司的一些机密或诸如信用卡号码，地址等顾客信息。幸好，公司的电脑技术人员可以在卖掉这些旧电脑之前，擦除这些硬盘。 为了安装擦除程序 secure-delete，键入 sudo apt-get install secure-delete,这个命令将会安装一个包含 4 个程序的程序集，用以确保被删除的文件不能被恢复。 srm - 永久删除一个文件。使用方法： srm -f ./secret_file.txt sfill - 擦除空白空间。使用方法: sfill -f /mount/point/of/partition sswap - 擦除 swap 空间。使用方法: sswap -f /dev/SWAP_DEVICE 假如电脑实际去清除那些删除的文件，那么就需要花费更长的时间去执行删除任务。将某些空间标记为空位是快速且容易的，但使得文件永远消失需要花费一定的时间。例如，擦除一个存储单元，可能需要花费几个小时的时间（根据磁盘容量大小）。总之，现在的系统工作的就挺好，因为即便用户清空了垃圾箱，他们仍然有另一次机会来改变他们当初的想法（或错误）。 via: http://www.linux.org/threads/undelete-files-on-linux-systems.4316/public: https://linux.cn/article-4938-1.html 作者：DevynCJohnson译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"文件恢复","slug":"文件恢复","permalink":"https://fsslc.github.io/tags/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/"},{"name":"TestDisk","slug":"TestDisk","permalink":"https://fsslc.github.io/tags/TestDisk/"}]},{"title":"[翻译] 使用 APT-mirror 四步配置 Ubuntu 本地软件仓库","date":"2015-02-23T03:17:07.000Z","path":"2015/02/23/Translate-4-Steps-to-Setup-Local-Repository-in-Ubuntu-using-APT-mirror/","text":"介绍使用 APT-Mirror 来制作本地源 今天，我们将向你展示如何在你的 Ubuntu 个人电脑或 Ubuntu 服务器中，直接通过 Ubuntu 官方软件仓库来配置本地软件仓库。在你的电脑中创建一个本地软件仓库有着许多的好处。假如你有许多电脑需要安装软件 、安全升级和修复补丁，那么配置一个本地软件仓库是一个做这些事情的高效方法。因为，所有需要安装的软件包都可以通过快速的局域网连接从你的本地服务器中下载，这样可以节省你的网络带宽，降低互联网接入的年度开支 … 你可以使用多种工具在你的本地个人电脑或服务器中配置一个 Ubuntu 的本地软件仓库，但在本教程中，我们将为你介绍 APT-Mirror。这里，我们将把默认的镜像包镜像到我们本地的服务器或个人电脑中，并且在你的本地或外置硬盘中，我们至少需要 120 GB 或更多的可用空间才行。 我们可以通过配置一个 HTTP 或 FTP 服务器来与本地系统客户端共享这个软件仓库。 我们需要安装 Apache 网络服务器和 APT-Mirror 来使得我们的工作得以开始。下面是配置一个可工作的本地软件仓库的步骤： 1. 安装需要的软件包我们需要从 Ubuntu 的公共软件包仓库中取得所有的软件包，然后在我们本地的 Ubuntu 服务器硬盘中保存它们。 首先我们安装一个Web 服务器来承载我们的本地软件仓库。这里我们将安装 Apache Web 服务器，但你可以安装任何你中意的 Web 服务器。对于 http 协议，Web 服务器是必须的。假如你需要配置 ftp 协议 及 rsync 协议，你还可以再分别额外安装 FTP 服务器，如 proftpd, vsftpd 等等 和 Rsync 。 $ sudo apt-get install apache2 然后我们需要安装 apt-mirror: $ sudo apt-get install apt-mirror apt-mirror-installation 注: 正如我先前提到的，我们需要至少 120 GB 的可用空间来使得所有的软件包被镜像或下载。 2. 配置 APT-Mirror现在，在你的硬盘上创建一个目录来保存所有的软件包。例如，我们创建一个名为 /linoxide的目录，我们将在这个目录中保存所有的软件包： $ sudo mkdir /linoxide 现在，打开文件 /etc/apt/mirror.list : $ sudo nano /etc/apt/mirror.list 复制下面的命令行配置到 mirror.list文件中并按照你的需求进行修改： ############# config ################## # set base_path /linoxide # # set mirror_path $base_path/mirror # set skel_path $base_path/skel # set var_path $base_path/var # set cleanscript $var_path/clean.sh # set defaultarch &lt;running host architecture&gt; # set postmirror_script $var_path/postmirror.sh # set run_postmirror 0 set nthreads 20 set _tilde 0 # ############# end config ############## deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiverse deb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse #deb http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse #deb http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu trusty-security main restricted universe multiverse deb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse #deb-src http://archive.ubuntu.com/ubuntu trusty-proposed main restricted universe multiverse #deb-src http://archive.ubuntu.com/ubuntu trusty-backports main restricted universe multiverse clean http://archive.ubuntu.com/ubuntu 注: 你可以将上面的官方镜像服务器网址更改为离你最近的服务器的网址，可以通过访问 Ubuntu Mirror Server来找到这些服务器地址。假如你并不太在意镜像完成的时间，你可以沿用默认的官方镜像服务器网址。 这里，我们将要镜像最新和最大的 Ubuntu LTS 发行版 —- 即 Ubuntu 14.04 LTS (Trusty Tahr) —- 的软件包仓库，所以在上面的配置中发行版本号为 trusty 。假如我们需要镜像 Saucy 或其他的 Ubuntu 发行版本，请修改上面的 trusy 为相应的代号。 现在，我们必须运行 apt-mirror 来下载或镜像官方仓库中的所有软件包。 sudo apt-mirror 从 Ubuntu 服务器中下载所有的软件包所花费的时间取决于你和镜像服务器之间的网络连接速率和性能。这里我中断了下载，因为我已经下载好了 … downloading-packages 3.配置网络服务器为了使得其他的电脑能够访问这个软件仓库，你需要一个Web服务器。你也可以通过 ftp 来完成这件事，但我选择使用一个Web服务器因为在上面的步骤 1 中我提及到使用Web服务器。因此，我们现在要对 Apache 服务器进行配置: 我们将为我们本地的软件仓库目录 建立一个到 Apache 托管目录 —- 即 /var/www/ubuntu —- 的符号链接。 $ sudo ln -s /linoxide /var/www/ubuntu $ sudo service apache2 start 上面的命令将允许我们从本地主机(localhost) —- 即 http://127.0.0.1(默认情况下) —- 浏览我们的镜像软件仓库。 4. 配置客户端最后，我们需要在其他的电脑中添加软件源，来使得它们可以从我们的电脑中取得软件包或软件仓库。为达到此目的，我们需要编辑 /etc/apt/sources.list 文件并添加下面的命令： $ sudo nano /etc/apt/sources.list 添加下面的一行到/etc/apt/sources.list中并保存。 deb http://192.168.0.100/ubuntu/ trusty main restricted universe 注: 这里的 192.168.0.100 是我们的服务器电脑的局域网 IP 地址，你需要替换为你的服务器电脑的局域网 IP 地址 $ sudo apt-get update 最终，我们完成了任务。现在，你可以使用sudo apt-get install packagename 命令来从你的本地 Ubuntu 软件仓库中安装所需的软件包，这将会是高速的且消耗很少的带宽。 via: http://linoxide.com/ubuntu-how-to/setup-local-repository-ubuntu/public: https://linux.cn/article-4926-1.html 作者：Arun Pyasi译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://fsslc.github.io/tags/Ubuntu/"},{"name":"APT-mirror","slug":"APT-mirror","permalink":"https://fsslc.github.io/tags/APT-mirror/"}]}]
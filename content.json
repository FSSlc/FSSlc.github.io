[{"title":"使用 Python 软件包来处理较为复杂的 JSON 文件","date":"2019-12-16T08:04:26.000Z","path":"2019/12/16/Python-Deals-large-json-file-md/","text":"使用 Python 软件包来处理较为复杂的 JSON 文件 最近在工作中遇到需要使用 Python 处理较复杂的 JSON 数据，不仅需要对嵌套的JSON 数据做查询、筛选，还需要替换其中的一些元素。这里将处理这个问题的过程记录下来，权当记忆。 复杂 json 示例下面展示的是一个较为复杂的 JSON 数据，这里列出只是展示一个较为复杂的 JSON 数据会怎么复杂。 [ // 一个 data group 根数据库的示例 { // 首先是激活条件 &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, // 接着是它包含的键值对，可包含多个，这里只显示一个 &quot;items&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;enum_list&quot;: null, &quot;max&quot;: null, &quot;min&quot;: null, &quot;name&quot;: &quot;periodic_dimension&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;int_array&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/periodic_dimension&quot;, &quot;value&quot;: &quot;0,0,0&quot; } ], // 然后是它包含的子数据库，可能会嵌套 &quot;librarys&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;items&quot;: [ { &quot;active&quot;: { &quot;ref-library&quot;: &quot;&quot;, &quot;ref-library_name&quot;: &quot;&quot;, &quot;ref-value&quot;: &quot;&quot;, &quot;ref_path&quot;: &quot;&quot;, &quot;type&quot;: &quot;Condition_Default&quot; }, &quot;enum_list&quot;: null, &quot;max&quot;: null, &quot;min&quot;: null, &quot;name&quot;: &quot;SAT_MODEL&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;string&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel/SAT_MODEL&quot;, &quot;value&quot;: &quot;model.sat&quot; } ], &quot;librarys&quot;: [], &quot;name&quot;: &quot;CADModel&quot;, &quot;show&quot;: { &quot;show_on_interface&quot;: false }, &quot;type&quot;: &quot;Library_Fixed&quot;, &quot;uid&quot;: &quot;{b717c641-4145-44ac-8468-efb7afa451f1}&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry/CADModel&quot; } ], // 最后是 data group 的额外属性 &quot;name&quot;: &quot;CartesianGeometry&quot;, &quot;show&quot;: { &quot;show_name&quot;: &quot;CartesianGeometry&quot;, &quot;show_on_interface&quot;: true }, &quot;type&quot;: &quot;Library_Fixed&quot;, &quot;uid&quot;: &quot;{909515c3-d978-4021-943b-0d6e7fc3136d}&quot;, &quot;unique_name&quot;: &quot;/CartesianGeometry&quot; }, // 后面再添加类似的其他 data group ] Python 标准库中对 json 数据的处理在 Python 标准库中，自带 json 模块，可以使用 import json 来使用它。 主要的函数有如下几个： json.dumps：将 Python 对象序列化为 json 字符串 json.dump：将 Python 对象序列化为 json 对象 json.loads：将 json 字符串导入为 Python 对象 json.load：将 json 对象导入为 Python 对象 另外，json 模块还提供一个命令行接口 json.tool，可以在终端中使用，常用的例子如下： $ echo &#39;{&quot;json&quot;: &quot;obj&quot;}&#39; | python -m json.tool { &quot;json&quot;: &quot;obj&quot; } 另外最为常见的使用场景是读入 json 文件的数据，然后经过修改，再将 json 数据写回 json 文件中。 下面的代码就展示这两个常用的使用场景： # 打开文件将 json 数据读入 data_json 对象中 with open(modelFile) as f: data_json = json.load(f) # 打开新文件，将 data_json 数据写入新的 json 文件中 with open(modModleFile, &#39;w&#39;) as f: f.write(json.dumps(data_json, indent=2)) 常见处理 JSON 的 Python 软件包针对上面我们的需求，需要对复杂 JSON 数据做处理，所以就在网上进行了相关的搜索。针对 JSON 数据的筛选，搜索后知道有个 JSONPath 的提议，仿照XPath 的语法来查询 JSON 数据。 然后就根据 JSONPath 这个关键字在 PyPI 中搜索都了一些软件包，下面简单罗列一下： dpath主页：https://www.github.com/akesterson/dpath-python特点：使用类型 XPath 的语法来对复杂 json 数据做查询优点：如果熟悉 XPath 的话，可以快速上手缺点：无法做复杂的模糊查询，需要知道大致路径来获取数据 jsonpath主页：www.ultimate.com/phil/python/#jsonpath特点：是对上面 jsonPath 提议的一个实现，经过测试发现，相比于后面提及的这些软件，它的查询效率最高优点：查询效率高，单文件的实现缺点：缺乏文档，开发久远；但还在持续更新 jsonpath2主页：https://pypi.org/project/jsonpath2/特点：是对上面 jsonPath 提议的一个实现，有 ANTLR v4 的语法支持，可以生成 antlr 语法解析优点：支持 antlr 语法缺点：文档太少，只是 jsonPath 的又一个实现，特点不突出 jsonpath-rw主页：https://github.com/kennknowles/python-jsonpath-rw特点：提供健壮的实现，在 Python 2.7, 3.4, 3.5, 3.6, 3.7, pypy 和 pypy3 上都测试过； 实现早，开发者多（15），GitHub 上的星多（434）；优点：开发者多，将 jsonPath 表达式当做第一类对象缺点：无法对数据做复杂的筛选 jsonpath-rw-ext主页：https://github.com/sileht/python-jsonpath-rw-ext特点：对上面的 jsonpath-rw 做了一些扩展，尤其是对筛选的支持优点：支持筛选缺点：文档不是太详细，筛选似乎只支持 list jsonpath-ng主页：https://github.com/h2non/jsonpath-ng特点：结合了上面 jsonpath-rw 和 jsonpath-rw-ext 的能力，是 jsonpath-rw 的一个 fork优点：具有上面两个包的功能，才能使用；文档详细缺点：扩展的使用有点不太方便 在查找到了这些软件包后，我针对它们都进行了一些测试，最后测试后发现，在查询方面， jsonpath 这个包的解析速度最快。 注：同时引入 jsonpath 和 jsonpath-rw-ext 会引起冲突，我的解决办法是只安装 jsonpath-rw-ext ，将 jsonpath 的单文件实现直接放入代码中，要使用时再引入。 下面回到整体，介绍如何对复杂 JSON 数据进行查询、筛选和修改。 如何查询复杂 json 数据经过了上面的搜索，简单来说可以直接使用上面的多个软件包，然后按照 JsonPath 的语法来对复杂数据进行查询。 下面是 JsonPath 的提议，摘自上面提及的网址。 JSONPath 描述 $ 代表根对象 @ 代表当前对象 . 或 [] 取孩子操作 .. 递归搜索后代 * 通配符，代表所有对象 [] 取下标操作，在 JSON 中，它是自带的数组操作 [,] 表示去其中的任意一个 [start:end:step] 数组切片操作 ?() 执行筛选操作 () 脚本表达式，不常用 如何筛选复杂 json 数据基于前面的搜索，如果要实现对复杂 json 数据的筛选功能，当前就只能使用上面的 jsonpath-rw-ext 或者 jsonpath-ng ，其中 jsonpath-ng 的筛选功能来自于 jsonpath-rw-ext，所以在最后的解决方案中，我直接使用了 jsonpath-rw-ext 来做复杂筛选。 在使用时，为了支持变量值的替换，可能还需要使用转义符。 另外，在做筛选时，可以利用 jsonPath 中 .. @ 等运算符来做模糊筛选。 具体的使用方法可以参考上面两个软件包的主页。这里就不再介绍。 下面重点介绍如何修改 json 数据。 如何修改复杂 json 数据基于上面的说明，我们知道可以使用上面的这些软件包来查询复杂 json ，但是对于如何修改数据，这些软件的文档中都没有太多的涉及。 另外根据我做的这个任务的需求，可能还需要在对 json 数据做了筛选后，再对筛选到的数据做修改。 python-jsonpath-rw GitHub 主页上的 issue 21 上有类似的说明，但自己根据上的说明去实现时，感觉无法满足上面的需求，故作罢。 另外 python-jsonpath-rw 在代码仓库中似乎更新了一个 update 方法，但没有更新到 PyPI 中，所以必须下载 GitHub 的代码才能使用该功能。在最后的实现时便没有使用该功能。 最终，我在 stack overflow 上找到了一个参考的例子： from jsonpath_rw import jsonpath, parse data = {&quot;dogs&quot;:[{&quot;tail&quot;: True, &quot;properties&quot;:{&quot;test&quot;:1}}]} jsonpath_expr = parse(&quot;dogs.[0].properties&quot;) jsonpath_expr.find(data)[0].value[&#39;test&#39;] = 2 print(data) # {&#39;dogs&#39;: [{&#39;tail&#39;: True, &#39;properties&#39;: {&#39;test&#39;: 2}}]} 通过上面的例子我得到启发，可以使用 jsonpath-rw-ext 或者 jsonpath-ng 包的筛选功能，再使用上面例子中类型的做法来达到筛选并修改特定键值的目的，这样我的需求就可以解决了。 在经过测试后，最终用来修改 input 模板文件中给定键值对的代码如下： import json import jsonpath_rw_ext def Modify_model(refVar, refValue, modelFile, modModleFile=&#39;run.json&#39;): &quot;&quot;&quot;利用 jsonpath_rw_ext 库搜索 json 格式的模板文件，并修改相应的值 refVar: 需要修改的参数的名称 refValue: 修改过后参数的值 modelFile: json 格式的模板文件 modModleFile: 修改过后的 json 模板文件 &quot;&quot;&quot; with open(modelFile) as f: data_json = json.load(f) parse_str = f&#39;$..items[?(@.unique_name=\\&quot;{refVar}\\&quot;)]&#39; jsonpath_rw_ext.parser.ExtentedJsonPathParser().parse(parse_str).find(data_json)[0].value[&#39;value&#39;] = f&#39;{refValue}&#39; if not os.path.exists(modModleFile): # 如果不存在文件，则直接创建空文件 # ref: https://stackoverflow.com/questions/12654772/create-empty-file-using-python open(modModleFile, &#39;a&#39;).close() with open(modModleFile, &#39;w&#39;) as f: f.write(json.dumps(data_json, indent=2)) 上面的代码中有几点需要说明： parse_str = f&#39;$..items[?(@.unique_name=\\&quot;{refVar}\\&quot;)]&#39; 这句使用了 Python 的新语法，直接将 refVar 的值替换到字符串中，这需要 Python 3.6 才能支持。另外还转义了括号，使得这个函数更加通用； jsonpath_rw_ext.parser.ExtentedJsonPathParser() 这句是为了使用扩展功能才这样写的，具体的使用方法可以参考其主页章的文档； 根据 GitHub 上的 issue，似乎筛选功能只对 list 生效，相关代码在这里。","tags":[{"name":"Python","slug":"Python","permalink":"https://fsslc.github.io/tags/Python/"},{"name":"JSON","slug":"JSON","permalink":"https://fsslc.github.io/tags/JSON/"}]},{"title":"linux 下使用 matlab 的几个小提示","date":"2018-07-31T09:39:30.000Z","path":"2018/07/31/Tips-for-using-matlab-in-linux/","text":"linux 下使用 matlab 的几个小提示 MATLAB LOGO 嗯，对的，MATLAB 有 linux 版本的，而且 mathematica、maple 等软件都有，而且在 linux 下这些软件利用资源的效率更高。 在 linux 下安装这些软件没有太大的问题，写这篇文章的目的是记录在安装使用 matlab 时遇到的一些问题和解决的版本。 安装大部分都是直接使用桌面版本来安装 matlab 的。所以先说说这种方法。 安装无外乎以下几步： 下载到 iso 镜像：这个不用多说，自己找资源。 挂载或者解压：挂载使用 mount 命令即可。 使用命令行安装：运行目录里面的 install 脚本后就会出来图形界面，接下来的安装过程与 windows 下的安装过程没有什么区别了。 激活：参考资源内的说明文档。 如果需要在没有桌面的 linux 中安装 matlab，则需要编辑压缩包里面的 installer_input.txt 和 activate.ini 这两个文件，具体的安装过程请参考这篇文章。 终端使用 matlab一般启动 MATLAB 使用如下命令： matlab -nodesktop -nodisplay 跟启动相关的命令主要有如下几个： -nodesktop: 启动 jvm (Jave Virtual Machine)，不启动 desktop， 但 help 界面，preferences 界面等仍可通过 cmdline 调出，即 jvm 启动但不启动 desktop，可以启动其他显示； 但是 matlab 不会在 cmd history 记录本次执行的命令。 -nodisplay: 启动 jvm，不启动 desktop，不启动任何显示相关，忽略任何 DISPLAY 环境变量； 即 jvm 启动但不能显示。 -nojvm: 不启动 jvm，则与之相关的一切活动将无法进行，包括图形界面显示，help 界面，preferences界面等，即 jvm 不启动故不能显示。 -nosplash: 只是不显示启动时的log画面，jvm，desktop等正常启动 如果想在让在终端中实现画图，一般需要做以下两步： 使用 matlab -nodesktop 来启动 matlab； 在脚本中添加 figure(&#39;Visible&#39;,&#39;off&#39;); 这样的句子来抑制画图窗口的弹出。 可以使用 print 来保存图片。例如如下的命令：print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-dpng&#39;); print([&#39;pic/q01/q010&#39;,num2str(i)],&#39;-depsc&#39;); 记得要提前使用 mkdir 创建好在上级目录，图片名称的次级目录如果不存在，matlab 会自动创建。 matlab 使用 gpumatlab 里面对 gpu 的使用做了封装，如果需要使用 NVIDIA 的 gpu ， 一般需要安装 Bumblebee， 然后使用 optirun 来运行。具体可以参考如下几个链接： https://wiki.archlinux.org/index.php/NVIDIA_Optimus https://wiki.archlinux.org/index.php/Bumblebee matlab 里面可以通过 opengl info 来查看使用了什么 gpu。 几个常见问题下面的几个问题常常与 matlab 自带的几个动态链接库有关。一般把这些库备份后，将系统中安装的对应包链接到 matlab 里面就可以了。具体的问题见下面的详细解释 帮助系统没有 CSS 渲染效果字体问题常常与 libfreetype.so 这个动态链接库有关。所以解决办法无非以下几步： sudo mv /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6.BAK # 备份 sudo ln -sf /usr/lib64/libfreetype.so.6 /usr/local/MATLAB/R2017b/bin/glnxa64/libfreetype.so.6 # 链接 libGL error for MATLAB解决办法： ln -sf /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /opt/MATLAB/XXXXX(R2014b)/sys/os/glnxa64/libstdc++.so.6 # 或者执行 cd MATLAB_ROOT/sys/os/glnxa64/ sudo mv libstdc++.so.6 libstdc++.so.6.old 无法使用并行工具箱解决办法同上，链接系统的 libstdc++.so.6 这个动态库。 matlab 无法使用系统中文字体参考： https://bbs.archlinux.org/viewtopic.php?id=231299 cd /usr/local/MATLAB/R2017b # Matlab directory cd bin/glnxa64 mkdir exclude mv libfreetype* exclude cd ../../sys/os/glnxa64 mkdir exclude mv libstdc++.so.6* exclude 或者跟上面的解决方法类似，备份文件后做链接。","tags":[{"name":"matlab","slug":"matlab","permalink":"https://fsslc.github.io/tags/matlab/"},{"name":"linux","slug":"linux","permalink":"https://fsslc.github.io/tags/linux/"}]},{"title":"[翻译] 递归：梦中梦","date":"2018-05-06T15:24:21.000Z","path":"2018/05/06/Translate-Recursion--dream-within-a-dream/","text":"“方其梦也，不知其梦也。梦之中又占其梦焉，觉而后知其梦也。” —— 《庄子·齐物论》 递归是很神奇的，但是在大多数的编程类书藉中对递归讲解的并不好。它们只是给你展示一个递归阶乘的实现，然后警告你递归运行的很慢，并且还有可能因为栈缓冲区溢出而崩溃。“你可以将头伸进微波炉中去烘干你的头发，但是需要警惕颅内高压并让你的头发生爆炸，或者你可以使用毛巾来擦干头发。”难怪人们不愿意使用递归。但这种建议是很糟糕的，因为在算法中，递归是一个非常强大的思想。 我们来看一下这个经典的递归阶乘： #include &lt;stdio.h&gt; int factorial(int n) { int previous = 0xdeadbeef; if (n == 0 || n == 1) { return 1; } previous = factorial(n-1); return n * previous; } int main(int argc) { int answer = factorial(5); printf(&quot;%d\\n&quot;, answer); } 递归阶乘 - factorial.c 函数调用自身的这个观点在一开始是让人很难理解的。为了让这个过程更形象具体，下图展示的是当调用 factorial(5) 并且达到 n == 1这行代码 时，栈上 端点的情况： 每次调用 factorial 都生成一个新的 栈帧。这些栈帧的创建和 销毁 是使得递归版本的阶乘慢于其相应的迭代版本的原因。在调用返回之前，累积的这些栈帧可能会耗尽栈空间，进而使你的程序崩溃。 而这些担心经常是存在于理论上的。例如，对于每个 factorial 的栈帧占用 16 字节（这可能取决于栈排列以及其它因素）。如果在你的电脑上运行着现代的 x86 的 Linux 内核，一般情况下你拥有 8 GB 的栈空间，因此，factorial 程序中的 n 最多可以达到 512,000 左右。这是一个 巨大无比的结果，它将花费 8,971,833 比特来表示这个结果，因此，栈空间根本就不是什么问题：一个极小的整数 —— 甚至是一个 64 位的整数 —— 在我们的栈空间被耗尽之前就早已经溢出了成千上万次了。 过一会儿我们再去看 CPU 的使用，现在，我们先从比特和字节回退一步，把递归看作一种通用技术。我们的阶乘算法可归结为：将整数 N、N-1、 … 1 推入到一个栈，然后将它们按相反的顺序相乘。实际上我们使用了程序调用栈来实现这一点，这是它的细节：我们在堆上分配一个栈并使用它。虽然调用栈具有特殊的特性，但是它也只是又一种数据结构而已，你可以随意使用。我希望这个示意图可以让你明白这一点。 当你将栈调用视为一种数据结构，有些事情将变得更加清晰明了：将那些整数堆积起来，然后再将它们相乘，这并不是一个好的想法。那是一种有缺陷的实现：就像你拿螺丝刀去钉钉子一样。相对更合理的是使用一个迭代过程去计算阶乘。 但是，螺丝钉太多了，我们只能挑一个。有一个经典的面试题，在迷宫里有一只老鼠，你必须帮助这只老鼠找到一个奶酪。假设老鼠能够在迷宫中向左或者向右转弯。你该怎么去建模来解决这个问题？ 就像现实生活中的很多问题一样，你可以将这个老鼠找奶酪的问题简化为一个图，一个二叉树的每个结点代表在迷宫中的一个位置。然后你可以让老鼠在任何可能的地方都左转，而当它进入一个死胡同时，再回溯回去，再右转。这是一个老鼠行走的 迷宫示例: 每到边缘（线）都让老鼠左转或者右转来到达一个新的位置。如果向哪边转都被拦住，说明相关的边缘不存在。现在，我们来讨论一下！这个过程无论你是调用栈还是其它数据结构，它都离不开一个递归的过程。而使用调用栈是非常容易的： #include &lt;stdio.h&gt; #include &quot;maze.h&quot; int explore(maze_t *node) { int found = 0; if (node == NULL) { return 0; } if (node-&gt;hasCheese){ return 1;// found cheese } found = explore(node-&gt;left) || explore(node-&gt;right); return found; } int main(int argc) { int found = explore(&amp;maze); } 递归迷宫求解 下载 当我们在 maze.c:13 中找到奶酪时，栈的情况如下图所示。你也可以在 GDB 输出 中看到更详细的数据，它是使用 命令 采集的数据。 它展示了递归的良好表现，因为这是一个适合使用递归的问题。而且这并不奇怪：当涉及到算法时，递归是规则，而不是例外。它出现在如下情景中——进行搜索时、进行遍历树和其它数据结构时、进行解析时、需要排序时——它无处不在。正如众所周知的 pi 或者 e，它们在数学中像“神”一样的存在，因为它们是宇宙万物的基础，而递归也和它们一样：只是它存在于计算结构中。 Steven Skienna 的优秀著作 算法设计指南 的精彩之处在于，他通过 “战争故事” 作为手段来诠释工作，以此来展示解决现实世界中的问题背后的算法。这是我所知道的拓展你的算法知识的最佳资源。另一个读物是 McCarthy 的 关于 LISP 实现的的原创论文。递归在语言中既是它的名字也是它的基本原理。这篇论文既可读又有趣，在工作中能看到大师的作品是件让人兴奋的事情。 回到迷宫问题上。虽然它在这里很难离开递归，但是并不意味着必须通过调用栈的方式来实现。你可以使用像 RRLL 这样的字符串去跟踪转向，然后，依据这个字符串去决定老鼠下一步的动作。或者你可以分配一些其它的东西来记录追寻奶酪的整个状态。你仍然是实现了一个递归的过程，只是需要你实现一个自己的数据结构。 那样似乎更复杂一些，因为栈调用更合适。每个栈帧记录的不仅是当前节点，也记录那个节点上的计算状态（在这个案例中，我们是否只让它走左边，或者已经尝试向右）。因此，代码已经变得不重要了。然而，有时候我们因为害怕溢出和期望中的性能而放弃这种优秀的算法。那是很愚蠢的！ 正如我们所见，栈空间是非常大的，在耗尽栈空间之前往往会遇到其它的限制。一方面可以通过检查问题大小来确保它能够被安全地处理。而对 CPU 的担心是由两个广为流传的有问题的示例所导致的：哑阶乘dumb factorial和可怕的无记忆的 O( 2^n ) Fibonacci 递归。它们并不是栈递归算法的正确代表。 事实上栈操作是非常快的。通常，栈对数据的偏移是非常准确的，它在 缓存 中是热数据，并且是由专门的指令来操作它的。同时，使用你自己定义的在堆上分配的数据结构的相关开销是很大的。经常能看到人们写的一些比栈调用递归更复杂、性能更差的实现方法。最后，现代的 CPU 的性能都是 非常好的 ，并且一般 CPU 不会是性能瓶颈所在。在考虑牺牲程序的简单性时要特别注意，就像经常考虑程序的性能及性能的测量那样。 下一篇文章将是探秘栈系列的最后一篇了，我们将了解尾调用、闭包、以及其它相关概念。然后，我们就该深入我们的老朋友—— Linux 内核了。感谢你的阅读！ via: https://manybutfinite.com/post/recursion/publish: https://linux.cn/article-9609-1.html 作者：Gustavo Duarte译者：qhwdw校对：FSSlc 本文由 LCTT 原创编译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"递归","slug":"递归","permalink":"https://fsslc.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"减小 VBoX 虚拟磁盘大小","date":"2016-12-18T08:28:48.000Z","path":"2016/12/18/Decrease-VBoX-image/","text":"如何使用 VBOX 自带工具减小虚拟磁盘大小 由于在 Linux 下还没有完美解决 Windows 下一些必备软件（QQ,WPS,MS Office）的安装，所以我还是在 Linux 系统里面用虚拟机装了个精简版的 Win 7。Linux 下 Virtual Box 免费开源，所以我一般使用的是它。 虚拟机用着用着就会发现，它的虚拟磁盘变得越来越大，但虚拟机里面的系统可能并没有占用那么大的空间。所以有必要压缩一下。 问题来了，便开始上网搜索方法。在开源中国的一个博客里面找到了方法，下面进行简单的记录。 根据博主的文章，要达到减小 VBox 虚拟磁盘的大小，主要有两个步骤： 碎片整理首先需要在虚拟机里面的系统下做碎片整理。 对于 Linux 系统，可以使用： sudo dd if=/dev/zero of=/EMPTY bs=1M sudo rm -f /EMPTY 对于 Windows 系统，则需要使用 Sysinternals Suite，点击上面的链接可以到微软的页面下进行下载。下载解压后，通过 CMD ，运行： sdelete -z c: 等待进度完成即可。然后关闭虚拟机。 压缩磁盘如果虚拟磁盘是 Virtual Box 自家的 VDI 格式，则只需要先通过终端到达含有后缀为 .vdi 的文件所在的那个目录，再执行： VBoxManage modifyhd win7.vdi --compact 这样就可以达到压缩磁盘的目的。 如果虚拟磁盘是 VMDK 的格式，则可以使用 vmware 自带的 vmware-vdiskmanager 工具，具体命令如下： vmware-vdiskmanager -k disk.vmdk","tags":[{"name":"VBox","slug":"VBox","permalink":"https://fsslc.github.io/tags/VBox/"}]},{"title":"在 Archlinux 中安装 Opendx","date":"2016-12-15T08:02:31.000Z","path":"2016/12/15/Install-opendx-In-Archlinux/","text":"在 Archlinux 中安装 Opendx 前面 我说过， opendx 这个项目基本处于开发停滞状态。而 AFEPack 还是需要这个程序的。在 Ubuntu 下，可以直接输入命令 sudo apt install dx dxsamples 安装这个可视化软件。 现在我使用 Archlinux 这个滚动发行版本，软件仓库里面已经移除了这个软件， AUR 里面也没有它的编译脚本了。 UPDATE现在下面那个久未更新的镜像网站已经不存在了，而我也没有保存那个安装包，所以只好自己想办法了。还好 Debian 还在维护这两个包，所以我就借鉴它的编译脚本来写成适合 Archlinux 编译的脚本。目前通过我自己编写的编译脚本编译这两个软件包基本可以使用，但还是有点小问题： Debian 维护者里面的那个仓库中，包含很多与 Debian 系统相关的补丁，我只清理了一点，有些可能没有清理干净； 有时会占用 100% 的 CPU，到时直接杀掉那个进程即可(PS: htop这个工具非常好用，推荐大家使用)； 在 dx 的窗口中仍然不能直接达到 samples 目录。 自己编译又不想安装那么多的依赖，最后在国内某个久未更新的镜像网站 中找到了别人打包好的二进制文件，下载那个名为 opendx-4.4.4-2.pkg.tar.gz 的安装包后，可以直接使用命令 sudo pacman -U opendx-4.4.4-2.pkg.tar.gz 进行安装。 这样安装后，可能会有些依赖问题，例如我的系统里面会报 netcdf 和 tiff 的动态链接库找不到，而我已经安装了它们，所以只需要创建一些软链接就可以了。 sudo ln -s /usr/lib/libnetcdf.so.12.0.0 /usr/lib/libnetcdf.so.4 sudo ln -s /usr/lib/libtiff.so.5.2.4 /usr/lib/libtiff.so.3 最后附上我改写的编译脚本和相关的源文件： 链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxt 如果只需要编译这两个包，只需要下载 Opendx_AUR_build_scripts.zip 这个压缩包就行了。另外的东西是用来编译 AFEPack 的。","tags":[{"name":"Opendx","slug":"Opendx","permalink":"https://fsslc.github.io/tags/Opendx/"},{"name":"Archlinux","slug":"Archlinux","permalink":"https://fsslc.github.io/tags/Archlinux/"}]},{"title":"使用 docker 构建 AFEPack 镜像","date":"2016-12-15T07:24:09.000Z","path":"2016/12/15/Build-AFEPack-docker-image/","text":"使用 docker 构建 AFEPack 镜像来减少安装 AFEPack 的痛苦 先前写了一篇如何在 Ubuntu 安装 AFEPack 的教程，但现在感觉有些陈旧了。在暑假到澳门大学学习期间，结识了 xywei ， 他使用 docker 构建了 AFEPack，镜像地址在这里。先前也知道 docker 掀起的热潮，但一直没有学习它。 关于 docker 的学习，网上一搜一大堆。我自己买了本 杨保华、戴王剑、曹亚仑 编著的《Docker 技术入门与实践》，利用一个下午学会了基本操作，后面的有些功能自己用不到就没有再深究下去。闲话少说，下面进入正题。 安装 docker首先，要构建 docker 镜像，你需要安装 docker，具体安装过程见官网或者 Google 、Baidu 一下。 编写 Dockerfile要想实现自动构建 Docker 镜像，就需要编写 Dockerfile。只要知道 Dockerfile 编写时需要用的一些指令和编译安装的命令就可以了。 下面是我最后写好的 Dockerfile 。我在下面用中文添加注释，原文件参考我 GitHub 上的项目AFEPackDocker。 FROM ubuntu:16.04 # 以 ubuntu 16.04 作为镜像的基础系统 MAINTAINER FSSlc, liuchang011235 AT gmail DOT com # 维护者的相关信息 # install essential packages RUN \\ # RUN 后面跟上要运行的命令即可 mkdir -p /root/Pkg &amp;&amp; \\ # use aliyun&#39;s mirror for better download speed sed -i &#39;s/archive.ubuntu.com/mirrors.aliyun.com/g&#39; /etc/apt/sources.list &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get install -y make automake autoconf wget build-essential \\ libdeal.ii-dev mpi-default-dev nano # libhypre-dev trilinos-all-dev petsc-dev --no-install-recommends ## set some env varibles # 设置与 AFEPack 相关的环境变量 COPY env.txt /root/Pkg/env.txt ## prepare AFEPack easymesh RUN \\ cd /root/Pkg &amp;&amp; \\ wget http://dsec.pku.edu.cn/~rli/AFEPack-snapshot.tar.gz &amp;&amp; \\ wget http://dsec.pku.edu.cn/~rli/source_code/easymesh.c.gz &amp;&amp; \\ tar -xzf ./AFEPack-snapshot.tar.gz -C /root/Pkg/ &amp;&amp; \\ gunzip easymesh.c.gz &amp;&amp; \\ ## compile and install AFEPack cat /root/Pkg/env.txt &gt;&gt; /root/.bashrc &amp;&amp; . /root/.bashrc &amp;&amp; \\ cd /root/Pkg/AFEPack &amp;&amp; \\ # 将 ubuntu 中安装的 deal.ii 库文件改名 ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.g.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.g.so &amp;&amp; \\ ln -s /usr/lib/x86_64-linux-gnu/libdeal.ii.so.8.1.0 /usr/lib/x86_64-linux-gnu/libdeal_II.so &amp;&amp; \\ aclocal &amp;&amp; autoconf &amp;&amp; automake --add-missing &amp;&amp; \\ env EXTRA_INCDIR=&quot;-I/usr/include/deal.II/&quot; EXTRA_LIBDIR=&quot;-L/usr/lib/x86_64-linux-gnu/&quot; ./configure &amp;&amp; \\ # make -j8 &amp;&amp; make install # 下面分开编译 AFEPack，直接编译会报错，镜像就编译不下去了 cd ./template/ &amp;&amp; make -j8 &amp;&amp; cd ../library/ &amp;&amp; make -j8 &amp;&amp; make install &amp;&amp; \\ cd ../example/ &amp;&amp; make -j8 &amp;&amp; \\ ## compile and install easymesh cd /root/Pkg/ &amp;&amp; \\ gcc -o easymesh easymesh.c -lm &amp;&amp; \\ mv ./easymesh /usr/local/bin/ &amp;&amp; \\ ## do some clean work # 清理一些不需要的文件，减小镜像大小 rm easymesh.c AFEPack-snapshot.tar.gz env.txt &amp;&amp; \\ rm -rf /var/lib/apt/lists/* CMD [&quot;/bin/bash&quot;] UPDATE为了能够本地编译安装 AFEPack 的镜像，我编写了两个 Dockerfile，一个是直接使用Ubuntu 16.04 里面 8.1 版本的 deal.II，另一个是在 Ubuntu 14.04 里使用源码编译的 deal.II 6.3.1，请自行选择。 UPDATE 20181103好久没有更新了，最近在做 docker 相关的事。了解到 docker 可以进行所谓的多阶段构建了。这个功能可以进一步地减小镜像的大小，所以我今天就尝试了一下，效果还是很明显的。从原来的 1.07GB 减少到现在的 573MB。 另外 AFEPack 的包做了一些更新，居然默认 std=c++14 了！所以原来的 Dockerfile 可能不能使用了，所以我顺便做了更新。从构建的结果看，step-7 这个例子跑不通，这次更新后的 Dockerfile 都有这个问题，它们获取的AFEPack 源码都是今天我从官网下载的。但是我放在 docker Hub 的镜像可以运行。。。 使用 docker build 命令构建镜像编写完 Dockerfile 后，便可以构建镜像了。使用的命令是： sudo docker build -t afepack:v0 . 其中 -t 选项是指定编译后镜像的名称，即所谓的 tag 。 具体使用时，一般运行： docker run -ti -v $HOME/Pkg:/opt afepack:v0 bash 上面的命令将启动一个容器，其中的 -v 选项将把主机中的 $HOME/Pkg 目录挂载到容器中的 /opt 目录，这样我们便可以在 $HOME/Pkg 中让主机和容器之间进行数据交互。","tags":[{"name":"AFEPack","slug":"AFEPack","permalink":"https://fsslc.github.io/tags/AFEPack/"},{"name":"Docker","slug":"Docker","permalink":"https://fsslc.github.io/tags/Docker/"}]},{"title":"在 Ubuntu 中安装 AFEPack","date":"2015-11-03T06:02:55.000Z","path":"2015/11/03/Install-AFEPack-In-Ubuntu/","text":"在 Ubuntu 中安装 AFEPack Update相对来说这里的内容有些陈旧了，最近学了点 docker，便做了个 AFEPack 的 docker 镜像，若嫌安装麻烦，可以直接参考我的说明进行安装。 系统准备我现在使用的系统 Ubuntu 14.04，经过测试可以安装运行 AFEPack，其他的可能需要检验。（另：已经在 Linux Mint 、Ubuntu 16.04 安装成功。） 准备安装包首先，下载好 deal. II、AFEPack、mpich（非必须） 这几个软件的安装包。 其中的 deal. II 和 AFEPack 可以到我的百度网盘去下载，这个是我从我大学同学的未来的师兄那里获得的，而那位师兄的老师正是这个软件包的作者 李若 老师。由于高版本的 deal. II 版本经过了许多的修改，且鉴于 AFEPack 几乎停滞的开发状态，我们采用的是 deal. II 的 6.3.1 版本。而 mpich 则可以到官网去下载最新的稳定版本。 相关软件的下载地址为： deal.II 和 AFEPack : 链接: https://pan.baidu.com/s/1jxjO5wRhMjbQjqetQxSU6g 密码: utxtmpich : http://www.mpich.org/downloads/ 下载好这些包后，将他们进行解压备用。 安装必要软件接下来，安装一些必要的软件。 首先安装 boost 库。这个可以用命令行，也可以使用 synaptic (新得立) 这个图形化的包管理软件来安装。命令行需要使用的命令为： sudo apt-get install libboost-dbg libboost-all-dev 接着安装自动化产生 makefile 的相关工具。其中 aclocal 已经被包括在 autoconf 里了。 sudo apt-get install autoconf automake 接着安装编译器，由于某些原因，编译 AFEPack 时，用高版本(如 4.8)的 gcc 和 g++ 会出错，所以需要安装对应的低版本的包。这里安装 4.6 版本。 sudo apt-get install gcc-4.6 g++-4.6 gfortran # 降低 gcc，g++ 的版本，可以在后面改回来 cd /usr/bin sudo ln -s gcc-4.6 gcc sudo ln -s g++-4.6 g++ 安装 deal. II根据李若老师的解释，他选用这个包的原因是看上了这个包里面 lac 、 base 中的代码，即关于基础线性代数相关的代码写得很好，所以才采用了 deal. II 。所以我们可以只编译里面的部分文件，当然如果你不在乎占用一点额外的磁盘空间，也可以选择完整安装。 关于安装路径，下面以我的安装位置 /home/lc/Pkg/deal.II 来举例，其中 /home/lc 为我的家目录，可以对应地修改，也可以安装到其他路径，如 /usr/local/deal.II 等。 首先，进入解压后的 deal. II 目录，我的在 /home/lc/Pkg/deal.II 。 然后在终端中依次输入下面的命令，其中 # 后的内容为注释，可以忽略。 cd /home/lc/Pkg/deal.II # 进入解压后的 deal.II 目录 ./configure make -j4 lac base contrib # -j 选项是启用多线程，以此来加快编译的速度，后面的数字最好与你机子的 CPU 的线程数相同或更少 # 或者使用 make all 来完整安装 经过一段时间后(根据你的机器配置而定)，就把需要的文件编译好了。下面需要做一些软链接。在以前安装时，我尝试过直接把 deal. II 编译后产生的相应目录加在系统变量中，然后再安装 AFEPack，结果 AFEPack 不能找到 deal. II 的头文件，所以还是做个链接。具体的原因我也不清楚，可能需要问作者本人。 下面是我做链接时使用的命令，请相应做些修改： cd /usr/local/include sudo ln -s ~/Pkg/deal.II/deal.II/include/ . sudo ln -s ~/Pkg/deal.II/lac/include/lac/ . sudo ln -s ~/Pkg/deal.II/base/include/base/ . sudo ln -s ~/Pkg/deal.II/contrib/tbb/tbb22_20090809oss/include/tbb/ . # 这里的 tbb22_20090809oss 可能会有所不同，但一般这个目录都是以 tbb 开头的，可用 Tab 键来自动补全； # 最后的 `.` 代指当前目录 ，以下类型 cd /usr/local/lib sudo ln -s ~/Pkg/deal.II/lib/lib* . 安装 mpich这个不是必须的，除了 mpich，也可以直接安装OpenMPI。 这个的安装可以根据解压后文件夹中的指示来操作，一般都是如下几个命令： cd /home/lc/Pkg/mpich2/ # 进入 mpich2 解压后的目录，根据你自己的情况调整 ./configure make -j4 sudo make install 这样就安装好了 mpich。 当然，我们也可以直接使用软件源里面的 mpich，这样或许更省事些。 安装 AFEPack现在进行 AFEPack 的安装。首先利用 autotools 套件中的软件(即 aclocal，autoconf，automake 等)来自动生成 configure 文件。使用的命令如下： cd /home/lc/Pkg/AFEPack aclocal autoconf automake --add-missing 然后把 # AFEPack templete export AFEPACK_TEMPLATE_PATH=&quot;/home/lc/Pkg/AFEPack/template/triangle:/home/lc/Pkg/AFEPack/template/rectangle:/home/lc/Pkg/AFEPack/template/interval:/home/lc/Pkg/AFEPack/template/twin_triangle:/home/lc/Pkg/AFEPack/template/tetrahedron:/home/lc/Pkg/AFEPack/template/twin_tetrahedron:/home/lc/Pkg/AFEPack/template/four_tetrahedron&quot; 加到 ～/.bashrc 文件中，然后使用 source ~/.bashrc 来使更改生效。 接着对 AFEPack 进行配置和编译。 ./configure make -j4 编译期间会报错停掉，报 mpi.h 找不到。这时仍然继续，输入： make install 然后进入 AFEPack 目录下的 template 目录，来编译模板。我使用的命令为： cd /home/lc/Pkg/AFEPack/template make 现在来编译关于 mpi 的静态文件。这里需要 MPI 的相关库，这里我们使用的是 mpich。 ~/Pkg/AFEPack/library/mpi make -j4 example 子目录下有一些实用的工具，我们现在来编译它们。 cd ~/Pkg/AFEPack/example make -j4 最后执行下面的命令来使得 ld 能够找到 AFEPack.so 等静态库。 cd ～/Pkg/AFEPack sudo ldconfig 至此， AFEPack 的安装就结束了。 如果你在安装期间有什么问题，可以来询问我，我尽量帮忙。","tags":[{"name":"AFEPack","slug":"AFEPack","permalink":"https://fsslc.github.io/tags/AFEPack/"},{"name":"Deal. II","slug":"Deal-II","permalink":"https://fsslc.github.io/tags/Deal-II/"}]},{"title":"Ubuntu 下 Opendx Data Explorer 的字体问题","date":"2015-11-03T05:51:25.000Z","path":"2015/11/03/Cannot-convert-string-to-type-FontStruct/","text":"解决在 Ubuntu 下 Opendx Data Explorer 的字体问题 缘起最近一直在学习使用李若老师的 AFEPack 软件包，其中这个包输出的图形格式一般为 Opendx，但据网上的一些评论，它基本上处于类似渡渡鸟的境地了。但自己能力有限，还不能更改它输出为 Vtk 等现在主流的图像格式，所以还是先用着吧。 现在读取 opendx 格式的软件好像就只有 Opendx Data Explorer 了。自从 IBM 开源了 opendx 后，就没有多少官方的支持，现在它的开发主要由一个名为 Visualization and Imagery Solutions, Inc. 的公司负责。在 Ubuntu 中，可以直接通过软件源安装编译好的 dx 软件。 安装后，可以在终端中使用 dx 命令来启动 Opendx Data Explorer。但终端始终会出现类似如下的警告： Cannot convert string &quot;-*-helvetica-bold-r-*-*-16-*&quot; to type FontStruct 于是乎，便利用网络来搜索答案。下面是解决办法。 解决方法搜索的过程就不说了，反正还是 Google 强。 最开始说的是先确认下有没有安装这些字体。一般是先建议你安装两个字体包，使用的命令是： sudo apt-get install xfonts-75dpi xfonts-100dpi 它们默认是安装在 /usr/share/fonts/X11/ 目录中。 然后可以使用下面的命令来查看是否安装了上面警告中的字体： xlsfonts -fn &quot;-*-helvetica-bold-r-*-*-10-*-*-*-*-*-*-*&quot; 其中的 * 都是一些匹配。可以类似地修改匹配格式。 但是安装完后还是没有解决问题。于是又搜。 最后在这个网页里面找到了解决办法。 原来，在安装完这些字体后，我们还需要一些设置，具体的命令是： xset +fp /usr/share/fonts/X11/75dpi/ xset +fp /usr/share/fonts/X11/100dpi/ 至于上面的命令具体执行了什么步骤，可以 man xset 。随后问题便解决了。遇到类似的问题（例如某个软件中文乱码，呈现出方框），似乎都可以这样解决。 后话最后说说我对 OpenDX 的看法吧。 刚开始入门的时候，总感觉资料很少，这个软件不太好使用。相比于 ViSit 或 ParaView 等软件，dx 太难用了，什么都要自己定义，而且找到的资料也不是很多；所以对它的印象不好。 现在由于导师分配的任务，我需要使用 AFEPack 来求解方程，最后需要用 dx 来展示结果。通过这几天的摸索，感觉了它的强大。现在基本明白了为什么李若老师喜欢这种数据格式和这个软件的原因了。说到底，还是需要折腾。 至于学习资料。安装好 dx 后，一般可以在 /usr/share/dx/samples 找到示例代码；文档说明的话，可以看 /usr/share/dx/html 里面的东西，这些 html 文件里面包含的内容其实很多的。一步一步的看下去还是有很多收获的。 至于 Visualization and Imagery Solutions, Inc. 公司出的那本名为 OpenDX---Paths to Visualization 的书，我觉得自带的 html 文件内容或许更多一些，当然看看还是不错的。 以前我在这个网站找到了很多关于 Opendx 的资料，现在仍然推荐去看看那里的东西。 TODO： 通过 Ubuntu 仓库安装 dx 软件有一个问题： 在经过一段时间的使用后， dx 会吃掉 100% 的 CPU。根据我的搜索，现在还没有找到解决办法，自编译的 dx 就好像没有这个问题。后面再搜索一下吧。","tags":[{"name":"Font","slug":"Font","permalink":"https://fsslc.github.io/tags/Font/"},{"name":"Opendx","slug":"Opendx","permalink":"https://fsslc.github.io/tags/Opendx/"}]},{"title":"在 Ubuntu 中安装 FEniCS","date":"2015-10-12T04:32:13.000Z","path":"2015/10/12/Install-FEniCS-in-Ubuntu/","text":"在 Ubuntu 中安装 FEniCS FEniCS Logo Update 20161212现在容器大热，Fenics 也提供通过 docker 安装了，具体可以参看官网的说明。这样就可以少折腾了。 缘由最近导师去开了个会议，从其他人那里打听到有很多人都在 FEniCS 的基础上写代码了。导师她最开始认为，它是用来写 Fortran 代码的一个平台，加之她主要使用的编程语言为 Fortran，所以希望我们能够去学习一下。 第一次看到 FEniCS 这个词，应该可以追溯到我大四做毕业论文的时候。那时想找个软件来书写有限元程序，因为自己从底层开始写起太费事了。通过搜索，找到了许多软件，具体可以看看这个链接。通过试用，左右权衡，最后决定使用 deal. II 来做毕业论文。 当时对于 FEniCS 的认识是： 它是用 Python 写的，自己对 Python 不熟悉，查找到的资料不是很齐全； 当时自己尝试从 PPA 安装了 FEniCS， 但程序运行地不是很顺利； 现在，通过这一两天的使用，觉得这货实在是太简单了，用 Python 根据它自定义的 UFL 语言来自动生成可执行代码，最后使用 OpenGL 和 VTK 来生成图形和 vtu 文件。当然，方便的代价就是编译过程的时间有点长；毕竟鱼和熊掌是不能兼得的。 PS：FEnics 还可以与 C, C++, Fortran, 或 MATLAB 交互，具体可以看这里的文档。 FEniCS 的安装过程安装前的准备首先我的安装平台为 ubuntu 14.04, 64 位，但从自己安装的过程来看，其他系统应该也可以安装，大体步骤是一致的，具体可以看官网的说明。 特别说明：对于使用 Windows 系统的同学，你就别指望能够完美安装和运行 FEniCS 了，官网上说了， Windows 平台的安装包没有更新了。所以还是尽快学习一些 Linux 或 Unix 这类系统的使用方法吧。命令行真的非常好用，包管理器的使用也非常方便。 下面我是通过 Anaconda 这个 Python 集成环境来安装 FEniCS 的，所以你需要安装好 Anaconda。可以到官网的下载页面 去下载相应版本的安装包，这里我们使用的是 Anaconda-2.3.0-Linux-x86_64.sh，至于安装，该页面里有提示，这里不赘述了。 另外，在运行 FEniCS 的程序之前，需要安装好 gcc g++ gfortran 等编译器，不然会出现意想不到的错误。可以使用如下的命令来安装这些软件： sudo apt-get install build-essential gfortran 具体的安装过程根据官网的解释，有如下几种方法可以来进行安装： 直接添加 PPA 来进行下载。 但安装尝试后，会引入许多不必要的安装依赖如 texlive 等，为了不污染系统，所以没有采取这种方法。当然，如果你订阅了他们的 PPA，这种方式能够使你获取到最新的更新。如果你没有‘洁癖’，可以尝试这种方法。 (注： 最近(2015-12) 找到了如何在安装有 Texlive 发型包的情况下，不再引起上面需要安装 texlive 依赖的方法，具体请参考这篇文章的最后一段，但请自己制作 dummy package，因为在安装时，可能会出现一点问题，请根据问题的描述更改相应的配置文件。 ) 通过下载脚本编译。 通过下面的这个脚本来从源文件编译安装 FEniCS。 curl -s http://fenicsproject.org/fenics-install.sh | bash 但在尝试的过程中，总是提示 SSL 认证失败。无果，所以放弃了这种方法。 直接下载虚拟机镜像来运行。 将镜像导入 Vbox 后，大概用了 7G 的空间，镜像里的系统使用的是 Lubuntu，感觉很精简，但没有自己安装的 Ubuntu 体验好。又考虑到空间占用的原因，亦弃之。 通过 Anaconda 来安装 FEniCS。 可以根据这个网页的指导安装。 这个 github 仓库里面用的命令是： conda install fenics mkl --channel juanlu001 而官网里面使用的命令是： conda create --name fenics27 python=2.7 source activate fenics27 conda install fenics --channel juanlu001 我最开始是根据 Github 上的命令来安装的。而再给其他人安装的时候，我特别使用了官网了给出的命令，现在大致知道了它们之间的区别：前者是直接将 FEniCS 安装到 Anaconda 的目录里面，而后者是创建了一个新的环境，单独进行了安装。考虑到简洁性，我推荐第二个命令。 在终端中依次输入上面的命令后，会大概下载 300M 左右的安装包，最后安装完毕会有 4G 左右(加上 Anaconda 原来安装后的文件)。经过一段漫长的等待后，FEniCS 就安装好了。 安装后需要做的事安装完成后，自然需要运行一下 FEniCS 自带的示例程序，它们一般在 ~/anaconda/envs/fenics27/share/dolfin/ 目录下。随便进入某个示例目录，可以有名为 cpp 和 python 的两个目录。先进入 python 这个目录试试效果。 在终端运行： python filename.py # 注意请将这句中的 filename 换为具体的程序名称 然后终端会报错，大致意思是没有找到 dolfin 这个 module。这应该是环境变量的问题，最后通过搜索，参考这里的说明，我们需要将 dolfin.conf 这个文件加到 PYTHONPATH 环境变量中。命令为： source &lt;PATH_TO_YOUR_DOLFIN_INSTALLATION&gt;/share/dolfin/dolfin.conf 对于使用 Anaconda 安装 FEniCS 的情况，dolfin.conf 一般在 ~/anaconda/envs/fenics27/share/dolfin 目录里。 最好是将这个上面这个命令写入你本地的 .bashrc 文件里面，然后用 source ~/.bashrc 更新环境变量。 这个做完后，总该可以运行程序了吧。可惜，还不行。你会看终端里报错，提示说某些 VTK 的动态链接库找不到，根据 Github 里的 issue，需要使用下面的命令将 VTK 的版本降低： conda list vtk conda install &quot;vtk=5.10&quot; 这样就可以运行程序了。在程序执行的开始，你可能会看到有些提示，说 MKL 库有 30 天的试用期限，要你购买。对于这种情况，Anaconda 给学校和科研机构提供有学术版的许可，只要你使用 edu 的邮箱就可以申请到, 申请地址 。 申请后，会得到一个 license 文件，将其放在 ~/.continuum 目录下即可。 另外，我发现我自己申请的 license 同样也可以用在别人的机器上，不知这是不是一个 bug。 安装后软件的学习关于入门，可以直接看官网的文档，例如 tutorial，The FEniCS Book, Manual。 PS： 可以到这里下载到 The FEniCS Book。 关于这两天学习的感受：我是从 tutorial 入门的，看了过后感觉这货居然这么简单，相比于我用 deal. II 写代码，这不知要轻松多少倍。另外，tutorial 里面的例子有些代码不能运行了，应该是 dolfin(或其他组件) 更新的缘故，而文档还没有被更新。下一步继续看文档来学习。 以后深入后，再写点东西来分享。 UPDATE 2018.07.31有几点需要更新的： 偶然发现了这个 网站， 似乎是将 fenics 应用到 HPC 领域中，并且在 edx 中开了一门 MOOC 关于学习资源，可以看看 这个老师的主页，里面课程中有一些 notes。","tags":[{"name":"FEniCS","slug":"FEniCS","permalink":"https://fsslc.github.io/tags/FEniCS/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://fsslc.github.io/tags/Anaconda/"}]},{"title":"在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView","date":"2015-10-10T04:07:08.000Z","path":"2015/10/10/Set-up-Deal-II-VisIt-and-ParaView-in-Ubuntu/","text":"介绍如何在 Ubuntu 中安装设置 Deal. II、VisIt 和 ParaView Deal. II 的安装与配置 Deal. II Logo Deal. II 的安装关于安装，有如下几种方式： 到 dealii 的下载页面去下载打包好的文件： 对于 Ubuntu、Mac、Debain 都已经有编译好的二进制文件，Arch、Gentoo 可以分别通过 AUR 和 Gentoo Science Overlay 来得到； 利用 docker 来生成相关的镜像，具体可以参考这里； 基于源码安装： 官网上推荐 candi，也可以通过 spack来安装。 下面是我自己的安装过程，算是一个记录吧。 下载好源文件后，进行解压，然后进入解压的目录，具体安装方法可以通过 README.md 这个文件知晓。需要注意的是 deal. II 是一套有限元 C++ 库，所以在 Linux 上面需要进行编译安装。编译时，需要使用 cmake 和 make，所以先将这两个软件安装好。然后依次执行下面的命令来进行编译安装： cmake -DCMAKE_INSTALL_PREFIX=/path/where/deal.II/should/be/intalled/to .. make install # (alternatively $ make -j&lt;N&gt; install) 这里需要注意的是： 如果 dealii 的安装为一般用户不可写的目录，需要 sudo 命令； 为了加快编译的速度，在第二句中，在 make 后加上 -jN 参数，其中 N 最好不要超过电脑的最大 CPU 数目； 执行完上面的命令后，接着就是漫长的等待了。在我的机子上 (Ubuntu 14.04, x86_64, Intel® Core™ i5-2430M CPU @ 2.40GHz × 4，SSD) 编译安装总共花了将近 40 min；一般的机子大概需要 1 个小时左右。 Deal. II 的配置首先是 将 dealii 的目录加入系统环境变量之中，只需要在 ~/.bashrc 中加入如下几行代码即可： # dealii 环境变量 export PATH=/opt/deal.II:$PATH DEAL_II_DIR=/opt/deal.II 在具体使用时，主要使用这三个命令： cmake . make # 也可以直接使用 make release, 这样编译出来的出现运行快些 make run 关于 deal. II 的学习，开发者为自学者提供了详尽的文档，可以在 dealii 的下载页面里找到离线的文档，并且在 dealii 的安装目录下有文档中的示例代码； 另外，dealii 的主要开发者 Wolfgan Bangerth 还在他的教学网址上提供了讲义和授课的视频链接(不过视频在 YouTube 上)。 Update 20161210这里只是介绍了最简单的安装，要安装额外的软件库还需要自己去安装。可以参考 这里 中的命令来进行安装。当然，在 Ubuntu 、Debian 、Gento 中有官方支持的版本，如果嫌麻烦，可以直接用包管理器安装。 VisIt 的安装和配置 VisIt Logo VisIt 的安装安装方面，首先到官网的下载页面里下载相关的包，并在同一页面下载 Visit install script 文件，具体安装过程，可以参考同一页面的 Visit install notes 。 VisIt 的配置关于配置，在 ~/.bashrc 中加入如下几行代码来添加环境变量： # visit 环境变量 export PATH=/opt/visit:$PATH 当然，如果你想和我一样，想为 VisIt 添加一个快捷方式，来达到 在系统的应用里面直接点击图标就启动软件的目的，可以按照下面方法来进行。 首先创建一个名为 visit.desktop 的文件，然后进行编辑，将如下的内容复制到该文件中(当然你可以进行自定义)： [Desktop Entry] Version=2.8.1 Type=Application Name=VisIt GenericName=image viewer Comment=VisIt is an Open Source, interactive, scalable, visualization, animation and analysis tool. Exec=/opt/visit/bin/visit Terminal=false MimeType=image/vtk; Icon=/opt/visit/visit.jpg Categories=Development;Graphics;Viewer; StartupNotify=true Actions=Window;Document; 注意: 上面的 Icon 后面的图片是我从 visit 官网里下载的，当然可以使用其他图片。 最后保持修改的文件，然后将该文件移动到 /usr/share/applications/ 目录中。当然，你也可以直接在这个目录中创建这个文件。这样，你就可以在系统的应用中找到 visit 了，通过点击图标就可以启动 visit。 Paraview 的安装和配置 paraview Logo Paraview 的安装当然，对于各种发行版本，对应的软件仓库里面可能已经有 paraview 的二进制包了，可以直接用相应的包管理器下载安装。 下面介绍的是自己手动安装 paraview 的过程。 首先到官网的下载页面上选择适合自己机子的相应压缩包并下载。然后解压，将解压的文件夹复制到需要安装的位置即可。 Paraview 的配置关于配置，和 visit 基本相似。 首先添加环境变量： # paraview 环境变量 export PATH=/opt/paraview:$PATH 然后制作图标；方法与上面一致，这里只列出 paraview.desktop 文件的内容： [Desktop Entry] Version=4.2 Type=Application Name=Paraview GenericName=image viewer Comment=ParaView is an open-source, multi-platform data analysis and visualization application Exec=/opt/paraview/bin/paraview Terminal=false MimeType=image/vtk; Icon=/opt/paraview/share/icons/hicolor/96x96/apps/paraview.png Categories=Development;Graphics;Viewer; StartupNotify=true Actions=Window;Document; 结语写这个文档的目的主要是为了进行一些纪录，好在遗忘的时候可以查看，也当做是备份。有限元软件当然不止这几个，还有如 gmesh、freefem++、getfem++ 等等，这里就不介绍了。总之学习之路漫漫，吾将上下而求索。","tags":[{"name":"Deal. II","slug":"Deal-II","permalink":"https://fsslc.github.io/tags/Deal-II/"},{"name":"Paraview","slug":"Paraview","permalink":"https://fsslc.github.io/tags/Paraview/"},{"name":"VisIt","slug":"VisIt","permalink":"https://fsslc.github.io/tags/VisIt/"}]},{"title":"[翻译] 让你玩转 Ubuntu 桌面的十一件武器","date":"2015-03-11T01:00:00.000Z","path":"2015/03/11/Translate-11-Useful-Utilities-To-Supercharge-Your-Ubuntu-Experience/","text":"介绍一些工具来调整和优化 Unity 桌面的外观、行为、性能 无论你是一个相对的新手还是经验丰富的专家，我们都想从我们的操作系统中得到更多的东西。正如大多数现代的操作系统，相比于乍一看呈现出的内容，Ubuntu 还有更多东西可以向我们提供。 从调整和优化 Unity 桌面的外观、行为、性能到执行系统维护，这里有大量的实用工具和应用可以帮助你调整 Ubuntu ，随时满足你的需求。 注意： Ubuntu 总是配备了‘合理的默认设置’（即工作良好的选项），以达到开箱即用，这些默认设置适合大多数人，并且它们都是经过了测试、采用及推荐等过程的。 但一个尺码并不适合所有人。对于我们当中的能工巧匠和实验主义者来说，默认设置只是他们定制系统的起点。 所以，无需更多的唠叨， 这里有 11 个极好的实用工具可以帮助你增强 Ubuntu 使用体验。 Unity Tweak Tool 我将以这个列表中最重要的一个工具: Unity Tweak Tool 来开始这次的介绍。融汇了各种定制选项，Unity Tweak Tool 提供了一系列针对 Ubuntu 和 Unity 桌面的系统综合调整功能。 它被各种开关、切换和控制器塞得满满的，使得你可以任意设置从 Unity 桌面的外观到 Unity 的行为之类的任何东西。你可以使用它快速简便地改变 GTK 主题和图标集、设置热区、调整启动器图标尺寸、增加或移除工作区，以及 —-特别地—-开启 Unity 桌面中被巧妙隐藏的“通过点击最小化”的功能。 它是免费的，可直接从 Ubuntu 软件中心里找到， Unity Tweak Tool 是非常值得保留在你的口袋里的工具之一。 Unity 隐私指示器 隐私是一个非常、非常重要的事，事实也恰恰如此，但这个话题要比二进制还难以说明白。让一些数据或习惯，比如说你经常打开的应用，在本地被记录下来，这或许会让你感到高兴，但对于你在 Dash 中的搜索数据被发送到第三方服务机构(尽管这些数据或许是匿名的)这类事情，你就高兴不起来了。 隐私指示器 是一个帮助你时刻跟踪 Ubuntu桌面系统中有哪些文件、目录和服务正被获取、记录及搜索的实用工具。 通过快速的点击被添加到桌面面板上的‘眼睛’图标，你可以： 开启或关闭在线搜索结果，使用 Zeitgeist 记录系统活动，存储 HUD 使用记录和启用 Ubuntu GeoIP 服务 快速清理 Zeitgeist 日志、 ALT-F2 历史、最近访问文件等等的记录数据 展示或隐藏桌面图标及面板上显示的用户名 上述的最后一条的功能似乎不应该出现在这个应用程序中，但对于那些要分享截图或截屏的人来说，这将会泄露更少的隐私。 从这里下载隐私指示器 (.deb) Unity 橱窗 Android, iOS, OS X, Chrome OS, 和 GNOME Shell 都有应用橱窗, 借助一个极好的第三方应用，Unity 也可以实现类似功能。 “Unity 橱窗” 允许你将 Unity 启动器中的应用分组到实用的橱窗中，—- 如游戏，办公，社交等。不必打开 Dash，你就可以快速启动你喜爱的应用，这非常适合你的工作流。 每一个 ‘橱窗’其实上是一个打开在图标附近的应用窗口，但总体效果看上去就像是一个 OS X 风格的“堆栈”或 Android 的分组框。 橱窗的图标可以自定义或根据橱窗内的应用来自动生成。已有的橱窗可以修改和重新组织、重命名以及如下的更多选择： 根据你的喜好创建任意多的橱窗 选择自定义或自动生成橱窗图标 可选择 3 种橱窗样式 为添加到橱窗中的应用设定自定义图标 编辑现有橱窗 Unity 橱窗的网址 咖啡因（Caffeine）对于我们中的许多人来说，咖啡因是必需品，而不仅仅是饮料。而这里的“咖啡因”则提供了一个快速，温和的方式来避免屏保/锁屏占据屏幕。它的有用程度将取决于你的环境(即你系统的怪癖)，并且尽管它不像以前那样好用，它仍然值得你尝试一下。 下载咖啡因（Caffeine） 系统监控指示器 假如你是一个状态迷，即一个喜欢密切关注程序，进程和硬件的状态的人， Linux 很容易满足你的需求。从 Conky 的配置到终端命令，并不缺少监视你的 CPU 使用情况、网络流量或 GPU 温度的方法。 但至今为止，我最喜爱的应用是系统监控指示器（也被叫做多负载指示器），它可从 Ubuntu 软件中心获得。它也有着大量的配置选项。 点击这个链接，在 Ubuntu 中下载 ‘系统监控指示器’ 针对 Linux 笔记本电脑的省电工具 TLP当提到便携式设备上的电池使用效率时，Linux 发行版的声誉并不算好。 如果你的 Linux 笔记本在重新充电前，电池只够让你从沙发走到厨房的话，那么这里有几个你可以试试的工具。 TLP 是最受欢迎的确保延长 Linux 笔记本的电池寿命的自动化后台工具之一，它是通过调整系统进程和硬件的设置及行为来达成省电的，例如 启动 Wi-Fi 省电模式， PCI 总线设备的实时电量管理和处理器的降频调整。 在 Ubuntu 14.04 LTS 以及后续发行版本中可以使用 TLP 专用的 PPA 来安装它，通过它的‘一下搞定’的设置就能用起来。在我们之中的高级用户可以潜心研究并根据你自己的硬件来调整设置，一个关于 TLP 的完整指导 wiki 使得设置更加容易。 Laptop Mode Tools假如 TLP 听起来有一点复杂，这也并没有什么可羞耻的，这里有一个更简单的替代品： Laptop Mode Tools。 这个软件包可从 Ubuntu 软件中心直接安装，且本身设置好了一系列合理的默认设置(Wi-Fi,蓝牙等等)。 切记，Laptop Mode Tools 不能和 TLP 同时被安装在电脑中。 Ubuntu 软件中心里的 Laptop Mode Tools Intel 显卡驱动安装工具 对于那些运行 Intel 显卡硬件，并想使得这些硬件发挥出最佳性能的人来说，Intel 显卡安装工具是必须拥有的。 它使得查找并安装最新的 Intel GPU 驱动变得不再是一件痛苦和大费周折的事，因为这无需 PPA 或任何的终端使用知识。 下载针对 Linux平台的 Intel 显卡驱动安装器 0.7 版本 硬件信息 假如你计划升级你的 PC 或想替换一个坏掉的零部件，你需要知道一些特定的硬件信息，例如 RAM 类型，CPU插座类型 或查看哪个 PCI 槽是可用的等信息。 I-Nex可以使得找出这些以及其他的系统具体配置变得更加容易。使用它来查找你的主板型号、S.M.A.R.T.(注：为 Self-Monitoring, Analysis and Reporting Technology 的缩写，经常写为 SMART ) 状态，以及你想的出的很多东西！ 可从 Launchpad 了解到更多关于 I-Nex 的信息 磁盘空间可视化程序 在这个硬盘以 TB 计数的时代，我们或许不必同以前一样对硬盘空间的使用三思而后行。但对于那些使用小容量的 SSD，分成多个分区或在一个拥有固定大小的虚拟磁盘的虚拟机上工作的人来说，总有“应该释放一些额外空间是必要的”这种想法的时候。 GNOME Disks，在 Ubuntu 中被默认安装，使得查找占用最大磁盘空间的罪魁祸首变得容易。对于定位隐藏的日志、缓存和视频文件，它是非常完美的工具。 BleachBit (Cruft Cleaner) Windows 用户可能对像 CCleaner 之类的应用很熟悉，它可以扫描并清理垃圾文件、空白文件夹、臃肿的缓存以及陈旧的软件包。在 Ubuntu 上，一个相似的快速且毫不费力的一键式清理方法可以试试 BleachBit 。 它是一个强大的工具，所以一定要注意你正在清理什么。不要漫无目的地确认每个选项框；不是所有的东西它都可以清理。所以请合理地使用它，当你对某个选项有疑问时，就跳过它。 从 Ubuntu 软件中心里安装 BleachBit 你已经有了自己最喜欢的系统实用工具了吗？可以在下面的评论中让其他人知晓它。 via: http://www.omgubuntu.co.uk/2014/11/useful-tools-for-ubuntu-do-you-use-thempublish: https://linux.cn/article-5025-1.html 作者：Joey-Elijah Sneddon译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://fsslc.github.io/tags/Ubuntu/"},{"name":"桌面","slug":"桌面","permalink":"https://fsslc.github.io/tags/%E6%A1%8C%E9%9D%A2/"}]},{"title":"[翻译] dupeGuru - 直接从硬盘中查找并移除重复文件","date":"2015-03-05T03:38:00.000Z","path":"2015/03/05/Translate-dupeGuru-Find-And-Remove-Duplicate-Files-Instantly-From-Hard-Drive/","text":"介绍使用 dupeGuru 来查找并删除重复文件 简介对我们来说，磁盘被装满是棘手问题之一。无论我们如何小心谨慎，我们总可能将相同的文件复制到多个不同的地方，或者在不知情的情况下，重复下载了同一个文件。因此，迟早你会看到“磁盘已满”的错误提示，若此时我们确实需要一些磁盘空间来存储重要数据，以上情形无疑是最糟糕的。假如你确信自己的系统中有重复文件，那么 dupeGuru 可能会帮助到你。 dupeGuru 团队也开发了名为 dupeGuru 音乐版 的应用来移除重复的音乐文件，和名为 dupeGuru 图片版 的应用来移除重复的图片文件。 1. dupeGuru (标准版)需要告诉那些不熟悉 dupeGuru 的人，它是一个免费、开源、跨平台的应用，其用途是在系统中查找和移除重复文件。它可以在 Linux, Windows, 和 Mac OS X 等平台下使用。通过使用一个快速的模糊匹配算法，它可以在几分钟内找到重复文件。同时，你还可以调整 dupeGuru 使它去精确查找特定文件类型的重复文件，以及从你想删除的文件中，清除某种文件。它支持英语、 法语、 德语、 中文 （简体）、 捷克语、 意大利语、亚美尼亚语、俄语、乌克兰语、巴西语和越南语。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGurudupeGuru 开发者已经构建了一个 Ubuntu PPA (Personal Package Archives)来简化安装过程。想要安装 dupeGuru，依次在终端中键入以下命令： sudo apt-add-repository ppa:hsoft/ppa sudo apt-get update sudo apt-get install dupeguru-se 使用使用非常简单，可从 Unity 面板或菜单中启动 dupeGuru。 点击位于底部的 + 按钮来添加你想扫描的文件目录。点击 扫描 按钮开始查找重复文件。 一旦所选目录中含有重复文件，那么它将在窗口中展示重复文件。正如你所看到的，在下面的截图中，我的下载目录中有一个重复文件。 现在，你可以决定下一步如何操作。你可以删除这个重复的文件，或者对它进行重命名，抑或是 复制/移动 到另一个位置。为此，选定该重复文件，或在菜单栏中选定写有“仅显示重复”选项 ，如果你选择了“仅显示重复”选项，则只有重复文件在窗口中可见，这样你便可以轻松选择并删除这些文件。点击“操作”下拉菜单，最后选择你将执行的操作。在这里，我只想删除重复文件，所以我选择了“移动标记文件到垃圾箱”这个选项。 接着，点击“继续”选项来移除重复文件。 2. dupeGuru 音乐版dupeGuru 音乐版 或简称 dupeGuru ME，它的功能与 dupeGuru 类似。它拥有 dupeGuru 的所有功能，但它包含更多的信息列 （如比特率，持续时间，标签等）和更多的扫描类型（如带有字段的文件名，标签以及音频内容）。和 dupeGuru 一样，dupeGuru ME 也运行在 Linux、Windows 和 Mac OS X 中。 它支持众多的格式，诸如 MP3、WMA、AAC (iTunes 格式)、OGG、FLAC，以及失真率较少的 AAC 和 WMA 格式等。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru ME现在，我们不必再添加任何 PPA，因为在前面的步骤中，我们已经进行了添加。所以在终端中键入以下命令来安装它： sudo apt-get install dupeguru-me 使用你可以从 Unity 面板或菜单中启动它。dupeGuru ME 的使用方法、操作界面以及外观和正常的 dupeGuru 类似。添加你想扫描的目录并选择你想执行的操作。重复的音乐文件就会被删除。 3. dupeGuru 图片版dupeGuru 图片版,或简称为 duepGuru PE，是一个在你的电脑中查找重复图片的工具。它和 dupeGuru 类似，但独具匹配重复图片的功能。dupeGuru PE 可运行在 Linux、Windows 和 Mac OS X 中。 dupeGuru PE 支持 JPG、PNG、TIFF、GIF 和 BMP 等图片格式。所有的这些格式可以被同时比较。Mac OS X 版的 dupeGuru PE 还支持 PSD 和 RAW (CR2 和 NEF) 格式。 在 Ubuntu 14.10/14.04/13.10/13.04/12.04 中安装 dupeGuru PE由于我们已经添加了 PPA，我们也不必为 dupeGuru PE 再次添加。只需运行如下命令来安装它。 sudo apt-get install dupeguru-pe 使用就使用方法，操作界面和外观而言，它与 dupeGuru，dupeGuru ME 类似。我就纳闷为什么开发者为不同的类别开发了不同的版本。我想如果开发一个结合以上三个版本功能的应用，或许会更好。 启动它，添加你想扫描的目录，并选择你想执行的操作。就这样，你的重复文件将被清除。 如果因为任何的安全问题而不能移除某些重复文件，请记下这些文件的位置，通过终端或文件管理器来手动删除它们。 欢呼吧！ via: http://www.unixmen.com/dupeguru-find-remove-duplicate-files-instantly-hard-drive/publish: https://linux.cn/article-4992-1.html 作者：SK译者：FSSlc校对：Caroline 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"重复文件","slug":"重复文件","permalink":"https://fsslc.github.io/tags/%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6/"},{"name":"dupeGuru","slug":"dupeGuru","permalink":"https://fsslc.github.io/tags/dupeGuru/"}]},{"title":"[翻译] 怎样通过 Twitter 的开源库来随处使用 Emoji 表情符号","date":"2015-02-28T12:53:00.000Z","path":"2015/02/28/Translate-How-To-Use-Emoji-Anywhere-With-Twitter-s-Open-Source-Library/","text":"通过 GitHub 将它们嵌入到网页和其他项目中 Emoji, 来自日本的小巧符号，通过图像表达感情，已经征服了移动互联网的信息世界。 现在，你可以在虚拟世界中随处使用它们了。 Twitter 最近开源了他们的 emoji 符号库，使得你可以在你自己的网站，应用，和项目中使用它们。 但这需要一点体力活。 Unicode 已经识别甚至标准化了 emoji 字母表， 然而 emoji 仍然不能完全与所有的网络浏览器相兼容，这意味着大多数情况下，它们将呈现为 “豆腐块”或“空白盒子”。当 Twitter 想使得 emoji 到处可用时，这家社交网络联合了一家名为Icon Factory的公司来渲染浏览器以模仿文本信息符号的效果。Twiter 认为人们对他们的 emoji 库有很大的需求。 现在， 你可以从 GitHub 上克隆 Twitter 的整个库，从而在你的开发项目中使用它们。 下面将为你介绍如何达到上面的目的以及如何使得 emoji 更容易被使用。 为 Emoji 得到 Unicode 支持Unicode 是国际编码标准，它为任意的符号、字母或人们想在网络上使用的数字配置了一串编码。换句话说，它是你如何在计算机上阅读文本与计算机如何读取文本之间的缺失环节。例如，对于你正看到的位于这些句子中的空格（LCTT 译注：英文分词中间的空格），计算机读取为 “&amp;nbsp”。 Unicode 甚至拥有其自己的原始 emoji，它们可以在没有你的任何努力的情况下在浏览器中被阅读。例如，当你看到了 一个 ❤ 符号，你的计算机正在解码字符串 “2665” 。 要在大多数情况下使用 Twitter 的 emoji 库，你只需在你的 HTML 网页中的 &lt;head&gt;块中添加如下脚本： &lt;script src=&quot;//twemoji.maxcdn.com/twemoji.min.js&quot;&gt;&lt;/script&gt; 这样就使得你的项目可以访问包含有已经在 Twitter 中可使用的数以百计的 Emoji 符号的 JavaScript 库。然而，创建一个仅仅包含这个脚本的文档并不能使得在你的网站中呈现出 emoji 符号，实际上，你仍需要嵌入这些 emoji 符号！ 在 &lt;body&gt;块中，粘贴一些可以在 Twitter 的preview.html 文件源代码 中找到的 emoji 字符串。我使用了 &#x1F3B9; 和 &amp;#x1F3C1，当然我并不知道在浏览器窗口中它们的样子。是的，你必须粘贴并猜测它们。你已经看出了问题，我们将在第二小节中予以解决。 无论如何，通过一些尝试，你可以将一个如下图的原始 HTML 文件 显示为如下图的网页： 将 Emoji 转换为可阅读的语言对于一个网站或应用，Twitter 的解决方案是非常适用的。但如果你想通过 HTML 轻易地插入你喜爱的 emoji 符号，你需要一个更易实现的解决方案，而不是记住所有代表 emoji 的 Unicode 字符串。 那正是程序员 Elle Kasai 的 Twemoji Awesome 样式大展身手的地方。 通过向任意网页中添加 Elle 的开源样式表，你可以适用 英语单词来理解你正插入的 emoji 符号的意义。所以如若你想展示一个 心形 emoji 符号，你可以简单地输入： &lt;i class=&quot;twa twa-heart&quot;&gt;&lt;/i&gt; 为了实现上面的目的，让我们下载 Elle 的项目，通过点击在 GitHub 上 “Download ZIP” 按钮。 接着，我们在桌面上新建一个文件夹，然后进入该文件夹，并将 emoji.html—-我先前向你展示的 HTML 源文件—- 和 Elle 的 twemoji-awesome.css 一同放进去。 我们还需要 HTML 文件识别这个 CSS 文件，所以在 html 网页中的 &lt;head&gt; 块中，为 CSS 文件添加一个链接： &lt;link rel=&quot;stylesheet&quot; href=&quot;twemoji-awesome.css&quot;&gt; 一旦你将上面的代码添加了进去，你便可以删除先前添加的 Twitter 的脚本链接。 现在，找到 body 块部分的代码，然后添加一些 emoji 符号。我使用了 &lt;i class=&quot;twa twa-sparkling-heart&quot;&gt;&lt;/i&gt;, &lt;i class=&quot;twa twa-exclamation&quot;&gt;&lt;/i&gt;, &lt;i class=&quot;twa twa-lg twa-sparkles&quot;&gt;&lt;/i&gt; 和 &lt;i class=&quot;twa twa-beer&quot;&gt;&lt;/i&gt;。 最终，你将得到如下的代码： 保存并在浏览器中查看上面的文件： Duang！这样你不仅得到了一个可以在浏览器中支持 emoji 符号的基本网页，而且还知道了如何简单地实现它。你可以随意的在我的 GitHub 中查看这个教程，并且可以克隆这些实际的文件而不只是看看这些截图。 题图来自于得到 Emoji； Lauren Orsini 截图。 via: http://readwrite.com/2014/11/12/how-to-use-emoji-in-the-browser-windowpublish: https://linux.cn/article-4961-1.html 作者：Lauren Orsini译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Emoji","slug":"Emoji","permalink":"https://fsslc.github.io/tags/Emoji/"}]},{"title":"[翻译] 怎样在 Linux 系统中恢复已删除文件","date":"2015-02-25T04:51:50.000Z","path":"2015/02/25/Translate-Undelete-Files-on-Linux-Systems/","text":"介绍如何使用 TestDisk 在 Linux 系统中恢复已删除文件 当用户意外地删除了一个仍然需要的文件时，大多数情况下，是没有简便的方法可以重新找回或重建这个文件。不过，幸运的是文件是可以通过一些方法恢复的。当用户删除了一个文件，该文件并没有消失，只是被隐藏了一段时间。 这里将解释它是如何工作的。在一个文件系统中，有一个叫做 文件分配表 的东西，这个表跟踪文件在存储单元（如硬盘， MicroSD 卡，闪存驱动器等等）中的位置。当一个文件被删除，文件系统将会在文件分配表中执行以下两个任务之一：这个文件在文件分配表上的条目被标记为 “自由空间” 或删除文件分配表里这个文件的条目，且将相应的空间被标记为自由空间 。现在，如果有一个新的文件需要被放置在一个存储单元上，操作系统将会把这个文件放置到标记为空位的地方。在新文件被写入到这个空位后，被删除的文件就彻底消失了。当需要恢复一个已经删除的文件时，用户绝对不能再对任何文件进行操作，因为假如该文件对应的“空位”被占用，这个文件就永远也不能恢复了。 恢复软件是如何工作的？大多数的文件系统（在删除文件时）只是标记空间为空白。在这些文件系统下，恢复软件查看文件分配表这个文件，然后复制被删除的文件到另外的存储单元中。假如该文件被复制到其它需要恢复的被删除的存储单元中，那么用户将有可能会失去那个所需的删除文件。 文件系统很少会擦除文件分配表中的条目。假如文件系统真的这样做了， 这便是恢复软件在恢复文件了。恢复软件在存储单元中扫描文件头，所有文件都拥有一个特殊的编码字符串，它们位于文件的最前面，也被叫做 魔法数字。例如，一个编译的 JAVA 类文件的魔法数字在十六进制中是“CAFEBABE”。所以，假如要恢复该类型的文件，恢复软件会查找 “CAFEBABE” 然后复制文件到另一个存储单元。一些恢复软件可以查找某种特殊的文件类型。若用户想恢复一个 PDF 文件，则恢复软件将会查找十六进制的魔法数字 “25504446”，这恰恰是 ASCII 编码中的 “%PDF”。恢复软件将会查找所有的魔法数字，然后用户可以选择恢复哪个已删除的文件。 假如一个文件的部分被覆写了，则整个文件就会被损坏。通常这个文件可以被恢复，但是其中的内容可能已经没有什么用处。例如，恢复一个已损坏的 JPEG 文件将会是无意义的，因为图片查看器不能从这个损坏的文件产生一幅图片。因此，即使用户拥有了这个文件，该文件也将毫无用处。 设备的位置：在我们继续之前，下面的一些信息将会对指引恢复软件找到正确的存储单元起到一定的帮助。所有的设备均挂载在 /dev/ 目录下。操作系统赋予每个设备的名称（并不是管理员给予每个分区或设备的名称）遵循一定的命名规律。 第一个 SATA 硬盘的第二个分区的名称将会是 sda2。名称的第一个字母暗示了存储类型，在这里指的是 SATA，但字母 “s” 也可能指的是 SCSI、 FireWire（火线端口）或 USB。第二个字母 “d” 指的是 disk(硬盘)。第三个字母指的是设备序数，即字母 “a” 指的是第一个 SATA 而 “b” 指的是第二个。最后的数字代表分区。没有分区数字的设备名代表该设置的所有分区。对于上面的例子，对应的名称为 sda 。作为命名的第一个字母还可能是 “h” ，这对应 PATA 硬盘（IDE）。 以下为命名规律的一些例子。假如一个用户有一个 SATA 硬盘（sda），这个设备有 4 个分区- sda1、 sda2、 sda3 和 sda4 。该用户删除了第三个分区，但直到格式化第四个分区之前，第四个分区名 sda4 都将保留不变。然后该用户插入了一个带有一个分区 - 即sdb1- 的 usb 存储卡（sdb），又增加了一个带有一个分区 -hda1- 的 IDE 硬盘 ，接着该用户又增加了一个 SCSI 硬盘 - sdc1 。接着用户移除了 USB 存储卡（sdb）。现在，SCSI 硬盘的名称仍然为 sdc，但如果这个 SCSI 被移除接着再被插入，则它的名称将变为 sdb。虽然还有其他的存储设备存在， 那个 IDE 硬盘的名称仍会有一个 “a”， 因为它是第一个 IDE 硬盘，IDE 设备的命名与 SCSI、 SATA、 FireWire 和 USB 设备要分开计数。 使用 TestDisk 进行恢复：每个恢复软件有其不同的功能，特征及支持的不同文件系统。下面是一些关于 使用 TestDisk 在各种文件系统中恢复文件的指南。 FAT16、 FAT32、 exFAT (FAT64)、 NTFS 以及 ext2/3/4：TestDisk 是一个运行在 Linux、 *BSD、 SunOS、 Mac OS X、 DOS 和 Windows 等操作系统下的开源的自由软件。 TestDisk 可以从下面的链接中找到 ：http://www.cgsecurity.org/wiki/TestDisk。TestDisk 也可以通过键入 sudo apt-get install testdisk 来安装。TestDisk 有着许多的功能，但这篇文章将只关注恢复文件这个功能。 使用 root 权限从终端中打开 TestDisk 可以通过键入 sudo testdisk 命令。 现在， TestDisk 命令行应用将会被执行。终端的显示将会改变。TestDisk 询问用户它是否可以保留日志，这完全由用户决定。假如一个用户正从系统存储中恢复文件，则不必保留日志。可选择的选项有“生成”、 “追加” 和 “无日志”。假如用户想保留日志，则日志将会保留在该用户的主目录。 在接着的屏幕中，存储设备以 /dev/*的方式被罗列出来。对于我的系统，系统的存储单元为 /dev/sda，这意味着我的存储单元为 一个 SATA硬盘（sd）且它是第一个硬盘（a）。每个存储单元的容量以 Gigabyte（千兆字节）为单位显示的。使用上下键来选择一个存储设备然后点击进入。 下一屏显示出一个列有分区表（也叫做分区映射表）的清单。正如文件有文件配置表，分区有着分区表。分区是存储设备上的分段。例如在几乎所有的 Linux 系统中，至少存在两种分区类型 - EXT3/4 和 Swap 。每一个分区表将会在下面被简要地描述。TestDisk 并不支持所有类型的分区表，所以这并不是完整的列表。 Intel - 这类分区表在 Windows 系统和许多的 Linux 系统中非常普遍，它也常常称作 MBR 分区表。 EFI GPT - 这种类型的分区表通常用在 Linux 系统中。对于 Linux 系统，这种分区表是最为推荐的， 因为逻辑分区或扩展分区的概念并不适用于 GPT (GUID Partition Table) 分区表。 这意味着，如果每个分区中有一个 Linux 系统，一个 Linux 用户可以从多种类型的 Linux 系统中进行多重启动。当然使用 GPT 分区表还有其他的优势，但那些已超出了本文的讨论范围。 Humax - Humax 分区映射表适用于韩国公司 Humax 生产的设备。 Mac - Apple 分区映射表 (APM) 适用于 Apple 的设备。 None - 某些设备并没有分区表。例如，许多 Subor 游戏控制台不使用分区映射表。如果一个用户试图以其它分区表类型从这类设备中恢复文件，用户就会困扰 TestDisk 为何找卟到任何的文件系统或者文件。 Sun - Sun 分区表适用于 Sun 系统。 Xbox -Xbox 适用于使用 Xbox 分区映射表的存储设备。 假如用户选择了 “Xbox” ，尽管他的系统使用了 GPT 分区表， 那么 TestDisk 将不能找到任何分区或文件系统。假如 TestDisk 按照用户的选择执行，则它可能猜测错误。（下面的图片显示的是当分区表类型错误时的输出） 当用户为他们的设备选择了正确的选项，则在下一屏中，选择 “高级” 选项。 现在，用户将看到一个列有用户存储设备中所有的文件系统或分区的列表。假如用户选择了错误的分区映射表，则在这一步中用户就将会知道他们做出了错误的选择。假如没有错误，通过移动文字光标来高亮选择含有被删除文件的分区。使用 左右键来高亮位于终端底部的 “列表”。接着，按下回车确认。 新的一屏便会呈现出列有文件和目录的列表。那些白色的文件名就是未被删除的文件，而红色的文件名是那些已被删除的文件。最右边的一列是文件的名称，从右到左方向的接着一列是文件的创建日期，再往左的一列是文件的大小（以 byte/ 比特为单位），最左边带有“-”，“d” ,“r”, “w” 和”x”的一列则代表的是文件的权限情况。“d” 表示该文件为一个目录，其他的权限术语与本文关系不大。在列表的最顶端以“.”代表的一项表示当前目录，第二行以”..”代表的一项表示当前目录的上级目录，所以用户可以通过选择目录所在行到达该目录。 举个例子，我想进入”Xaiml_Dataset” 目录，该目录基本上由被删除的文件组成。通过按键盘上的 “c”键，我将恢复文件 “computers.xaiml”，接着我被询问选择一个目标目录，当然，我应该放置该文件到另一个分区中。现在，当我在我的家目录时，按下了“c”键。（选择目标目录时）哪个目录被高亮并没有什么影响，当前目录就是目标目录，在屏幕的上方，将会显示“复制完成”的消息。在我的家目录中便会有一个名为”Xaiml_Dataset”的目录，里面里有一个 Xaiml 文件。 假如我在更多的已删除文件上按“c” 键，则这些文件将会被放置到新的文件夹中而无需再向我询问目标目录。 当这些步骤完成后，重复按“q”键直到看到正常的终端模样。目录”Xaiml_Dataset” 只能被 root 用户访问。为了解决这个问题，使用 root 权限改变该目录及其子目录的权限。做完这些后，文件便被恢复了且用户可以访问它们。 特别的 ReiserFS：为了从 ReiserFS 文件系统中恢复一个文件，首先需将分区中的所有文件做一个备份。因为如果发生某些错误， 这个方法可能会引起文件丢失。接着执行下面的命令，其中 DEVICE指的是那些以 sda2 形式命名的设备。一些文件将被放入 lost+found 目录而其他则会保存到原先被删除的位置。 reiserfsck --rebuild-tree --scan-whole-partition /dev/DEVICE 恢复被某个程序打开的删除文件：假设用户意外地删除了一个文件，且该文件被某个程序打开。虽然在硬盘中该文件被删除了，但这个程序正使用着位于 RAM 中的该文件的副本。幸好，我们有两种简单的解决方法来恢复该文件。 假如这个软件有保存功能，如文本编辑器，则用户可以重新保存该文件，这样，文本编辑器可以将该文件写入硬盘中。 假设在音乐播放器中有一个 MP3 文件，而该音乐播放器并不能保存该 MP3 文件，则这种情形下需要比先前花更多的时间来恢复文件。不幸的是，这种方法并不能保证在所有的系统和应用中有效。首先，键入下面的命令。 lsof -c smplayer | grep mp3 上面的命令会列出所有由 smplayer 使用的文件，这个列表由 grep 命令通过管道搜索 mp3 。命令的输入类似于下面： smplayer 10037 collier mp3 169r 8,1 676376 1704294 /usr/bin/smplayer 现在，键入下面的命令来直接从 RAM（在 Linux 系统中，/proc/映射到 RAM）中恢复文件，并复制该文件到选定的文件夹中。其中 cp 指的是复制命令，输出中的数字 10037 来自于进程数，输出中的数字 169 指的是文件描述符，”~/Music/“为目标目录，最后的 “music.mp3” 为用户想恢复的文件的名称。 cp /proc/10037/fd/169 ~/Music/music.mp3 真正的删除：为确保一个文件不能被恢复，可以使用一个命令来 “擦除” 硬盘。擦除硬盘实际上是向硬盘中写入无意义的数据。例如，许多擦除程序向硬盘中写入零，随机字母或随机数据。不会有空间被占用或丢失，擦除程序只是对空位进行重写覆盖。假如存储单元被文件占满而没有空余空间，则所有先前被删除的文件将会消失而不能恢复。 擦除硬盘的目的是确保隐私数据不被他人看见。举个例子，一个公司可能预订了一些新的电脑，总经理决定将旧的电脑卖掉，然而，新的电脑拥有者可能会看到公司的一些机密或诸如信用卡号码，地址等顾客信息。幸好，公司的电脑技术人员可以在卖掉这些旧电脑之前，擦除这些硬盘。 为了安装擦除程序 secure-delete，键入 sudo apt-get install secure-delete,这个命令将会安装一个包含 4 个程序的程序集，用以确保被删除的文件不能被恢复。 srm - 永久删除一个文件。使用方法： srm -f ./secret_file.txt sfill - 擦除空白空间。使用方法: sfill -f /mount/point/of/partition sswap - 擦除 swap 空间。使用方法: sswap -f /dev/SWAP_DEVICE 假如电脑实际去清除那些删除的文件，那么就需要花费更长的时间去执行删除任务。将某些空间标记为空位是快速且容易的，但使得文件永远消失需要花费一定的时间。例如，擦除一个存储单元，可能需要花费几个小时的时间（根据磁盘容量大小）。总之，现在的系统工作的就挺好，因为即便用户清空了垃圾箱，他们仍然有另一次机会来改变他们当初的想法（或错误）。 via: http://www.linux.org/threads/undelete-files-on-linux-systems.4316/public: https://linux.cn/article-4938-1.html 作者：DevynCJohnson译者：FSSlc校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","tags":[{"name":"翻译","slug":"翻译","permalink":"https://fsslc.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"文件回复","slug":"文件回复","permalink":"https://fsslc.github.io/tags/%E6%96%87%E4%BB%B6%E5%9B%9E%E5%A4%8D/"},{"name":"TestDisk","slug":"TestDisk","permalink":"https://fsslc.github.io/tags/TestDisk/"}]}]